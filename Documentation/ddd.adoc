= Smartbook Project Detailed Design Document (DDD) - Complete and Final Document
:author: Gemini AI Assistant
:revdate: 2025-12-13
:doctype: article
:toc: left
:toclevels: 3
:sectnums:

== Introduction and Scope

This Detailed Design Document (DDD) specifies the internal structure, data formats, exact interfaces, and core algorithms for the key components of the Smartbook Reader and Creator tools, ensuring synchronized documentation for implementation.

== Data Structure Specification

This section defines the precise structure for the data persisted within the Smartbook Cartridge.

=== Form Definition JSON Schema (form_schema_json)

The JSON schema defining form fields and validation rules, stored in the `Form_Definitions` table.

==== Top-Level Schema Structure

[cols="2, ^1, 4, ^1, 2"]
|===
^.^| Key ^.^| Type ^.^| Description ^.^| Required? ^.^| Example Value

| `schemaVersion` | String | Versioning for the form schema. | Yes | `1.0`
| `formId` | String | A unique, permanent identifier for the form. | Yes | `character_sheet_v3`
| `formTitle` | String | The human-readable title of the form. | Yes | `D&D 5e Character Sheet`
| `fields` | Array | An ordered array containing field definitions. | Yes | `[...]`
|===

// NOTE: Detailed Field Object Definition and Validation Rules follow in implementation documentation.

== Initial Smartbook Cartridge SQLite Schema

The following tables define the structure of the Smartbook Cartridge (`.sqlite` file).

=== `Metadata` Table (UPDATED)

[cols="2, ^1,^ 3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `id` | INTEGER | PRIMARY KEY | Internal primary key.
| **`cartridge_guid`** | **TEXT** | **NOT NULL, UNIQUE** | **A UUID Version 4 string. The definitive, immutable unique identifier for the content edition (NFR-3.2).**
| `title` | TEXT | NOT NULL | Human-readable title of the Smartbook.
| `author` | TEXT | NOT NULL | Author name(s).
| `publisher` | TEXT | | Publisher name. May be NULL for self-published works.
| `version` | TEXT | NOT NULL | Content Edition/Revision (e.g., "2.0").
| **`publication_year`** | **TEXT** | **NOT NULL** | **The year the content was first published (e.g., "2025").**
| `tags_json` | TEXT | | JSON array of descriptive tags/subjects.
| `cover_image_path` | TEXT | | Relative path to the front cover image file.
| `schema_version` | TEXT | NOT NULL | Smartbook Format Specification version (e.g., "1.0").
|===

=== `Content_Pages` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `page_id` | INTEGER | PRIMARY KEY | Unique ID for the page.
| `page_order` | INTEGER | NOT NULL, UNIQUE | Order of the page in the book structure.
| `chapter_title` | TEXT | | Title of the chapter/section this page belongs to.
| `html_content` | TEXT | NOT NULL | The primary HTML body content.
| `associated_css` | TEXT | | Inline CSS or reference to a style sheet. This CSS controls the **structure** of the page (layout, positioning, spacing, margins, borders, display properties, etc.). Color and font styling is controlled by content themes (see `Content_Themes` table).
|===

**CSS vs Theme Distinction:**
* **`associated_css`:** Controls **structural** aspects - layout (flexbox, grid, positioning), spacing (margins, padding), borders, display properties, etc.
* **Content Themes (`Content_Themes` table):** Controls **visual** aspects - colors (background, text, links), fonts (family, size, weight), typography styling

=== `Form_Definitions` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `form_id` | TEXT | PRIMARY KEY | Unique identifier referenced by the WebChannel API.
| `form_schema_json` | TEXT | NOT NULL | The complete JSON schema defining the form fields and validation.
| `form_version` | INTEGER | NOT NULL, DEFAULT 1 | Version number of the form schema. Incremented when form structure changes significantly.
| `migration_rules_json` | TEXT | | Optional JSON structure containing migration rules for upgrading user data from previous form versions. NULL if no migration rules defined.
|===

=== `User_Data` Table

[cols="2, 1, 3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `data_id` | INTEGER | PRIMARY KEY | Unique ID for the saved data entry.
| `form_key` | TEXT | NOT NULL | The `form_id` that this data belongs to.
| `form_version` | INTEGER | | Version of the form schema when this data was saved. NULL for data saved before versioning was implemented (treated as version 1).
| `migrated_from_version` | INTEGER | | If this data was migrated from an older form version, this field stores the source version number. NULL if data was saved directly to current version.
| `timestamp` | INTEGER | NOT NULL | UNIX timestamp of when the data was saved.
| `serialized_data` | TEXT | NOT NULL | The final, validated JSON string of user inputs.
|===

=== `Settings` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `setting_key` | TEXT | PRIMARY KEY | Unique identifier for the setting (e.g., `default_font_size`, `default_font_family`, `default_theme`, `page_margins`, `line_spacing`).
| `setting_value` | TEXT | NOT NULL | The value of the setting. May be a simple value (e.g., "14") or JSON for complex settings (e.g., `{"top": 10, "bottom": 10, "left": 15, "right": 15}` for margins).
| `setting_type` | TEXT | NOT NULL | Data type of the setting: `string`, `integer`, `float`, `boolean`, `json`.
| `description` | TEXT | | Optional human-readable description of what the setting controls.
|===

**Purpose:** Stores author-defined rendering defaults for the smartbook cartridge. These settings are part of the cartridge itself, defined by the author to provide initial display preferences. Users can override these settings, but the original author-defined defaults are preserved in the cartridge to enable resetting to the author's intended appearance.

**Common Settings:**
* `default_font_size` - Default font size in points (integer)
* `default_font_family` - Default font family name (string)
* `default_theme` - Default theme preference: `light`, `dark`, `sepia` (string)
* `page_margins` - Page margin settings in pixels (JSON: `{"top": X, "bottom": Y, "left": Z, "right": W}`)
* `line_spacing` - Line spacing multiplier (float, e.g., 1.5)
* `text_alignment` - Default text alignment: `left`, `right`, `center`, `justify` (string)

=== `Embedded_Apps` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `app_id` | TEXT | PRIMARY KEY | Unique identifier for the embedded application (matches `appId` in manifest JSON).
| `app_name` | TEXT | NOT NULL | Human-readable name of the application.
| `manifest_json` | TEXT | NOT NULL | Complete `Embedded_App_Manifest` JSON structure defining the app's metadata, entry points, and resource requirements.
| `entry_html` | TEXT | NOT NULL | The primary HTML entry point for the application (SPA root HTML).
| `js_code` | BLOB | | Compiled or minified JavaScript code for the application. May be NULL if using external scripts.
| `css_code` | BLOB | | CSS stylesheet code for the application. May be NULL if using external stylesheets.
| `additional_resources` | BLOB | | ZIP archive or JSON manifest of additional resources (images, fonts, data files) required by the app. May be NULL.
|===

**Note:** Embedded applications are Single Page Applications (SPAs) or similar interactive components that operate **locally only** within a sandboxed environment. They provide functionality such as character generators, calculators, design tools, etc., but have **no network access** and can only access a local sandbox file system.

=== `Settings` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `setting_key` | TEXT | PRIMARY KEY | Unique identifier for the setting (e.g., `default_font_size`, `default_font_family`, `default_theme`, `page_margins`, `line_spacing`).
| `setting_value` | TEXT | NOT NULL | The value of the setting (stored as string, may represent numbers, JSON, or other types).
| `setting_type` | TEXT | NOT NULL | Type of the setting value: `string`, `number`, `boolean`, `json` (for complex settings).
| `description` | TEXT | | Optional human-readable description of what the setting controls.
|===

**Purpose:** Stores book-specific rendering defaults defined by the author. These settings provide initial values for how the content should be displayed in the Reader. Users can override these settings, but the original cartridge defaults are preserved to allow resetting to author's intended appearance.

**Common Settings:**
* `default_font_size` - Default font size in points (e.g., "12")
* `default_font_family` - Default font family name (e.g., "Georgia", "Arial")
* `default_theme` - Default theme preference (e.g., "light", "dark", "sepia")
* `page_margins` - Page margin settings (JSON: `{"top": 20, "bottom": 20, "left": 30, "right": 30}`)
* `line_spacing` - Line spacing multiplier (e.g., "1.5")
* `text_alignment` - Default text alignment (e.g., "left", "justify")
* `page_width` - Preferred page width (e.g., "800px" or "100%")

=== `Content_Themes` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `theme_id` | TEXT | PRIMARY KEY | Unique identifier for the content theme (e.g., "light-content", "dark-content").
| `theme_name` | TEXT | NOT NULL | Human-readable name of the theme (e.g., "Light Content", "Dark Content").
| `is_builtin` | INTEGER | NOT NULL, DEFAULT 0 | Boolean flag: 1 for built-in themes (immutable), 0 for custom themes.
| `theme_config_json` | TEXT | NOT NULL | JSON structure containing theme configuration (colors, fonts, styling).
| `is_active` | INTEGER | DEFAULT 0 | Boolean flag: 1 if this theme is currently applied to the cartridge.
|===

**Purpose:** Stores content themes for smartbook cartridges. Themes define how content is rendered (colors, fonts, styling) and can be applied to control the appearance of content in the Reader. Built-in themes are immutable; custom themes can be created, modified, and deleted by authors.

**Theme Configuration JSON Structure:**
[source,json]
----
{
  "coreColors": {
    "primary": "#1976D2",
    "onPrimary": "#FFFFFF",
    "surface": "#FFFFFF",
    "onSurface": "#000000",
    "background": "#F5F5F5"
  },
  "fonts": {
    "heading": "Georgia, serif",
    "body": "Arial, sans-serif",
    "monospace": "Courier New, monospace"
  },
  "styling": {
    "linkColor": "#1976D2",
    "emphasisStyle": "italic",
    "codeBackground": "#F5F5F5"
  }
}
----

=== `Cartridge_Security` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `digest_type` | TEXT | NOT NULL | Hash algorithm used. **SHALL** be "SHA-256" for Phase 1.
| `hash_digest` | BLOB | NOT NULL | The binary hash of the critical content tables (H1).
| `digital_signature` | BLOB | NOT NULL | The H1 hash signed by the author's private key.
| `public_key_fingerprint` | TEXT | NOT NULL | Fingerprint of the public key used for verification.
| `certificate_data` | BLOB | | The X.509 certificate (DER or PEM format) used for signing. Required for Level 1 (CA-signed) and Level 2 (self-signed) cartridges.
|===

=== `Navigation_Structure` Table

[cols="2, ^1, ^3, 4"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `nav_id` | INTEGER | PRIMARY KEY | Unique ID for the navigation entry.
| `group_name` | TEXT | NOT NULL | Name of the navigation group (e.g., "Browse", "Departments", "Bibliographies").
| `group_order` | INTEGER | NOT NULL | Display order of the navigation group (lower numbers appear first).
| `item_label` | TEXT | NOT NULL | Display label for the menu item.
| `item_order` | INTEGER | NOT NULL | Display order of the item within its group.
| `target_type` | TEXT | NOT NULL | Type of navigation target: `page_id`, `anchor_id`, `page_and_anchor`, `custom_handler`.
| `target_value` | TEXT | NOT NULL | Navigation target value:
  * For `page_id`: The page_id to navigate to
  * For `anchor_id`: The anchor ID (assumes current page)
  * For `page_and_anchor`: Format "page_id#anchor_id"
  * For `custom_handler`: Custom JavaScript handler identifier
| `parent_item_id` | INTEGER | | Optional parent item ID for hierarchical navigation (sub-menus). NULL for top-level items.
| `metadata_json` | TEXT | | Optional JSON object containing additional metadata (e.g., icon path, tooltip, filter criteria for Browse navigation).
|===

**Purpose:** Stores custom navigation bar structure for cartridges. This enables magazine collections and similar content to provide specialized navigation (Browse by Creator/Issue/Title, Departments, Bibliographies, etc.) separate from the application menu.

**Navigation Structure Examples:**

**Browse Group:**
* Group: "Browse" (group_order: 1)
  * Item: "By Creator" (item_order: 1, target_type: "custom_handler", target_value: "browse_by_creator")
  * Item: "By Issue" (item_order: 2, target_type: "custom_handler", target_value: "browse_by_issue")
  * Item: "By Title" (item_order: 3, target_type: "custom_handler", target_value: "browse_by_title")

**Departments Group:**
* Group: "Departments" (group_order: 2)
  * Item: "Department 1" (item_order: 1, target_type: "page_id", target_value: "42")
  * Item: "Department 2" (item_order: 2, target_type: "page_id", target_value: "58")

**Bibliographies Group:**
* Group: "Bibliographies" (group_order: 3)
  * Item: "APA Format" (item_order: 1, target_type: "page_and_anchor", target_value: "100#apa-bibliography")
  * Item: "CMS Format" (item_order: 2, target_type: "page_and_anchor", target_value: "100#cms-bibliography")

**Metadata JSON Structure:**
[source,json]
----
{
  "icon": "path/to/icon.png",
  "tooltip": "Browse articles by creator name",
  "filter_criteria": {
    "type": "creator",
    "field": "author"
  }
}
----

== Reader Local Persistence Schema

These tables exist in a separate, local SQLite database maintained by the Reader Application for user preferences, security, and library management.

=== `Local_Library_Manifest` Table (UPDATED)

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `manifest_id` | INTEGER | | Internal primary key.
| `cartridge_guid` | TEXT | NOT NULL, UNIQUE (FK) | The unique ID (UUID v4) of the cartridge.
| `cartridge_hash` | BLOB | NOT NULL | The content hash (H2) for integrity checking.
| `local_path` | TEXT | NOT NULL | Full file path on the user's system.
| `title` | TEXT | NOT NULL | Extracted Title.
| `author` | TEXT | NOT NULL | Extracted Author.
| `publisher` | TEXT | | Cached publisher name from cartridge Metadata table (for fast queries).
| `version` | TEXT | | Extracted Content Version.
| **`publication_year`** | **TEXT** | **NOT NULL** | **Cached publication year for fast List-View display.**
| `cover_image_data` | BLOB | | The binary data of the cover image for fast browsing.
| `last_opened` | INTEGER | | Timestamp of last access.
| `location_status` | TEXT | | **Phase 2:** Tracks local/remote status (`local_only`, `remote_only`, `both`).
| `series_name` | TEXT | | Cached series name from cartridge Metadata table (for fast grouping queries).
| `edition_name` | TEXT | | Cached edition name from cartridge Metadata table (for fast grouping queries).
| `series_order` | INTEGER | | Cached series order from cartridge Metadata table (for fast series ordering).
|===

=== `Local_Trust_Registry` Table

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `trust_id` | INTEGER | PRIMARY KEY | Unique ID for the trust entry.
| `cartridge_guid` | TEXT | NOT NULL, UNIQUE (FK) | The unique ID of the cartridge.
| `trust_level` | TEXT | NOT NULL | The initial signature trust level (Level 1, 2, or 3).
| `app_trust_policy` | TEXT | NOT NULL | User's decision: `PERSISTENT`, `SESSION`, or `REVOKED`.
| `timestamp` | INTEGER | NOT NULL | When the trust decision was made.
|===

=== `Local_User_Settings` Table

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `settings_id` | INTEGER | PRIMARY KEY | Unique ID for the settings entry.
| `cartridge_guid` | TEXT | NOT NULL (FK) | The unique ID of the cartridge these settings apply to.
| `setting_key` | TEXT | NOT NULL | The setting key (matches `setting_key` in cartridge `Settings` table).
| `setting_value` | TEXT | NOT NULL | The user's override value for this setting.
| `timestamp` | INTEGER | NOT NULL | When the setting was last modified.
|===

**Purpose:** Stores user preference overrides for cartridge rendering settings. These overrides take precedence over author-defined defaults from the cartridge's `Settings` table, but the original author defaults are preserved in the cartridge for reset functionality.

**Unique Constraint:** `(cartridge_guid, setting_key)` - One user override per setting per cartridge.

**Settings Priority:** When loading a cartridge, settings are applied in this order:
. User override from `Local_User_Settings` (if exists)
. Author default from cartridge `Settings` table (if exists)
. Application default (hardcoded fallback)

=== `Local_Bookmarks` Table

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `bookmark_id` | INTEGER | PRIMARY KEY | Unique ID for the bookmark.
| `cartridge_guid` | TEXT | NOT NULL (FK) | The unique ID of the cartridge this bookmark belongs to.
| `page_id` | INTEGER | NOT NULL | The `page_id` from the cartridge's `Content_Pages` table.
| `anchor_id` | TEXT | | Optional anchor identifier (e.g., heading ID, element ID) within the page.
| `bookmark_label` | TEXT | NOT NULL | User-provided label/name for the bookmark.
| `timestamp` | INTEGER | NOT NULL | When the bookmark was created.
| `scroll_position` | INTEGER | | Optional scroll position (pixels from top) for precise position restoration.
|===

**Purpose:** Stores user-created bookmarks for quick navigation to specific pages or positions within pages.

**Unique Constraint:** `(cartridge_guid, page_id, anchor_id)` - Prevents duplicate bookmarks for the same location.

=== `Local_Reading_Position` Table

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `position_id` | INTEGER | PRIMARY KEY | Unique ID for the reading position entry.
| `cartridge_guid` | TEXT | NOT NULL, UNIQUE (FK) | The unique ID of the cartridge (one reading position per cartridge).
| `page_id` | INTEGER | NOT NULL | The `page_id` from the cartridge's `Content_Pages` table where reading stopped.
| `anchor_id` | TEXT | | Optional anchor identifier (e.g., heading ID, element ID) within the page.
| `scroll_position` | INTEGER | | Optional scroll position (pixels from top) for precise position restoration.
| `last_access_timestamp` | INTEGER | NOT NULL | Timestamp of when the cartridge was last accessed.
|===

**Purpose:** Stores the last reading position for each cartridge, enabling automatic restoration of reading position when cartridge is reopened.

=== `Local_Cartridge_Groups` Table

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `group_id` | INTEGER | PRIMARY KEY | Unique ID for the group.
| `group_name` | TEXT | NOT NULL | User-defined name for the group/collection.
| `group_type` | TEXT | NOT NULL | Type of group: `custom_collection` (user-defined), `series` (auto-grouped by series_name), `edition` (auto-grouped by edition_name).
| `created_timestamp` | INTEGER | NOT NULL | UNIX timestamp when the group was created.
| `last_modified_timestamp` | INTEGER | NOT NULL | UNIX timestamp when the group was last modified.
| `description` | TEXT | | Optional user-provided description of the group.
|===

**Purpose:** Stores user-defined custom collections and metadata for auto-grouped series/editions. Custom collections allow users to organize cartridges independently of author-defined series/edition metadata.

**Group Types:**
* **`custom_collection`:** User-created collection (e.g., "My RPG Collection", "Favorites")
* **`series`:** Auto-grouped by `series_name` metadata (read-only, managed by system)
* **`edition`:** Auto-grouped by `edition_name` metadata (read-only, managed by system)

=== `Local_Cartridge_Group_Members` Table

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `membership_id` | INTEGER | PRIMARY KEY | Unique ID for the membership record.
| `group_id` | INTEGER | NOT NULL | Foreign key to `Local_Cartridge_Groups.group_id`.
| `cartridge_guid` | TEXT | NOT NULL | Foreign key to `Local_Library_Manifest.cartridge_guid`.
| `added_timestamp` | INTEGER | NOT NULL | UNIX timestamp when the cartridge was added to the group.
| `display_order` | INTEGER | | Optional display order within the group (for custom collections). NULL for auto-grouped series/editions (uses series_order from metadata).
|===

**Purpose:** Junction table linking cartridges to groups (custom collections, series, or editions). For custom collections, users can manually add/remove cartridges. For series/editions, memberships are automatically maintained based on metadata.

**Constraints:**
* Unique constraint on (`group_id`, `cartridge_guid`) to prevent duplicate memberships
* Foreign key constraints ensure referential integrity

=== `Local_Window_State` Table

[cols="2, ^1, ^3, 4", options="headers"]
|===
^.^| Column Name ^.^| SQLite Type ^.^| Constraints ^.^| Description

| `state_id` | INTEGER | PRIMARY KEY | Unique ID for the window state entry.
| `cartridge_guid` | TEXT | NOT NULL, UNIQUE (FK) | The unique ID of the cartridge (one window state per cartridge).
| `window_width` | INTEGER | NOT NULL | Window width in pixels.
| `window_height` | INTEGER | NOT NULL | Window height in pixels.
| `window_x` | INTEGER | NOT NULL | Window X position (left edge) in screen coordinates.
| `window_y` | INTEGER | NOT NULL | Window Y position (top edge) in screen coordinates.
| `is_maximized` | INTEGER | NOT NULL | Boolean flag (0 = false, 1 = true) indicating whether window was maximized.
| `last_updated` | INTEGER | NOT NULL | Timestamp when window state was last saved.
|===

**Purpose:** Stores window geometry and state (size, position, maximized state) for each cartridge, enabling restoration of window appearance when cartridge is reopened.

**Unique Constraint:** `(cartridge_guid)` - One window state entry per cartridge.

**Update Strategy:** On cartridge close or page navigation, update or insert record for `cartridge_guid` with current `page_id`, `anchor_id`, `scroll_position`, and `last_access_timestamp`.

== Component Interface Specification

=== WebChannel Bridge API (SmartbookBridge)

==== Core API Methods Summary

[cols="2, 3, ^2, 4", options="headers"]
|===
^.^| C++ Method Name ^.^| JS Method Signature ^.^| Return Type (JS) ^.^| Purpose

| `saveFormData` | `saveFormData(formId, dataJson, callback)` | Boolean | Persists user data from a form into the `User_Data` table.
| `loadFormData` | `loadFormData(formId, callback)` | JSON String | Retrieves the most recent serialized data for a specific form ID.
| `logMessage` | `logMessage(level, message)` | void | Sends debug/error messages to the native C++ logging system.
| `requestAppConsent`| `requestAppConsent(appId, callback)` | Boolean | Triggers the native modal dialog for embedded app security consent.
|===

==== Persistence Layer Interactions (Reader Core)

[cols="2, 2, 4", options="headers"]
|===
^.^| Core Operation ^.^| Database Operation ^.^| Rationale

| **`loadFormData`** | `SELECT` from `User_Data` | Retrieves the *latest* data record: `ORDER BY timestamp DESC LIMIT 1`
| **`saveFormData`** | `INSERT` into `User_Data` | Creates a new, immutable record.
| **Integrity Check** | `SELECT` from `Cartridge_Security` | Read security parameters upon cartridge load.
| **Content Loading** | `SELECT` from `Content_Pages` | Retrieves HTML/CSS based on navigation requests.
| **Form Rendering** | `SELECT` from `Form_Definitions` | Retrieves `form_schema_json`.
|===

== Form Rendering and Interaction Specification

This section defines how forms are embedded, rendered, and interacted with in the Reader application.

=== Form Embedding in Content Pages

Forms are embedded within content pages using a special HTML marker element. The Reader detects these markers and dynamically renders the corresponding form definition.

==== Embedding Syntax

Forms are embedded in `Content_Pages.html_content` using one of the following patterns:

**Pattern 1: Data Attribute (Recommended)**
[source,html]
----
<div data-smartbook-form="form_id" data-form-instance="optional_instance_id"></div>
----

**Pattern 2: Custom Element (Alternative)**
[source,html]
----
<smartbook-form form-id="form_id" instance-id="optional_instance_id"></smartbook-form>
----

**Parameters:**
* `form_id` (required): The `form_id` from the `Form_Definitions` table
* `instance_id` (optional): Unique identifier for this form instance, allowing multiple instances of the same form on different pages

==== Form Detection and Rendering Flow

. **Content Loading:** Reader loads `html_content` from `Content_Pages` table
. **Form Marker Detection:** Reader scans HTML for form markers (`data-smartbook-form` attribute or `<smartbook-form>` elements)
. **Form Definition Retrieval:** For each detected marker, Reader queries `Form_Definitions` table using `form_id`
. **JSON Schema Parsing:** Reader parses `form_schema_json` to extract field definitions
. **HTML Form Generation:** Reader generates standard HTML form elements based on field definitions
. **Form Injection:** Reader replaces form marker with generated HTML form
. **Data Loading:** Reader loads saved form data (if any) and populates form fields
. **Event Binding:** Reader binds form events (submit, change, validation) to WebChannel API

=== Form Rendering Algorithm

The Reader converts form definition JSON schema to HTML form elements using the following mapping:

==== Field Type to HTML Element Mapping

[cols="2, 2, 4", options="headers"]
|===
^.^| Field Type ^.^| HTML Element ^.^| Notes

| `text` | `<input type="text">` | Standard text input
| `number` | `<input type="number">` | Numeric input with min/max validation
| `email` | `<input type="email">` | Email input with format validation
| `url` | `<input type="url">` | URL input with format validation
| `date` | `<input type="date">` | Date picker input
| `time` | `<input type="time">` | Time picker input
| `textarea` | `<textarea>` | Multi-line text input
| `select` | `<select>` with `<option>` elements | Dropdown selection
| `radio` | `<input type="radio">` | Radio button group
| `checkbox` | `<input type="checkbox">` | Checkbox input
| `group` | `<fieldset>` with `<legend>` | Grouping container for nested fields
|===

==== Form Structure Generation

**Algorithm:**
. Create `<form>` element with `id="smartbook-form-{formId}-{instanceId}"`
. Add form title as `<h2>` or `<legend>` if `formTitle` is defined
. Iterate through `fields` array in order:
   a. For each field, generate appropriate HTML element based on `fieldType`
   b. Set `name` attribute to `fieldId`
   c. Set `id` attribute to `{formId}-{fieldId}-{instanceId}`
   d. Apply `defaultValue` if present
   e. Apply `placeholder` if present
   f. Apply validation attributes (`required`, `min`, `max`, `pattern`, etc.)
   g. For `group` type, create `<fieldset>` and recursively process `children` array
. Add form action buttons: "Save", "Reset", "Print" (if enabled)
. Apply CSS classes for styling: `smartbook-form`, `smartbook-form-field`, etc.

=== Form Validation

==== Client-Side Validation

Validation is performed using HTML5 validation attributes and custom JavaScript validation:

**HTML5 Attributes Applied:**
* `required` - If `validation.required === true`
* `min` / `max` - For numeric fields (`validation.min`, `validation.max`)
* `minlength` / `maxlength` - For text fields (`validation.minLength`, `validation.maxLength`)
* `pattern` - For regex validation (`validation.pattern`)
* `type` - For email, url, date, time fields

**Custom Validation:**
* Custom validation rules are enforced via JavaScript event handlers
* Validation errors are displayed inline using HTML5 `:invalid` pseudo-class and custom error messages
* Error messages are displayed inline using `<span class="error-message">` elements

==== Validation Error Display

**Error Display Pattern:**
[source,html]
----
<div class="form-field">
  <label for="field-id">Field Label</label>
  <input type="text" id="field-id" name="fieldId" required>
  <span class="error-message" id="field-id-error" role="alert"></span>
</div>
----

**Error Message Population:**
* Error messages are populated from `validation.errorMessage` in form schema
* If no custom message, default HTML5 validation messages are used
* Error messages are displayed immediately on field blur or form submit

=== Form Data Persistence

==== Persistence to Cartridge (`User_Data` Table)

**Save Operation:**
. User clicks "Save" button or auto-save triggers
. Form data is serialized to JSON: `{ "fieldId1": "value1", "fieldId2": "value2", ... }`
. JSON is validated against form schema
. WebChannel API `saveFormData(formId, dataJson, callback)` is called
. C++ core inserts new record into `User_Data` table:
   * `form_key` = `formId`
   * `form_version` = current form version (from `Form_Definitions` table)
   * `migrated_from_version` = NULL (data saved directly to current version)
   * `serialized_data` = validated JSON string
   * `timestamp` = current UNIX timestamp

**Load Operation:**
. Form is rendered
. Reader retrieves current form version from `Form_Definitions` table
. WebChannel API `loadFormData(formId, callback)` is called
. C++ core queries `User_Data` table: `SELECT serialized_data, form_version, migrated_from_version FROM User_Data WHERE form_key = formId ORDER BY timestamp DESC LIMIT 1`
. If saved data version < current form version, apply migration (see "Form Versioning and Data Migration" section)
. JSON data (migrated if necessary) is returned to JavaScript
. Form fields are populated with loaded values

==== Persistence to Sandbox File System

**Save Operation:**
. User selects "Save to Sandbox" option (if available)
. Form data is serialized to JSON
. **File Selection:** Reader presents sandbox file picker dialog:
   a. User can select existing file to overwrite, or
   b. User can enter new filename
   c. File picker is restricted to sandbox directory only (no navigation outside)
   d. Default filename suggested: `{formId}_{instanceId}_data.json`
. WebChannel API `saveSandboxFile(filename, jsonData, callback)` is called
. File is saved to embedded app's sandbox directory
. Embedded app can access file via `loadSandboxFile` API

**Load Operation:**
. Form checks for sandbox file on load
. **File Selection:** Reader provides option to use sandbox file picker:
   a. User can browse available files in sandbox directory
   b. File picker displays list of available JSON files (or all files)
   c. User selects file to load
   d. File picker is restricted to sandbox directory only
. WebChannel API `loadSandboxFile(filename, callback)` is called with selected filename
. JSON data is loaded and form fields are populated

**Sandbox File Picker Requirements:**
* **Security:** File picker MUST be restricted to sandbox directory only
* **Navigation:** User MUST NOT be able to navigate outside sandbox directory
* **File Filtering:** Option to filter by file type (e.g., JSON files only)
* **File Listing:** Display available files in sandbox with metadata (size, date modified)
* **File Selection:** User can select existing file or enter new filename
* **Validation:** Filename validation prevents path traversal and invalid characters

**Use Case:** Enables embedded applications to process form data (e.g., character generators, calculators, design tools)

=== Form Printing

==== Print Functionality

**Print Button:** Forms include a "Print" button that triggers print functionality.

**Print Algorithm:**
. User clicks "Print" button
. Form is cloned and transformed for printing:
   a. Remove all `<input>`, `<select>`, `<textarea>` elements
   b. Replace with `<span>` or `<div>` elements displaying current field values
   c. Apply print-specific CSS (`@media print`)
   d. Hide form action buttons
   e. Show field labels and values in print-friendly format
. Browser print dialog is triggered (`window.print()`)
. Print preview shows form with values, not input controls

**Print CSS:**
[source,css]
----
@media print {
  .smartbook-form input,
  .smartbook-form select,
  .smartbook-form textarea {
    display: none;
  }
  .smartbook-form .print-value {
    display: inline;
    font-weight: bold;
  }
  .smartbook-form button {
    display: none;
  }
}
----

=== Form State Management

==== Auto-Save

**Configuration:**
* Auto-save interval: Configurable (default: 30 seconds)
* Auto-save trigger: Field blur event or interval timer
* Auto-save scope: Current form instance only

**Implementation:**
. Timer starts when form is loaded
. On field blur or timer expiration, form data is serialized
. If data has changed since last save, `saveFormData` is called
. Visual indicator shows "Saving..." and "Saved" states

==== Form Reset

**Reset to Defaults:**
. User clicks "Reset" button
. All form fields are restored to `defaultValue` from form schema
. Unsaved changes are discarded
. Saved data remains in `User_Data` table (not deleted)

**Clear Form:**
. User selects "Clear" option
. All form fields are set to empty/null values
. Saved data remains in `User_Data` table (not deleted)

=== Multiple Form Instances

**Instance Isolation:**
* Each form instance has unique `instance_id`
* Form data is scoped by `formId` + `instanceId` combination
* Multiple instances of same form can exist on different pages
* Each instance maintains independent data state

**Instance ID Generation:**
* If `instance-id` attribute is provided, use that value
* If not provided, generate unique ID: `{pageId}-{formId}-{timestamp}`

**Data Scoping:**
* When saving: `saveFormData(formId + "-" + instanceId, dataJson, callback)`
* When loading: `loadFormData(formId + "-" + instanceId, callback)`

=== Form Versioning and Data Migration

This section defines how form schemas are versioned and how user data is migrated when form definitions change.

==== Form Versioning Strategy

**Version Number:**
* Each form has a `form_version` integer in the `Form_Definitions` table
* Version starts at 1 for new forms
* Version is incremented when form structure changes significantly (fields added/removed/renamed, validation rules changed, field types changed)

**Version Increment Triggers:**
* **Breaking Changes:** Field removed, field renamed, field type changed, validation rules changed significantly
* **Non-Breaking Changes:** Field added (with default value), field label changed, placeholder text changed, validation rules made more permissive

**Version Tracking:**
* Current form version stored in `Form_Definitions.form_version`
* Form schema JSON also includes `schemaVersion` field (matches `form_version`)
* User data stores `form_version` when saved, allowing Reader to detect version mismatches

==== Form Page Structure

**Dedicated Form Pages:**
* Forms SHALL be placed on dedicated content pages, not intermingled with other content text
* A form page contains only the form marker element: `<div data-smartbook-form="form_id"></div>`
* Form pages may include minimal descriptive text (form title, instructions) but the form itself is the primary content
* Form pages are regular `Content_Pages` entries with form markers

**Form Embedding:**
* Forms are embedded using existing form marker mechanism
* Form builder output is injected at the designated point in the content page
* If a form page already exists, form builder can overwrite it with updated form
* Form pages are identified by presence of form marker in `html_content`

**Rationale:**
* Clear separation between forms and content text
* Easier form management and versioning
* Better user experience (forms are clearly distinct from reading content)
* Simplifies form builder workflow

==== Form Builder Version Management

**Version Management UI:**
* Form Builder displays current form version
* Version increment button/option when making breaking changes
* Version history view showing changes between versions
* Migration mapping interface for defining field mappings

**Version Increment Workflow:**
. Author makes changes to form in Form Builder
. Form Builder detects if changes are breaking (field removed, renamed, type changed)
. If breaking changes detected, prompt author to increment version
. Author can choose to:
   * Increment version and define migration rules
   * Revert changes
   * Save as new form (different `form_id`)

**Migration Mapping Interface:**
* When version is incremented, Form Builder shows migration mapping interface
* Lists all fields from previous version
* For each field, author can:
   * Map to new field (if renamed)
   * Set default value (if field removed)
   * Map to new field with transformation (if field type changed)
* Author can preview migration results before saving

==== Migration Rules JSON Structure

Migration rules are stored in `Form_Definitions.migration_rules_json` as a JSON object:

[source,json]
----
{
  "fromVersion": 1,
  "toVersion": 2,
  "fieldMappings": [
    {
      "oldFieldId": "character_name",
      "newFieldId": "name",
      "action": "rename"
    },
    {
      "oldFieldId": "character_class",
      "newFieldId": "class",
      "action": "rename"
    },
    {
      "oldFieldId": "old_field",
      "action": "remove",
      "defaultValue": ""
    },
    {
      "oldFieldId": "level",
      "newFieldId": "character_level",
      "action": "rename",
      "transform": {
        "type": "type_cast",
        "fromType": "string",
        "toType": "integer"
      }
    }
  ],
  "newFields": [
    {
      "fieldId": "new_field",
      "defaultValue": "default_value"
    }
  ]
}
----

**Migration Rule Actions:**
* **`rename`** - Map old field to new field (field ID changed)
* **`remove`** - Field was removed, use default value
* **`transform`** - Field exists but type changed, apply transformation
* **`copy`** - Copy field value as-is (explicit mapping, optional)

**New Fields:**
* Fields added in new version get default values from schema
* Migration rules can override defaults if needed

==== Form Data Migration Algorithm

**Migration Process:**
. **Load Saved Data:** Retrieve most recent user data for form
. **Check Version:** Compare saved data `form_version` with current form version
. **If Versions Match:** Return data as-is (no migration needed)
. **If Versions Don't Match:**
   a. Load migration rules from `Form_Definitions.migration_rules_json`
   b. If no migration rules, attempt automatic migration (see below)
   c. Apply migration rules to transform data
   d. Validate migrated data against new form schema
   e. If validation fails, load with defaults and warn user
   f. Save migrated data with new version number and `migrated_from_version` set

**Automatic Migration (No Rules Defined):**
* If migration rules are not defined, attempt automatic field mapping:
  * Fields with same `fieldId` are copied as-is
  * Fields that don't exist in new schema are dropped
  * New fields get default values from schema
* Automatic migration only works for compatible changes (field additions, non-breaking changes)
* Breaking changes (field removals, renames, type changes) require explicit migration rules

**Migration Validation:**
* After migration, validate migrated data against new form schema
* Check required fields are present
* Check data types match field types
* Check validation rules pass
* If validation fails:
  * Log warning
  * Load form with defaults
  * Display message to user: "Form has been updated. Some of your previous data could not be migrated. Please review and update your entries."

**Migration Data Saving:**
* When migrated data is saved, set:
  * `form_version` = current form version
  * `migrated_from_version` = original saved data version
* Original data record is preserved (not deleted) for audit trail
* New record is created with migrated data

==== Migration Security Considerations

**Input Validation:**
* Validate migration rules JSON structure before saving
* Validate field mappings reference valid fields in both old and new schemas
* Validate transformation rules (prevent code injection)
* Sanitize default values (prevent XSS in migrated data)

**Data Validation:**
* Always validate migrated data against new form schema
* Reject migrated data that doesn't pass validation
* Never execute arbitrary code during migration
* Type transformations must be safe (string to number, etc.)

**Version Integrity:**
* Prevent version downgrades (could corrupt data)
* Validate version numbers are sequential
* Validate migration rules target correct version range
* Log all migration operations for audit trail

**User Consent:**
* When migration occurs, inform user that form has been updated
* Show which fields were migrated and which were reset to defaults
* Allow user to review migrated data before saving
* Provide option to start fresh (discard old data)

==== Form Builder Migration Interface Specification

**Migration Mapping Dialog:**
* Displayed when author increments form version with breaking changes
* Shows side-by-side comparison: old form fields vs new form fields
* For each old field, author can:
  * Map to new field (dropdown of new fields)
  * Mark as removed (set default value)
  * Apply transformation (type conversion, value mapping)
* Preview button to test migration with sample data
* Save migration rules button

**Migration Preview:**
* Author can enter sample data for old form version
* Preview shows how data would be migrated
* Highlights any fields that would be lost or reset
* Allows author to refine migration rules before saving

**Version History:**
* Form Builder shows version history for form
* Lists all versions with change descriptions
* Shows migration rules for each version transition
* Allows author to view/edit migration rules for previous versions

=== Form Field Undo/Redo

**Undo/Redo Functionality:**
* Support undo/redo operations for text input within form fields
* Maintain undo/redo history per form field independently
* Clear undo/redo history when form field loses focus or when form is saved

**Implementation:**
* Use browser/WebEngine's native undo/redo capabilities for form inputs
* Keyboard shortcuts:
  * **Undo:** Ctrl+Z (Windows/Linux) or Cmd+Z (macOS)
  * **Redo:** Ctrl+Y or Ctrl+Shift+Z (Windows/Linux) or Cmd+Shift+Z (macOS)
* Undo/redo works within the focused form field only
* History is maintained in memory (not persisted)
* History is cleared when:
  * Form field loses focus (blur event)
  * Form data is saved
  * User navigates away from page

**Undo/Redo Scope:**
* Per-field undo/redo history (each form field has its own history)
* History tracks text changes (insertions, deletions, replacements)
* History does not track field-level operations (clearing field, loading data)
* Maximum history depth: Browser default (typically 50-100 operations)

**User Experience:**
* Undo/redo works as users expect in standard text editors
* Visual feedback: Text changes immediately when undo/redo is triggered
* No separate undo/redo UI needed (uses standard keyboard shortcuts)
* Context menu may optionally include "Undo" and "Redo" options when appropriate

== Custom Navigation Bar Implementation Specification

This section defines how custom navigation bars (e.g., Browse, Departments, Bibliographies) are implemented in the Reader application.

=== Navigation Structure Loading

**Load Navigation Structure:**
. On cartridge open, query `Navigation_Structure` table:
   `SELECT * FROM Navigation_Structure ORDER BY group_order, item_order`
. Group results by `group_name`
. Build navigation structure object:
   ```
   {
     "groups": [
       {
         "name": "Browse",
         "order": 1,
         "items": [
           {
             "label": "By Creator",
             "order": 1,
             "target_type": "custom_handler",
             "target_value": "browse_by_creator",
             "metadata": {...}
           },
           ...
         ]
       },
       ...
     ]
   }
   ```

**Navigation Bar Rendering:**
. If navigation structure exists, render custom navigation bar
. Navigation bar is rendered as HTML/CSS within the Reader View
. Navigation bar is positioned above main content area
. Navigation bar uses cartridge styling (CSS from `Content_Pages` or `Content_Themes`)

=== Navigation Bar HTML Structure

[source,html]
----
<nav class="smartbook-navbar" id="custom-navbar">
  <div class="nav-group" data-group="Browse">
    <button class="nav-group-button">Browse ▼</button>
    <ul class="nav-dropdown">
      <li><a href="#" data-target-type="custom_handler" data-target-value="browse_by_creator">By Creator</a></li>
      <li><a href="#" data-target-type="custom_handler" data-target-value="browse_by_issue">By Issue</a></li>
      <li><a href="#" data-target-type="custom_handler" data-target-value="browse_by_title">By Title</a></li>
    </ul>
  </div>
  <div class="nav-group" data-group="Departments">
    <button class="nav-group-button">Departments ▼</button>
    <ul class="nav-dropdown">
      <li><a href="#" data-target-type="page_id" data-target-value="42">Department 1</a></li>
      <li><a href="#" data-target-type="page_id" data-target-value="58">Department 2</a></li>
    </ul>
  </div>
  <div class="nav-group" data-group="Bibliographies">
    <button class="nav-group-button">Bibliographies ▼</button>
    <ul class="nav-dropdown">
      <li><a href="#" data-target-type="page_and_anchor" data-target-value="100#apa-bibliography">APA Format</a></li>
      <li><a href="#" data-target-type="page_and_anchor" data-target-value="100#cms-bibliography">CMS Format</a></li>
    </ul>
  </div>
</nav>
----

=== Navigation Target Resolution

**Page ID Navigation:**
. Extract `target_value` (page_id)
. Load page: `SELECT html_content FROM Content_Pages WHERE page_id = ?`
. Navigate to page (update reading position, add to history)

**Anchor Navigation:**
. Extract `target_value` (anchor_id)
. If on current page: Scroll to anchor element
. If anchor is on different page: Load page first, then scroll to anchor
. Update reading position with `anchor_id`

**Page and Anchor Navigation:**
. Parse `target_value` format: "page_id#anchor_id"
. Load page: `SELECT html_content FROM Content_Pages WHERE page_id = ?`
. After page loads, scroll to anchor element
. Update reading position with both `page_id` and `anchor_id`

**Custom Handler Navigation:**
. Extract `target_value` (handler identifier)
. Execute custom JavaScript handler (if defined in embedded app or content)
. Custom handlers may:
   * Filter content by metadata (Browse by Creator/Issue/Title)
   * Display search results
   * Show filtered content views
   * Navigate to dynamically determined targets

=== Browse Navigation Implementation

**Browse by Creator:**
. Custom handler: `browse_by_creator`
. Query `Content_Pages` for pages with metadata matching creator filter
. Display filtered results or navigate to creator index page
. Filter criteria stored in `metadata_json`:
   ```json
   {
     "filter_criteria": {
       "type": "creator",
       "field": "author",
       "match": "exact"
     }
   }
   ```

**Browse by Issue:**
. Custom handler: `browse_by_issue`
. Query pages filtered by issue metadata
. Display issue index or filtered content view

**Browse by Title:**
. Custom handler: `browse_by_title`
. Query pages filtered by title metadata
. Display title index or filtered content view

=== Department Navigation Implementation

**Department Structure:**
. Departments are defined as navigation items in `Navigation_Structure` table
. Each department item links to a specific page or section
. Departments may have hierarchical structure (parent_item_id for sub-departments)

**Department Navigation:**
. User selects department from dropdown
. Resolve target (page_id, anchor, or custom handler)
. Navigate to department content
. Update reading position and navigation history

=== Bibliography Navigation Implementation

**Bibliography Formats:**
. Bibliography items link to citation format reference pages
. Target format: `page_and_anchor` (e.g., "100#apa-bibliography")
. Navigation loads bibliography reference page and scrolls to format section

**Bibliography Display:**
. Load target page
. Scroll to anchor (format section)
. Display citation format guidelines and examples

=== Navigation Bar CSS Styling

**Default Navigation Bar Styles:**
[source,css]
----
.smartbook-navbar {
  display: flex;
  background-color: #f5f5f5;
  border-bottom: 1px solid #ddd;
  padding: 8px;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-group {
  position: relative;
  margin-right: 16px;
}

.nav-group-button {
  background: none;
  border: none;
  padding: 8px 16px;
  cursor: pointer;
  font-size: 14px;
}

.nav-group-button:hover {
  background-color: #e0e0e0;
}

.nav-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background-color: white;
  border: 1px solid #ddd;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  list-style: none;
  padding: 0;
  margin: 0;
  min-width: 200px;
}

.nav-group:hover .nav-dropdown {
  display: block;
}

.nav-dropdown li {
  padding: 0;
}

.nav-dropdown a {
  display: block;
  padding: 8px 16px;
  text-decoration: none;
  color: #333;
}

.nav-dropdown a:hover {
  background-color: #f0f0f0;
}
----

**Custom Styling:**
* Navigation bar styling can be customized via cartridge CSS
* Styles defined in `Content_Pages.associated_css` or `Content_Themes` apply to navigation bar
* Navigation bar respects cartridge theme colors and fonts

=== Keyboard Navigation

**Navigation Bar Keyboard Access:**
. Tab key: Navigate between navigation groups
. Arrow keys: Navigate within dropdown menus
. Enter/Space: Activate selected menu item
. Escape: Close open dropdown menu

**Implementation:**
* Navigation bar elements have proper ARIA attributes for accessibility
* Keyboard event handlers attached to navigation elements
* Focus management for dropdown menus

== Content Navigation Implementation Specification

This section defines how content navigation, table of contents, bookmarking, and reading position are implemented in the Reader application.

=== Forward/Backward Navigation

**Implementation:**
. Reader maintains current `page_id` and `page_order` for active cartridge
. Forward button: Query `SELECT page_id FROM Content_Pages WHERE page_order = (SELECT page_order FROM Content_Pages WHERE page_id = ?) + 1 LIMIT 1`
. Backward button: Query `SELECT page_id FROM Content_Pages WHERE page_order = (SELECT page_order FROM Content_Pages WHERE page_id = ?) - 1 LIMIT 1`
. At boundaries: Wrap around (configurable) or disable buttons
. On navigation: Update `Local_Reading_Position` table with new `page_id`

**Keyboard Shortcuts:**
* Left Arrow / Page Up: Navigate backward
* Right Arrow / Page Down: Navigate forward
* Home: Navigate to first page
* End: Navigate to last page

=== Table of Contents Generation

**TOC Generation Algorithm:**
. **Primary Structure (Chapters):**
   a. Query `SELECT DISTINCT chapter_title, MIN(page_order) as first_page_order FROM Content_Pages WHERE chapter_title IS NOT NULL GROUP BY chapter_title ORDER BY first_page_order`
   b. For each chapter, query pages: `SELECT page_id, page_order FROM Content_Pages WHERE chapter_title = ? ORDER BY page_order`
   c. Create TOC entry: `{ "type": "chapter", "title": chapter_title, "page_id": first_page_id, "children": [...] }`

. **Secondary Structure (Headings):**
   a. For each page, parse HTML content for heading elements (`<h1>`, `<h2>`, `<h3>`, etc.)
   b. Extract heading text and ID (or generate ID if missing)
   c. Create nested structure based on heading hierarchy
   d. Apply depth limit (default: 2 levels, configurable 1-3)

. **TOC Structure:**
[source,json]
----
{
  "chapters": [
    {
      "title": "Chapter 1",
      "page_id": 1,
      "page_order": 1,
      "headings": [
        {
          "level": 1,
          "title": "Section 1.1",
          "anchor_id": "section-1-1",
          "page_id": 1
        },
        {
          "level": 2,
          "title": "Subsection 1.1.1",
          "anchor_id": "subsection-1-1-1",
          "page_id": 1
        }
      ],
      "children": []
    }
  ]
}
----

**TOC Display:**
* Tree view with collapsible/expandable nodes
* Click on TOC entry navigates to page and scrolls to anchor (if present)
* Visual indicator for current page/section in TOC
* Search/filter capability within TOC

=== Tabbed Pane Interface

**Pane Structure:**
* **Tab 1: Table of Contents**
  * Displays generated TOC tree
  * Collapsible/expandable sections
  * Click to navigate
  
* **Tab 2: Search Results**
  * Displays search results when search is performed
  * Shows matching pages and context snippets
  * Click to navigate to result location

**Implementation:**
* Qt `QTabWidget` or similar tabbed interface
* TOC tab always visible
* Search Results tab appears when search is active
* Both tabs share same navigation target (Reader View)

=== Internal Link Navigation

**Link Processing:**
. Reader intercepts link clicks within content pages
. Parse link href:
   a. **Page reference:** `smartbook://page/{page_id}` or `#page-{page_id}`
   b. **Anchor reference:** `#anchor-id` (within current page) or `smartbook://page/{page_id}#anchor-id` (cross-page)
   c. **External link:** `http://` or `https://` (open in system browser)

. **Navigation Logic:**
   a. Extract `page_id` and `anchor_id` from link
   b. Load page: `SELECT html_content FROM Content_Pages WHERE page_id = ?`
   c. If `anchor_id` present, scroll to element with matching ID
   d. Update `Local_Reading_Position` table
   e. Add to navigation history stack

**Link Format Examples:**
[source,html]
----
<!-- Link to another page -->
<a href="smartbook://page/5">Go to Chapter 2</a>

<!-- Link to anchor on current page -->
<a href="#section-1">Jump to Section 1</a>

<!-- Link to anchor on another page -->
<a href="smartbook://page/10#character-sheet">View Character Sheet</a>

<!-- External link (opens in system browser) -->
<a href="https://example.com">External Reference</a>
----

=== Bookmarking Implementation

**Add Bookmark:**
. User clicks "Add Bookmark" button or uses keyboard shortcut (Ctrl+B / Cmd+B)
. Reader prompts for bookmark label (default: page title or heading text)
. Reader captures:
   * Current `page_id`
   * Current `anchor_id` (if on a heading or anchor)
   * Current `scroll_position` (optional, for precise restoration)
. Insert into `Local_Bookmarks` table:
   * `cartridge_guid` = current cartridge GUID
   * `page_id` = current page ID
   * `anchor_id` = current anchor (if any)
   * `bookmark_label` = user-provided label
   * `scroll_position` = current scroll position
   * `timestamp` = current timestamp

**Bookmark Management:**
* Display bookmarks in dedicated panel or menu
* Show bookmark label, page title, and timestamp
* Allow editing bookmark label
* Allow deleting bookmarks
* Click bookmark to navigate to saved position

**Navigate to Bookmark:**
. User selects bookmark from list
. Load page: `SELECT html_content FROM Content_Pages WHERE page_id = ?`
. If `anchor_id` present, scroll to element
. If `scroll_position` present, restore scroll position
. Update `Local_Reading_Position` table

=== Reading Position Persistence

**Save Reading Position:**
. On page navigation or cartridge close:
   a. Capture current `page_id`
   b. Capture current `anchor_id` (if on a heading/anchor)
   c. Capture current `scroll_position` (optional)
   d. Update or insert into `Local_Reading_Position` table:

      * `cartridge_guid` = current cartridge GUID
      * `page_id` = current page ID
      * `anchor_id` = current anchor (if any)
      * `scroll_position` = current scroll position
      * `last_access_timestamp` = current timestamp

**Restore Reading Position:**
. On cartridge open:
   a. Query `Local_Reading_Position` table: `SELECT * FROM Local_Reading_Position WHERE cartridge_guid = ?`
   b. If record exists:

      * Load page: `SELECT html_content FROM Content_Pages WHERE page_id = ?`
      * If `anchor_id` present, scroll to element after page loads
      * If `scroll_position` present, restore scroll position
   c. If no record exists, load first page (`page_order = 1`)

**Position Update Frequency:**
* Update on explicit page navigation (forward/backward buttons, TOC click)
* Update on internal link navigation
* Update on bookmark navigation
* Update on cartridge close/window close
* Optionally update on scroll (debounced, e.g., every 5 seconds)

=== Navigation History

**History Stack:**
* Maintain stack per Reader View Window
* Stack entries: `{ page_id, anchor_id, scroll_position }`
* Maximum stack size: 50 entries (configurable)

**Back Navigation:**
. Pop current position from stack (save to end of forward stack)
. Pop previous position from history stack
. Navigate to previous position
. Update `Local_Reading_Position` table

**Forward Navigation:**
. Pop next position from forward stack
. Push current position to history stack
. Navigate to next position
. Update `Local_Reading_Position` table

**History Management:**
* Clear history on cartridge close
* Maintain separate history per Reader View Window
* Browser-style back/forward buttons or keyboard shortcuts (Alt+Left/Right)

== Search Functionality Implementation Specification

This section defines how document search and in-page search are implemented in the Reader application.

=== Document Search Implementation

==== Search Modal UI

**Modal Components:**
* **Title:** "Site Search" or "Document Search"
* **Search Input Field:** Text input with placeholder "Search site..." or "Search document..."
* **Case Sensitivity Toggle ("Aa" Button):** Toggle button to enable/disable case-sensitive matching
* **Search Type Dropdown:** Dropdown menu with options:
  * "Normal" - Standard text search (default)
  * "Boolean" - Boolean operator search (AND, OR, NOT)
  * "Fuzzy" - Approximate/fuzzy matching
  * "Regex" - Regular expression pattern matching
* **Search Button:** Execute search button
* **Close Button (X):** Dismiss modal

**Modal Behavior:**
* Modal appears centered on screen with semi-transparent overlay
* Keyboard shortcut: Ctrl+F / Cmd+F opens modal
* Escape key closes modal
* Enter key in search field executes search

==== Normal Search Algorithm

**Implementation:**
. User enters search term in input field
. If case-sensitive toggle is OFF, convert search term and content to lowercase for comparison
. Query all pages: `SELECT page_id, page_order, chapter_title, html_content FROM Content_Pages ORDER BY page_order`
. For each page:
   a. Strip HTML tags from `html_content` to get plain text
   b. Search for search term in plain text
   c. If match found, extract context snippet (e.g., 50 characters before and after match)
   d. Store result: `{ page_id, page_order, chapter_title, match_text, context_snippet, match_position }`
. Return results sorted by `page_order`

**Context Snippet Generation:**
* Extract text surrounding match (e.g., 50-100 characters before and after)
* Highlight search term in snippet (bold or different color)
* Truncate with ellipsis if snippet exceeds maximum length

==== Boolean Search Algorithm

**Boolean Operators:**
* `AND` - All terms must be present (e.g., "character AND sheet")
* `OR` - Any term may be present (e.g., "weapon OR armor")
* `NOT` - Term must not be present (e.g., "magic NOT spell")
* Parentheses for grouping: `(character OR player) AND sheet`

**Implementation:**
. Parse search query into boolean expression tree
. For each page, evaluate boolean expression against page content
. If expression evaluates to true, include page in results
. Extract context snippets for matched terms

**Query Parsing:**
* Tokenize input: split on whitespace, identify operators (AND, OR, NOT)
* Build expression tree respecting operator precedence (NOT > AND > OR)
* Evaluate tree against page content

==== Fuzzy Search Algorithm

**Fuzzy Matching:**
* Use edit distance (Levenshtein distance) algorithm
* Allow 1-2 character differences (configurable)
* Match similar words despite typos or misspellings

**Implementation:**
. For each word in search term, find similar words in content
. Calculate edit distance between search term and candidate words
. If edit distance <= threshold (default: 2), consider it a match
. Rank results by similarity score (lower edit distance = higher rank)

**Performance Optimization:**
* Limit fuzzy search to words of similar length
* Use indexing or caching for frequently searched terms
* Consider limiting fuzzy search to first 1000 pages for performance

==== Regex Search Algorithm

**Implementation:**
. Validate regex pattern syntax
. If invalid, display error message: "Invalid regular expression: [error details]"
. If valid, compile regex pattern
. For each page:
   a. Strip HTML tags to get plain text
   b. Apply regex pattern matching
   c. Extract all matches and context snippets
. Return results with matched patterns highlighted

**Error Handling:**
* Catch regex compilation errors
* Display user-friendly error messages
* Suggest common regex patterns or provide help link

==== Search Results Display

**Results Format (Adobe Reader-style):**
* **Result List:** Scrollable list of results
* **Result Item Structure:**
  * Page/Chapter title (clickable, navigates to page)
  * Context snippet with search term highlighted
  * Match indicator (e.g., "Match 1 of 15")
* **Result Count:** Display total matches found (e.g., "Found 15 matches in 8 pages")
* **Grouping:** Optionally group results by page or chapter

**Result Item Example:**
----
Chapter 2: Character Creation
...character sheet includes ability scores, skills, and equipment...
Match 1 of 15
----

**Navigation:**
* Click on result item navigates to corresponding page
* Scrolls to match location within page
* Highlights match on page (temporary highlight)

==== Search Performance Optimization

**Indexing Strategy:**
* Option 1: Build search index on cartridge open (one-time cost)
* Option 2: Lazy indexing (index pages as they're searched)
* Option 3: No indexing (search on-demand, acceptable for small cartridges)

**Index Structure:**
* Full-text index: `{ word: [page_id, position, context] }`
* Store in memory or temporary database
* Rebuild index if cartridge content changes

**Caching:**
* Cache recent search results
* Cache indexed pages
* Clear cache on cartridge close

=== In-Page Search Implementation

==== Find-in-Page Dialog

**Dialog Components:**
* Compact bar/overlay at top or bottom of Reader view
* Search input field (auto-focus on open)
* Previous button (up arrow or "Previous")
* Next button (down arrow or "Next")
* Result count display (e.g., "3 of 12")
* Case sensitivity checkbox
* Close button (X)

**Dialog Behavior:**
* Keyboard shortcut: Ctrl+F / Cmd+F (if document search modal not open) or F3
* Escape key closes dialog
* Enter key moves to next match
* Shift+Enter moves to previous match
* Dialog stays visible while searching

==== Term Highlighting

**Highlighting Implementation:**
. User enters search term in find dialog
. Reader searches current page content for all matches
. Wrap each match in HTML span with highlight class:
   [source,html]
   ----
   <span class="find-highlight">matched text</span>
   ----
. Apply CSS styling:
   [source,css]
   ----
   .find-highlight {
     background-color: yellow;
     color: black;
   }
   .find-highlight.active {
     background-color: orange;
     border: 2px solid red;
   }
   ----

**Dynamic Highlighting:**
* Update highlights as user types (debounced, e.g., 300ms delay)
* Clear highlights when search term is cleared
* Clear highlights when dialog is closed

==== Match Navigation

**Navigation Implementation:**
. Maintain array of all match positions: `[{ element, offset, text }]`
. Track current match index
. On "Next":
   a. Increment current match index
   b. Remove `active` class from previous match
   c. Add `active` class to current match
   d. Scroll to current match
. On "Previous":
   a. Decrement current match index
   b. Remove `active` class from previous match
   c. Add `active` class to current match
   d. Scroll to current match

**Scroll to Match:**
* Use `element.scrollIntoView({ behavior: 'smooth', block: 'center' })`
* Ensure match is centered or visible in viewport
* Handle edge cases (match at top/bottom of page)

==== Result Count Display

**Count Calculation:**
* Count total matches on current page
* Track current match position (1-based index)
* Display: "3 of 12" or "Match 3 of 12"

**Update Frequency:**
* Update count when search term changes
* Update position when navigating between matches
* Display "No matches" when search term not found

==== Case Sensitivity

**Case-Sensitive Matching:**
* Checkbox or toggle in find dialog
* When enabled, match exact case (e.g., "Character" ≠ "character")
* When disabled, case-insensitive matching (default)
* Re-highlight and re-count when toggled

==== Search Persistence Across Pages

**Persistence Implementation:**
. Store current search term in Reader View Window state
. When user navigates to new page:
   a. Check if search term exists
   b. If exists, automatically search new page
   c. Highlight matches on new page
   d. Reset match index to 1
   e. Update result count
. Maintain search term until:
   a. User clears search field
   b. User closes find dialog
   c. User opens document search modal

**State Management:**
* Store search term per Reader View Window
* Persist across page navigation
* Clear on cartridge close

== Content Theme Manager Implementation Specification

This section defines how the Content Theme Manager dialog is implemented in the Creator Tool, allowing authors to create and manage themes for smartbook content.

=== Content Theme Manager Dialog Structure

**Dialog Layout:**
* **Title:** "Content Theme Manager"
* **Close Button (X):** Top right corner to dismiss dialog
* **Two-Panel Layout:**
  * Left Panel: Available Themes list and management actions
  * Right Panel: Theme configuration and live preview

=== Left Panel - Available Themes

**Panel Components:**
* **Heading:** "Available Themes" (bold, dark gray)
* **Theme List:** Scrollable list displaying:
  * Theme name (e.g., "Light Content", "Dark Content", "Warm Content")
  * "Apply" button next to each theme
  * Visual indicator for built-in vs custom themes
  * Visual indicator for active theme (currently applied)
* **Action Buttons:** Four buttons below theme list:
  * **Add (+):** Create new custom theme
  * **Delete (-):** Delete selected custom theme (disabled for built-in themes)
  * **Copy:** Duplicate selected theme to create new custom theme
  * **Rename:** Rename selected custom theme (disabled for built-in themes)
* **Checkbox:** "Persist on add" - When enabled, automatically saves theme to cartridge when created/modified

**Theme List Behavior:**
* Built-in themes (Light Content, Dark Content, Warm Content) are immutable
* Custom themes can be edited, renamed, or deleted
* Clicking a theme selects it and loads its configuration in the right panel
* "Apply" button applies theme to current cartridge immediately

=== Right Panel - Theme Configuration

**Panel Components:**

==== Name Section
* **Label:** "Name"
* **Input Field:** Text input for theme name (editable for custom themes, read-only for built-in themes)
* **Action Buttons:**
  * **Apply:** Apply theme configuration to current cartridge
  * **Save:** Save theme configuration (enabled when theme is modified, highlighted in blue)
  * **Cancel:** Discard changes and close dialog
  * **Revert:** Revert theme to last saved state (enabled when theme has unsaved changes)

==== Core Colors (Simple) Section
* **Heading:** "Core Colors (Simple)" (bold, dark gray)
* **Preset Controls:**
  * **Preset Dropdown:** Select color preset (e.g., "Default", "High Contrast", "Custom")
  * **Reset Button:** Reset all colors to default values
  * **Show Swatches Checkbox:** Toggle display of color swatches
* **Color Pickers/Swatches:**
  * **Primary:** Color picker/swatch for primary color
  * **On Primary:** Color picker/swatch for text color on primary background
  * **Surface:** Color picker/swatch for surface color
  * **On Surface:** Color picker/swatch for text color on surface
  * **Background:** Color picker/swatch for background color (may have multiple swatches)
* **Descriptive Text:** "Only the core colors are exposed. Background is handled via a decorative pseudo-element so copying text won't include background color."

**Color Picker Implementation:**
* Use Qt `QColorDialog` or custom color picker widget
* Display color swatches showing current color values
* Update live preview when colors change
* Validate color values (hex codes, RGB values)

==== Live Preview Section
* **Heading:** "Live Preview" (bold, dark gray)
* **Preview Area:** White rectangular area displaying sample content rendered with current theme:
  * **Heading:** "Heading Example" (styled with theme heading font/color)
  * **Body Text:** "Body text with a link and emphasis. inline code."
    * Link styled with theme link color
    * Emphasis styled with theme emphasis style
    * Inline code styled with theme monospace font and code background
  * **Quoted Text:** Indented quoted text example
  * **Table:** Two-column table with header row styled with theme colors

**Live Preview Updates:**
* Preview updates in real-time as colors/fonts are modified
* Preview reflects current theme configuration
* Preview uses actual HTML/CSS rendering (Qt WebEngineView or similar)

=== Theme Management Operations

==== Add New Theme
. User clicks "Add (+)" button
. Create new theme with default configuration:
   * Generate unique `theme_id` (e.g., "custom-theme-{timestamp}")
   * Set `theme_name` to "New Theme" or prompt for name
   * Set `is_builtin` = 0
   * Set default `theme_config_json` (copy from "Default" preset)
   * Set `is_active` = 0
. Add theme to list in left panel
. Select new theme (loads in right panel for editing)
. If "Persist on add" is checked, automatically save to cartridge

==== Delete Theme
. User selects custom theme in list
. User clicks "Delete (-)" button
. Confirm deletion dialog: "Are you sure you want to delete '{theme_name}'?"
. If confirmed:
   * Delete theme from `Content_Themes` table
   * Remove from theme list
   * If deleted theme was active, apply default theme (Light Content)
. If theme is built-in, disable delete button (cannot delete built-in themes)

==== Copy Theme
. User selects theme in list (built-in or custom)
. User clicks "Copy" button
. Create new theme:
   * Generate unique `theme_id`
   * Set `theme_name` to "{original_name} Copy" or prompt for name
   * Copy `theme_config_json` from selected theme
   * Set `is_builtin` = 0
   * Set `is_active` = 0
. Add copied theme to list
. Select copied theme for editing

==== Rename Theme
. User selects custom theme in list
. User clicks "Rename" button
. Prompt for new name (or edit name field directly)
. Validate name (not empty, unique within cartridge)
. Update `theme_name` in `Content_Themes` table
. Update theme list display
. If "Persist on add" is checked, save changes

==== Apply Theme
. User clicks "Apply" button (either in theme list or configuration panel)
. Update `Content_Themes` table:
   * Set `is_active` = 0 for all themes
   * Set `is_active` = 1 for selected theme
. Generate theme CSS from theme configuration (colors and fonts only)
. Apply theme CSS to cartridge content (update `Settings` table or inject CSS)
. Theme CSS works **in conjunction with** structural CSS (`associated_css` field)
. Update preview pane in Creator Tool
. Visual indicator shows active theme in theme list

**Note:** The theme CSS controls colors and fonts, while the CSS stylesheet (`associated_css`) controls structure (layout, positioning, spacing). Both are applied together for final rendering.

==== Save Theme
. User modifies theme configuration (colors, fonts, etc.)
. "Save" button becomes enabled (highlighted in blue)
. User clicks "Save" button
. Update `theme_config_json` in `Content_Themes` table
. If "Persist on add" is checked, also save to cartridge file
. "Save" button becomes disabled (changes saved)

==== Revert Theme
. User modifies theme configuration
. "Revert" button becomes enabled
. User clicks "Revert" button
. Reload theme configuration from `Content_Themes` table (last saved state)
. Reset all color pickers and inputs to saved values
. Update live preview
. "Revert" button becomes disabled

=== Theme Configuration Storage

**Database Operations:**
* **Load Themes:** `SELECT * FROM Content_Themes ORDER BY is_builtin DESC, theme_name`
* **Save Theme:** `INSERT OR REPLACE INTO Content_Themes (theme_id, theme_name, is_builtin, theme_config_json, is_active) VALUES (?, ?, ?, ?, ?)`
* **Delete Theme:** `DELETE FROM Content_Themes WHERE theme_id = ? AND is_builtin = 0`
* **Apply Theme:** `UPDATE Content_Themes SET is_active = CASE WHEN theme_id = ? THEN 1 ELSE 0 END`

**Theme Configuration JSON Schema:**
[source,json]
----
{
  "version": "1.0",
  "coreColors": {
    "primary": "#1976D2",
    "onPrimary": "#FFFFFF",
    "surface": "#FFFFFF",
    "onSurface": "#000000",
    "background": "#F5F5F5"
  },
  "fonts": {
    "heading": "Georgia, serif",
    "body": "Arial, sans-serif",
    "monospace": "Courier New, monospace"
  },
  "styling": {
    "linkColor": "#1976D2",
    "emphasisStyle": "italic",
    "codeBackground": "#F5F5F5",
    "quoteIndent": "20px"
  }
}
----

=== Theme Application to Content

**Theme vs CSS Distinction:**
* **CSS Stylesheet (`associated_css` in `Content_Pages`):** Controls **structure** - layout, positioning, spacing, margins, borders, display properties, flexbox/grid layouts, etc.
* **Content Theme (`Content_Themes` table):** Controls **colors and fonts** - color schemes, typography (font families, sizes, weights), text colors, background colors, link colors, etc.

**Design Rationale:**
By separating structural concerns (CSS) from visual appearance concerns (themes), the system achieves a balanced approach:

* **Author Control:** Authors maintain control over page structure, layout, and organization through CSS, ensuring content is presented as intended
* **User Customization:** Users can customize visual appearance (colors, fonts) through theme selection and user settings, accommodating personal preferences and accessibility needs
* **Middle Ground:** This separation provides a reasonable middle ground between strict author control (no customization) and complete user control (which could break author intent), allowing both parties to achieve their goals without conflict

**Theme CSS Generation:**
. Load active theme from `Content_Themes` table
. Parse `theme_config_json` to extract colors, fonts, styling
. Generate CSS rules using CSS custom properties (variables) for **colors and fonts only**:
   [source,css]
   ----
   :root {
     /* Color variables */
     --theme-primary: #1976D2;
     --theme-on-primary: #FFFFFF;
     --theme-surface: #FFFFFF;
     --theme-on-surface: #000000;
     --theme-background: #F5F5F5;
     --theme-link: #1976D2;
     
     /* Font variables */
     --theme-font-heading: Georgia, serif;
     --theme-font-body: Arial, sans-serif;
     --theme-font-monospace: Courier New, monospace;
   }
   
   /* Apply colors and fonts only - structure handled by CSS stylesheet */
   body {
     background-color: var(--theme-background);
     color: var(--theme-on-surface);
     font-family: var(--theme-font-body);
   }
   
   h1, h2, h3 {
     font-family: var(--theme-font-heading);
     color: var(--theme-on-surface);
   }
   
   a {
     color: var(--theme-link);
   }
   
   code {
     background-color: var(--theme-code-background);
     font-family: var(--theme-font-monospace);
   }
   ----
. Inject theme CSS into cartridge content (add to `Settings` table or inject into HTML)
. Theme CSS works **in conjunction with** the structural CSS stylesheet (`associated_css`)
. Apply to Creator Tool preview pane
. Theme will be applied when cartridge is opened in Reader

**Rendering Priority:**
. Structural CSS (`associated_css`) is applied first (layout, positioning, spacing)
. Theme CSS is applied second (colors, fonts override defaults)
. User settings (from `Local_User_Settings`) can override theme colors/fonts

=== Built-in Themes

**Default Built-in Themes:**
* **Light Content:** Light background, dark text, blue links
* **Dark Content:** Dark background, light text, light blue links
* **Warm Content:** Warm beige/sepia background, dark brown text, warm accent colors

**Built-in Theme Characteristics:**
* Immutable (cannot be edited, renamed, or deleted)
* Always available in theme list
* Can be copied to create custom variants
* Stored in application, not in cartridge (but can be applied to cartridge)

== Print Functionality Implementation Specification

This section defines how print functionality is implemented in the Reader application, including print capabilities, CSS handling, and rendering.

=== Print Capabilities

**Print Options:**
* **Print Entire Document:** Print all pages in the cartridge
* **Print Current Page:** Print only the currently displayed page
* **Print Selection:** Print only selected text/content (if text is selected)

**Print Dialog:**
* Use Qt `QPrintDialog` for native system print dialog
* Allow user to configure:
  * Printer selection
  * Page range (for document printing)
  * Number of copies
  * Paper size (US Letter, A4, etc.)
  * Orientation (Portrait, Landscape)
  * Other standard print options (color/grayscale, quality, etc.)

=== Print CSS Stylesheets

**Built-in Print Stylesheets:**
The Reader provides built-in print CSS optimized for common paper sizes:

==== US Letter (8.5" × 11") Print CSS
[source,css]
----
@media print {
  @page {
    size: letter;
    margin: 0.75in;
  }
  
  body {
    font-size: 12pt;
    line-height: 1.5;
  }
  
  /* Hide non-printable elements */
  .smartbook-navigation,
  .smartbook-controls,
  .smartbook-forms input,
  .smartbook-forms select,
  .smartbook-forms textarea,
  button {
    display: none;
  }
  
  /* Optimize page breaks */
  h1, h2, h3 {
    page-break-after: avoid;
  }
  
  p, li {
    page-break-inside: avoid;
  }
  
  /* Print-friendly link styling */
  a::after {
    content: " (" attr(href) ")";
    font-size: 0.8em;
    color: #666;
  }
}
----

==== A4 (210mm × 297mm) Print CSS
[source,css]
----
@media print {
  @page {
    size: A4;
    margin: 20mm;
  }
  
  body {
    font-size: 12pt;
    line-height: 1.5;
  }
  
  /* Same hide/show rules as US Letter */
  .smartbook-navigation,
  .smartbook-controls,
  .smartbook-forms input,
  .smartbook-forms select,
  .smartbook-forms textarea,
  button {
    display: none;
  }
  
  h1, h2, h3 {
    page-break-after: avoid;
  }
  
  p, li {
    page-break-inside: avoid;
  }
  
  a::after {
    content: " (" attr(href) ")";
    font-size: 0.8em;
    color: #666;
  }
}
----

**Print CSS Application:**
. Detect selected paper size from print dialog
. Load appropriate built-in print CSS (US Letter or A4)
. Merge with author's structural CSS (`associated_css`)
. Apply theme colors/fonts (from active content theme)
. Apply print-specific overrides via `@media print` rules
. Ensure print CSS takes precedence for print-specific rules

=== Print Rendering Implementation

**Rendering Strategy:**
. **Content Preparation:**
   a. Load content from `Content_Pages` table
   b. Apply structural CSS (`associated_css`)
   c. Apply active theme CSS (colors/fonts)
   d. Apply print CSS based on selected paper size
   e. Remove/hide non-printable elements

. **Offscreen Rendering (if required):**
   a. Create offscreen `QWebEngineView` or `QWebEnginePage`
   b. Load prepared HTML content with all CSS applied
   c. Wait for content to fully render
   d. Capture rendered content for printing
   e. Use Qt `QPrinter` to render to print device

. **Qt Print Integration:**
   a. Use `QPrintDialog` for user print configuration
   b. Use `QPrinter` to handle print rendering
   c. Use `QWebEnginePage::printToPdf()` or `QWebEnginePage::print()` for WebEngine content
   d. Handle page breaks and multi-page documents

**Print Algorithm:**
. User triggers print (menu item, keyboard shortcut Ctrl+P / Cmd+P, or toolbar button)
. Determine print scope:
   * If text selected: Print selection only
   * If "Print Current Page" selected: Print current page only
   * If "Print Document" selected: Print all pages
. Open `QPrintDialog` for user configuration
. User selects printer, paper size, orientation, etc.
. For each page to print:
   a. Load page content from `Content_Pages` table
   b. Apply CSS (structural + theme + print)
   c. Render content (onscreen or offscreen)
   d. Send to printer via `QPrinter`
. Handle page breaks between pages
. Complete print job

=== Print Preview

**Preview Implementation:**
. User selects "Print Preview" option
. Prepare content with print CSS applied (same as print rendering)
. Display preview in dialog or separate window
. Show preview with selected paper size and orientation
. Allow user to navigate through pages
. Allow user to adjust print settings and refresh preview
. User can print from preview or cancel

**Preview Dialog:**
* Display preview pages in scrollable view
* Show page boundaries and margins
* Display page numbers
* Provide zoom controls
* Show print settings summary
* "Print" and "Cancel" buttons

=== Print Quality Considerations

**Text Rendering:**
* Use appropriate font sizes for print (typically 10-12pt)
* Ensure sufficient line spacing for readability
* Use high-quality font rendering
* Handle font fallbacks appropriately

**Image Handling:**
* Scale images appropriately for print resolution
* Maintain aspect ratios
* Use high-resolution images when available
* Handle image formats appropriately (convert if needed)

**Color Handling:**
* Preserve color information for color printers
* Provide grayscale option for monochrome printers
* Handle transparency appropriately
* Ensure sufficient contrast for readability

**Background Handling:**
* Option to print backgrounds (default: off for ink savings)
* Handle decorative backgrounds appropriately
* Ensure text remains readable

=== Print CSS Priority

**CSS Application Order:**
. **Structural CSS** (`associated_css`) - Base layout and structure
. **Theme CSS** (from `Content_Themes`) - Colors and fonts
. **Print CSS** (`@media print` rules) - Print-specific optimizations

**Print CSS Overrides:**

* Print CSS can override structural CSS for print-specific layout
* Print CSS can override theme colors for print optimization (e.g., force black text)
* Print CSS takes precedence within `@media print` blocks
* User print settings (from print dialog) can further override CSS

=== Multi-Page Document Printing

**Page Handling:**
* For document printing, iterate through all pages in `page_order`
* Load each page's content sequentially
* Apply consistent CSS across all pages
* Handle page breaks between pages
* Maintain consistent margins and formatting
* Optionally add page numbers (if implemented in future)

**Page Break Handling:**
* Avoid breaking content awkwardly (headings, paragraphs, lists)
* Use CSS `page-break-after`, `page-break-before`, `page-break-inside` properties
* Ensure content flows naturally across pages
* Handle edge cases (very long content, tables, etc.)

== Text Selection and Copy Implementation Specification

This section defines how text selection, copying, and pasting are implemented in the Reader application.

=== Text Selection

**Selection Methods:**
* **Mouse Selection:** Click and drag to select text
* **Keyboard Selection:** Shift+Arrow keys to extend selection
* **Word Selection:** Double-click to select word
* **Paragraph Selection:** Triple-click to select paragraph
* **Select All:** Ctrl+A / Cmd+A to select all text on current page (or all text in focused form field)

**Select All Behavior:**
* **On Content Pages:** Selects all text content on the current page
* **In Form Fields:** When a form field (input, textarea) is focused, selects all text within that field only
* **Context Menu:** "Select All" option available in context menu when appropriate
* **Keyboard Shortcut:** Ctrl+A (Windows/Linux) or Cmd+A (macOS)

**Selection Behavior:**
* Selection works with all rendered HTML content
* Selection respects text flow and layout
* Selection can span multiple elements (headings, paragraphs, lists)
* Selection highlights with standard platform selection color
* Selection is cleared when clicking outside selected area or navigating to new page

**Selection Implementation:**
* Use Qt WebEngine's native text selection capabilities
* Enable text selection in `QWebEngineView` settings
* Handle selection events via JavaScript or Qt signals
* Display selection highlight using platform-standard selection styling

=== Copy to Clipboard

**Copy Functionality:**
* **Keyboard Shortcut:** Ctrl+C / Cmd+C copies selected text to clipboard
* **Context Menu:** Right-click on selected text shows "Copy" option
* **Menu Bar:** Edit menu provides "Copy" option when text is selected

**Copy Implementation:**
. User selects text and triggers copy (keyboard shortcut, context menu, or menu bar)
. Reader captures selected text from WebEngine
. **Background Removal:** Strip background colors and styling from copied text
. Convert to plain text format
. Copy plain text to system clipboard

**Background Removal Algorithm:**
. Get selected HTML content from WebEngine
. Parse HTML to extract text nodes
. For each text node:
   a. Extract text content
   b. Remove inline styles (background-color, background, color if it matches background)
   c. Remove CSS classes that apply backgrounds
   d. Preserve text content only
. Combine text nodes with appropriate whitespace
. Copy plain text to clipboard

**Alternative Approach (Simpler):**
* Use WebEngine's built-in copy functionality
* Intercept clipboard data before it's set
* Strip HTML formatting, keeping only plain text
* Set plain text to clipboard instead of HTML

=== Paste Functionality

**Paste into Forms:**
. User focuses on a form field (input, textarea, etc.)
. User triggers paste (Ctrl+V / Cmd+V or context menu)
. Reader retrieves plain text from system clipboard
. Insert text into focused form field
. Form field validation applies (if any)

**Paste Implementation:**
* Use WebEngine's native paste handling for form fields
* Ensure clipboard content is accessible to form fields
* Handle paste events in form input elements
* Apply form validation after paste

**Paste into External Documents:**
* Text copied from Reader is plain text in clipboard
* External applications receive plain text when pasting
* No background formatting or styling is transferred
* Text can be pasted into any application that accepts plain text

=== Context Menu

**Context Menu Implementation:**
* Display context menu on right-click
* Menu options:
  * **Copy:** Copy selected text to clipboard (shown when text is selected)
  * **Select All:** Select all text on current page or in focused form field (shown when appropriate)
  * **Cut:** Cut selected text from form field (shown when text is selected in form field)
  * **Paste:** Paste text from clipboard (shown when clipboard contains text and cursor is in form field)
* Menu follows platform conventions (native OS context menu styling)
* Menu appears near cursor position
* Menu is dismissed when clicking outside or selecting option

**Context Menu Behavior:**
* Show "Copy" option when text is selected
* Show "Cut" option when text is selected in a form field (not in content pages)
* Show "Paste" option when clipboard contains text and cursor is in a form field
* Show "Select All" option when appropriate (no text selected, or in form field)
* Hide context menu when clicking outside
* Handle keyboard navigation (arrow keys, Enter to select)

=== Clipboard Integration

**System Clipboard:**
* Use Qt `QClipboard` for clipboard operations
* Access system clipboard via `QApplication::clipboard()`
* Set text using `clipboard->setText(plainText, QClipboard::Clipboard)`
* Get text using `clipboard->text(QClipboard::Clipboard)`

**Clipboard Formats:**
* **Primary Format:** Plain text (UTF-8)
* **No HTML Format:** Do not copy HTML to clipboard
* **No Rich Text Format:** Do not copy RTF or other formatted text
* **Plain Text Only:** Ensure only plain text is available for pasting

**Cross-Platform Considerations:**
* Windows: Use `QClipboard::Clipboard` (standard clipboard)
* macOS: Use `QClipboard::Clipboard` (standard clipboard)
* Linux: Use `QClipboard::Clipboard` (standard clipboard) or `QClipboard::Selection` (primary selection) based on platform conventions

=== Form Field Paste Handling

**Form Field Focus:**
* Detect when form field receives focus
* Enable paste functionality for focused form field
* Handle paste events in form input elements

**Paste into Form Fields:**
. User focuses on form field (click or Tab navigation)
. User triggers paste (Ctrl+V / Cmd+V)
. WebEngine handles paste event in form field
. Plain text from clipboard is inserted into form field
. Form field's input event is triggered
. Form validation applies (if any)

**Paste Validation:**
* Form field validation rules apply to pasted content
* Invalid content may be rejected or sanitized
* User receives feedback if paste is rejected
* Valid content is inserted normally

=== Selection Persistence

**Selection Behavior:**
* Selection is cleared when:
  * User clicks outside selected area
  * User navigates to new page
  * User scrolls significantly
  * User performs other actions (search, etc.)
* Selection is NOT persisted across page navigation
* Selection is NOT saved in reading position

**Selection State:**
* Track selection state per Reader View Window
* Clear selection on page navigation
* Clear selection on window focus loss (optional, platform-dependent)

=== Standard Keyboard Shortcuts

**Text Selection and Copy Shortcuts:**
* **Select All:** Ctrl+A (Windows/Linux) or Cmd+A (macOS)
  * Selects all text on current page when no form field is focused
  * Selects all text in focused form field when form field has focus
* **Copy:** Ctrl+C (Windows/Linux) or Cmd+C (macOS)
  * Copies selected text to clipboard
  * Works with content page text and form field text
* **Paste:** Ctrl+V (Windows/Linux) or Cmd+V (macOS)
  * Pastes text from clipboard into focused form field
  * Works when form field has focus
* **Cut:** Ctrl+X (Windows/Linux) or Cmd+X (macOS)
  * Cuts selected text from form field (removes text and copies to clipboard)
  * Only works in form fields, not in content pages (content is read-only)

**Shortcut Implementation:**
* Use Qt's keyboard shortcut handling (`QShortcut` or menu actions)
* Ensure shortcuts work consistently across all Reader View Windows
* Handle focus properly (shortcuts apply to focused element)
* Follow platform conventions (Ctrl on Windows/Linux, Cmd on macOS)
* Shortcuts should not conflict with WebEngine's native shortcuts

**Shortcut Priority:**
. Form field shortcuts take precedence when form field is focused
. Content page shortcuts apply when no form field is focused
. Application-level shortcuts (menu items) always available

**WCAG Compliance:**
* Keyboard shortcuts are essential for WCAG 2.1 Level AA compliance
* All essential functions must be accessible via keyboard without requiring a mouse
* Standard keyboard shortcuts ensure users can perform all operations using only the keyboard
* Keyboard shortcuts follow platform conventions for consistency and familiarity

== Cartridge Signature Verification Process Algorithm

=== 4-Phase Verification Algorithm Sequence Diagram

[NOTE]
====
See `diagrams.adoc` (4-Phase Verification Algorithm sequence diagram) for a complete visual representation of the security verification process showing all four phases: Identity, Integrity Check, Trust Lookup, and Policy Determination.
====

=== Phase 1: Integrity Check and Identity Establishment

[cols="2, 2, 4", option="headers"]
|===
^.^| Step ^.^| Action by Reader C++ Core ^.^| Output/Result

| **1. Extract IDs & Security Data** | Read `cartridge_guid` from `Metadata`. Read security parameters (H1, Signature, Certificate, Fingerprint) from `Cartridge_Security`. | `cartridge_guid`, H1, Signature, Certificate, Fingerprint 
| **2. Recalculate Content Hash** | Read the binary content of critical tables. Calculate H2 using the Content Hash Algorithm (see "Content Hash Algorithm Specification" section below). | H2 (Recalculated Content Hash)
| **3. Extract Certificate and Public Key** | Extract certificate from `certificate_data`. Extract public key from certificate using `QSslCertificate::publicKey()`. If certificate is missing or invalid, set Public Key Status to `MISSING` or `INVALID`. | Certificate Object, Public Key Object, Public Key Status
| **4. Verify Public Key Fingerprint** | Calculate fingerprint of extracted public key (using same algorithm as stored fingerprint, typically SHA-256). Compare calculated fingerprint with stored `public_key_fingerprint`. If mismatch, set Fingerprint Status to `MISMATCH` (indicates potential tampering). | Fingerprint Status: `MATCH` or `MISMATCH`
| **5. Verify Digital Signature** | Use extracted Public Key to verify `digital_signature` matches the stored H1. If fingerprint mismatch detected in Step 4, reject signature verification. | Signature Status: `VALID`, `INVALID`, or `UNVERIFIED`.
| **6. Extract and Validate Certificate** | Validate certificate using system CA store and check expiration. See "Certificate Validation" section below. | Certificate Status: `CA_VALID`, `CA_EXPIRED`, `SELF_SIGNED`, `INVALID`, or `NONE`.
| **7. Check Tampering (Content vs. Signature)** | Compare H1 vs. H2. | Integrity Status: `MATCH` or `MISMATCH`.
|===

=== Phase 2: Trust Level Assignment

[cols="2, 2, 4", option="headers"]
|===
^.^| Condition ^.^| Initial Trust Level ^.^| Required Action

| Signature Invalid OR Hash Mismatch OR Fingerprint Mismatch OR Public Key Missing. | **Rejected** | Halt loading. Block all execution.
| Signature Valid AND Certificate Status = `CA_VALID` (valid, non-expired CA-signed) AND Fingerprint Match. | **Level 1: Commercial Trust** | Whitelist apps by default.
| Signature Valid AND Certificate Status = `CA_EXPIRED` (expired CA-signed certificate) AND Fingerprint Match. | **Level 2: Self-Signed Trust** | Downgrade to Level 2. Display integrity warning. Apps require consent.
| Signature Valid AND Certificate Status = `SELF_SIGNED` (self-signed certificate) AND Fingerprint Match. | **Level 2: Self-Signed Trust** | Apps require consent.
| Signature Valid AND Certificate Status = `INVALID` (certificate validation failed). | **Rejected** | Halt loading. Block all execution.
| No Signature OR Certificate Status = `NONE`. | **Level 3: No Signature** | Apps require consent.
|===

=== Phase 3: Local Trust Registry and Policy Enforcement

. **Check Local Persistent Trust:** Query the `Local_Trust_Registry` using the `cartridge_guid`.
. **Tampering Check on Trusted Files:** If persistent trust exists, compare **H2** against the hash in the **`Local_Library_Manifest`**. A mismatch sets policy to **Rejected (Tampered)**.
. **Final Policy:** Policy is `WHITELISTED` if Level 1 OR Persistent Trust exists and is valid. Otherwise, the policy requires explicit consent.
. **Update Manifest:** Update the `Local_Library_Manifest` using the current `cartridge_guid` and H2. If manifest update fails, log error and display user-friendly error dialog (see "Manifest Update Error Handling" section).

=== Phase 4: Embedded Application Execution Policy

[cols="2, 2", options="headers"]
|===
^.^| Policy Status ^.^| Native Application Response

| **WHITELISTED** | Return `TRUE`. Execute app.
| **Level 2 / Level 3** | Display the Consent Dialog.
| **Rejected (Tampered/Invalid)** | Return `FALSE`. Block app execution.
|===

=== Certificate Validation Implementation

This section details how certificates are validated in the Reader application.

==== Certificate Extraction

**Process:**
. Read `certificate_data` BLOB from `Cartridge_Security` table
. Parse certificate data (supports DER and PEM formats)
. Create `QSslCertificate` object from certificate data
. If certificate data is missing or invalid, set Certificate Status to `NONE` or `INVALID`

==== System Certificate Store Integration

**Platform-Specific Certificate Stores:**
* **Windows:** Windows Certificate Store (automatically accessed via Qt's SSL implementation)
* **macOS:** Keychain System Roots (automatically accessed via Qt's SSL implementation)
* **Linux:** System CA bundle (typically `/etc/ssl/certs/ca-certificates.crt` or `/etc/pki/tls/certs/ca-bundle.crt`)

**Implementation:**
* Qt's `QSslCertificate` class automatically validates certificates against the system's trusted root CA store
* No manual CA list maintenance required
* System certificate store updates are automatically used by Qt

==== Certificate Validation Algorithm

**Step 1: Determine Certificate Type**
. Extract certificate from `certificate_data`
. Use `QSslCertificate::verify()` to check if certificate is signed by a trusted CA:
  * If `verify()` returns `QSslCertificate::Valid` → Certificate is CA-signed
  * If `verify()` returns `QSslCertificate::SelfSigned` → Certificate is self-signed
  * If `verify()` returns `QSslCertificate::Invalid` → Certificate validation failed

**Step 2: Check Certificate Expiration**
. Get certificate validity dates:
   * `QSslCertificate::effectiveDate()` - Certificate becomes valid
   * `QSslCertificate::expiryDate()` - Certificate expires
. Get current system date/time
. Compare dates and determine status:
  * If current date < `effectiveDate` → Certificate not yet valid → Certificate Status = `INVALID`
  * If current date > `expiryDate` → Certificate expired → Certificate Status = `CA_EXPIRED` (if CA-signed) or `INVALID` (if self-signed)
  * If current date is within validity period → Certificate is valid

**Step 3: Determine Final Certificate Status**
* **CA-signed AND valid AND not expired:** Certificate Status = `CA_VALID`
* **CA-signed AND valid BUT expired:** Certificate Status = `CA_EXPIRED` (downgrade to Level 2)
* **Self-signed AND valid:** Certificate Status = `SELF_SIGNED`
* **Certificate validation failed:** Certificate Status = `INVALID`
* **No certificate data:** Certificate Status = `NONE`

==== Expired CA Certificate Handling

**Decision:** Expired CA-signed certificates are downgraded to Level 2 (Self-Signed Trust) rather than being rejected.

**Rationale:**
* Expired certificates may still be valid for content that was signed when the certificate was valid
* Downgrading to Level 2 allows users to make informed trust decisions
* Users can still trust the cartridge via the Local Trust Registry if desired

**User Experience:**
* Expired CA certificates trigger the same integrity warning as self-signed certificates
* Embedded applications require explicit user consent (same as Level 2)
* Users can grant persistent trust via the consent dialog

==== Certificate Revocation (Deferred for Phase 1)

**Decision:** Certificate revocation checking (OCSP/CRL) is deferred for Phase 1.

**Rationale:**
* Revocation checking requires network access, which conflicts with offline-first design
* Adds complexity and latency to certificate validation
* Most use cases for Phase 1 do not require revocation checking
* Can be added in future phases if needed

**Future Consideration:**
* OCSP (Online Certificate Status Protocol) checking
* CRL (Certificate Revocation List) checking
* Cached revocation status for offline operation

== Content Hash Algorithm Specification

This section defines the exact algorithm used to calculate content hashes (H1 and H2) for cartridge integrity verification and tampering detection.

=== Hash Algorithm

**Algorithm:** SHA-256 (Secure Hash Algorithm 256-bit)

**Rationale:**
* **Security:** 256-bit output provides strong collision resistance
* **Performance:** Efficient computation suitable for large content
* **Standard:** Widely supported in Qt, OpenSSL, and cryptographic libraries
* **Future-proof:** No known vulnerabilities; recommended by NIST

**Implementation:**
* Use Qt's `QCryptographicHash` class with `QCryptographicHash::Sha256` algorithm
* Or use OpenSSL's SHA-256 implementation
* Hash output is 32 bytes (256 bits)

=== Tables Included in Hash

The content hash includes the following tables, which represent author-controlled content and potential attack surfaces:

**Included Tables:**
. **`Content_Pages`** - Primary content (HTML pages, chapter structure)
. **`Embedded_Apps`** - Embedded JavaScript applications (critical attack surface)
. **`Form_Definitions`** - Form schemas and validation rules
. **`Settings`** - Author-defined rendering defaults
. **`Content_Themes`** - Theme configurations (colors, fonts, styling)
. **`Metadata`** (partial) - Author metadata fields (see below for specific fields)

**Excluded Tables:**
* **`User_Data`** - User input data (not part of author content, changes per user)
* **`Cartridge_Security`** - Security metadata (circular dependency - contains the hash itself)

**Metadata Fields Included:**
From the `Metadata` table, include the following fields in the hash:

* `title`
* `author`
* `version`
* `publication_year`
* `tags_json`
* `cover_image_path`
* `schema_version`

**Metadata Fields Excluded:**
* `cartridge_guid` - Used separately for identification, not part of content integrity

=== Hash Calculation Algorithm (Option A: Concatenate Table Hashes)

**Approach:** Hash each table independently, then concatenate table hashes and hash the result.

**Step 1: Hash Each Table Independently**

For each table in the specified order (see "Table Ordering" below):

. **Query all rows** from the table, ordered by primary key
. **Serialize each row** to a deterministic byte representation (see "Row Serialization" below)
. **Concatenate all serialized rows** in primary key order
. **Calculate SHA-256 hash** of the concatenated row data
. **Store table hash** (32 bytes) for later concatenation

**Step 2: Concatenate Table Hashes**

. **Concatenate all table hashes** in the specified table order
. **Include table name** as a 4-byte prefix for each table hash (to prevent hash collisions between tables)
   * Table name prefix: First 4 bytes of SHA-256 hash of table name (ensures deterministic, fixed-size prefix)
. **Result:** Single byte array containing: `[table1_prefix][table1_hash][table2_prefix][table2_hash]...`

**Step 3: Calculate Final Hash**

. **Calculate SHA-256 hash** of the concatenated table hashes byte array
. **Result:** H1 (or H2) - 32-byte content hash

=== Table Ordering

Tables are processed in the following fixed order:

. `Content_Pages`
. `Content_Themes`
. `Embedded_Apps`
. `Form_Definitions`
. `Metadata` (partial fields only)
. `Settings`

**Rationale:** Fixed order ensures deterministic hash calculation regardless of database insertion order.

=== Row Ordering

Within each table, rows are ordered by primary key in ascending order:

* **`Content_Pages`:** Ordered by `page_order` (ascending)
* **`Content_Themes`:** Ordered by `theme_id` (alphabetical)
* **`Embedded_Apps`:** Ordered by `app_id` (alphabetical)
* **`Form_Definitions`:** Ordered by `form_id` (alphabetical)
* **`Metadata`:** Single row (no ordering needed)
* **`Settings`:** Ordered by `setting_key` (alphabetical)

=== Row Serialization

Each row is serialized to a deterministic byte representation using the following rules:

**Column Ordering:**
* Columns are serialized in alphabetical order by column name
* This ensures deterministic output regardless of table schema definition order

**Value Serialization:**
* **TEXT fields:** UTF-8 encoded bytes
* **INTEGER fields:** 8-byte big-endian representation
* **BLOB fields:** Raw bytes (no encoding)
* **NULL values:** Single byte `0x00` (null marker)

**Row Delimiter:**
* Each row is terminated with a single newline byte (`0x0A`)
* This prevents concatenation issues when rows are combined

**Example Serialization:**
For a row in `Content_Pages` with:

* `page_id` = 1 (INTEGER)
* `page_order` = 1 (INTEGER)
* `chapter_title` = "Introduction" (TEXT)
* `html_content` = "<p>Hello</p>" (TEXT)
* `associated_css` = NULL

Serialized as (hex representation):
```
[page_id: 8 bytes big-endian 1][page_order: 8 bytes big-endian 1][associated_css: 0x00][chapter_title: UTF-8 "Introduction"][html_content: UTF-8 "<p>Hello</p>"][0x0A]
```

**Column Name Order:** `associated_css`, `chapter_title`, `html_content`, `page_id`, `page_order`

=== Empty Table Handling

**Empty Tables:**
* If a table has no rows, still include it in the hash calculation
* Hash of empty table = SHA-256 of empty byte array (32 bytes of zeros)
* Table name prefix is still included

**Rationale:** Ensures hash changes if a table is added/removed, even if initially empty.

=== Hash Calculation Pseudocode

[source,text]
----
function calculateContentHash(database):
    tableHashes = []
    
    // Define table order
    tables = ["Content_Pages", "Content_Themes", "Embedded_Apps", 
              "Form_Definitions", "Metadata", "Settings"]
    
    for each table in tables:
        // Get table name prefix (first 4 bytes of SHA-256 of table name)
        tableNameHash = SHA256(table)
        tablePrefix = tableNameHash[0:4]
        
        // Query all rows ordered by primary key
        rows = database.query("SELECT * FROM " + table + " ORDER BY primary_key")
        
        // Serialize all rows
        rowData = []
        for each row in rows:
            serializedRow = serializeRow(row, table)  // Alphabetical column order
            rowData.append(serializedRow)
            rowData.append(0x0A)  // Row delimiter
        
        // Hash concatenated row data
        tableHash = SHA256(concatenate(rowData))
        
        // Store prefix + hash
        tableHashes.append(tablePrefix)
        tableHashes.append(tableHash)
    
    // Concatenate all table hashes
    concatenatedHashes = concatenate(tableHashes)
    
    // Calculate final hash
    H1 = SHA256(concatenatedHashes)
    
    return H1
----

=== Verification Process

**H1 (Stored Hash):**
* Calculated by Creator Tool during cartridge finalization
* Stored in `Cartridge_Security.hash_digest` column
* Represents the content state at signing time

**H2 (Recalculated Hash):**
* Calculated by Reader during cartridge loading
* Uses the same algorithm as H1
* Represents the current content state

**Tampering Detection:**
* Compare H1 (stored) vs H2 (recalculated)
* If H1 == H2: Content is intact (no tampering)
* If H1 != H2: Content has been modified (tampering detected)

=== Security Considerations

**Attack Surface Coverage:**
* **Content Pages:** Prevents modification of HTML content
* **Embedded Apps:** Critical - prevents injection of malicious JavaScript code
* **Form Definitions:** Prevents modification of form validation rules
* **Settings & Themes:** Prevents modification of rendering behavior

**Hash Collision Resistance:**
* SHA-256 provides 2^256 possible hash values
* Extremely low probability of collision (cryptographically secure)
* Table name prefixes prevent cross-table hash collisions

**Deterministic Calculation:**
* Fixed table order ensures consistent hashing
* Fixed row order (by primary key) ensures consistent hashing
* Fixed column order (alphabetical) ensures consistent hashing
* UTF-8 encoding ensures consistent text representation

=== Public Key Extraction and Fingerprint Verification

This section details how public keys are obtained and verified during signature verification.

==== Public Key Source

**Primary Method: Extract from Certificate**
* Public keys are **NOT** distributed separately
* Public keys are **extracted from the X.509 certificate** stored in `certificate_data`
* The certificate is embedded in the cartridge itself, making each cartridge self-contained
* No external public key distribution mechanism is required

**Implementation:**
* Use Qt's `QSslCertificate::publicKey()` method to extract the public key from the certificate
* The public key is extracted on-demand during signature verification
* No persistent storage of public keys in the Reader is required

==== Public Key Extraction Process

**Step 1: Certificate Parsing**
. Read `certificate_data` BLOB from `Cartridge_Security` table
. Parse certificate data (supports DER and PEM formats)
. Create `QSslCertificate` object from certificate data

**Step 2: Public Key Extraction**
. Call `QSslCertificate::publicKey()` to extract the public key
. The public key is returned as a `QSslKey` object
. If certificate is missing or invalid, public key extraction fails → Public Key Status = `MISSING` or `INVALID`

**Step 3: Public Key Usage**
* Use extracted public key to verify the `digital_signature`
* The public key is used to decrypt/verify that the signature matches the stored H1 hash
* Public key is not stored persistently; it is extracted fresh for each verification

==== Fingerprint Verification

**Purpose:**
* The `public_key_fingerprint` stored in `Cartridge_Security` serves as an integrity check
* Verifying the fingerprint ensures the certificate (and thus the public key) has not been tampered with
* Fingerprint mismatch indicates potential tampering or corruption

**Fingerprint Calculation:**
. Extract public key from certificate (as described above)
. Calculate fingerprint of the public key using the same algorithm used when creating the cartridge (typically SHA-256)
. Convert fingerprint to the same format as stored `public_key_fingerprint` (typically hexadecimal string)

**Fingerprint Verification Process:**
. Calculate fingerprint of extracted public key
. Compare calculated fingerprint with stored `public_key_fingerprint` from `Cartridge_Security` table
. If fingerprints match → Fingerprint Status = `MATCH`
. If fingerprints do not match → Fingerprint Status = `MISMATCH` (indicates potential tampering)

**Fingerprint Mismatch Handling:**
* Fingerprint mismatch is treated as a security violation
* Cartridge is rejected (same as signature invalid or hash mismatch)
* User is not prompted; cartridge loading is blocked immediately
* This prevents attacks where an attacker might replace the certificate with a different one

==== Public Key Storage

**Reader Storage:**
* **No persistent storage required** - public keys are extracted on-demand from certificates
* Public keys are not cached in the Reader's local database
* Each verification extracts the public key fresh from the certificate

**Cartridge Storage:**
* Public key is embedded in the certificate stored in `certificate_data` column
* `public_key_fingerprint` is stored as a TEXT field for quick integrity checking
* Both are stored in the `Cartridge_Security` table

==== Key Rotation and Updates

**Cartridge Independence:**
* Each cartridge is **self-contained** with its own certificate and public key
* Cartridges are **immutable** once signed - they cannot be updated with new keys
* Old cartridges remain valid with their original certificates indefinitely

**Key Rotation Strategy:**
* **No cross-cartridge key management** is required
* If an author obtains a new certificate/key pair:
  * New cartridges can be signed with the new certificate
  * Old cartridges continue to work with their original certificates
  * No need to update or re-sign existing cartridges

**Certificate Expiration:**
* Expired certificates are handled as described in "Expired CA Certificate Handling" section
* Expired certificates do not invalidate the cartridge; they are downgraded to Level 2
* The public key remains valid for signature verification even if the certificate is expired

**Key Compromise:**
* If an author's private key is compromised:
  * Existing cartridges signed with that key remain valid (they were signed before compromise)
  * New cartridges should be signed with a new key pair
  * Authors should obtain a new certificate and use it for future cartridges
  * No mechanism exists to revoke signatures on existing cartridges (by design, for offline operation)

==== Security Considerations

**Advantages of Certificate-Embedded Public Keys:**
* **Self-contained:** Each cartridge includes everything needed for verification
* **No external dependencies:** No need for public key servers or distribution mechanisms
* **Tamper-resistant:** Fingerprint verification detects certificate replacement
* **Standard practice:** Follows PKI best practices

**Limitations:**
* **No key revocation:** Once a cartridge is signed, the signature cannot be revoked
* **Key compromise handling:** Compromised keys cannot invalidate existing cartridges
* **Offline-first design:** These limitations are intentional to support offline operation

**Fingerprint Verification Benefits:**
* Detects certificate tampering even if signature verification would pass
* Provides additional layer of integrity checking
* Quick comparison (fingerprint is small, fast to compute and compare)
* Prevents certificate substitution attacks

== Embedded Application Specification

=== Concept and Purpose

Embedded applications are **Single Page Applications (SPAs)** or similar interactive components that provide functionality such as:

* Character generators (e.g., RPG character creation)
* Design tools (vehicle/weapon/armor design)
* Calculators and computational tools
* Artifact generators
* Interactive data visualization

**Security Model:**
* **Local Operation Only:** Embedded apps operate entirely locally with **no network access**
* **Sandboxed File System:** Apps can only access a local sandbox directory for storing/retrieving files
* **Isolated Execution:** Each app runs in its own isolated context within the WebEngine
* **User Consent Required:** Apps require explicit user consent (except Level 1 trusted cartridges)

=== JSON Structure: `Embedded_App_Manifest`

The `Embedded_App_Manifest` is stored as JSON in the `manifest_json` column of the `Embedded_Apps` table. This structure defines the application's metadata and resource requirements.

**Creation and Update:**
* Embedded App Manifest is created/updated when the cartridge is created or updated by the Creator Tool
* Manifest is stored as part of the cartridge database during cartridge packaging
* Manifest is validated before being saved to the cartridge

**Error Handling:**
* If manifest creation/update fails in Creator Tool, user is notified with error dialog
* Error dialog includes: operation type (create/update), app ID, error message, and suggested resolution
* Manifest validation errors are caught before saving to cartridge

[cols="1, ^1, 3"]
|===
^.^| Key ^.^| Type ^.^| Description

| `appId` | String | Unique identifier for this application instance. **MUST** match the `app_id` in the `Embedded_Apps` table.
| `name` | String | Human-readable name displayed in the consent prompt and UI.
| `description` | String | Brief explanation of the app's function and purpose.
| `version` | String | Application version (e.g., "1.0.0").
| `entryFile` | String | The primary HTML entry point. For SPAs, this is typically `index.html` or similar. The HTML content is stored in the `entry_html` column.
| `requiredScripts` | Array | List of JavaScript file names or identifiers. Code stored in `js_code` BLOB or referenced from `additional_resources`.
| `requiredStyles` | Array | List of CSS file names or identifiers. Styles stored in `css_code` BLOB or referenced from `additional_resources`.
| `sandboxPermissions` | Array | Reserved for future granular sandbox permission requests (e.g., `["read", "write"]`).
|===

=== Embedded Application Execution Flow

[cols="1, 1, 1", options="header", grid="all"]
|===
^.^| Step ^.^| Action ^.^| Description

| **1. App Request** | Content page calls `SmartbookBridge.requestAppConsent(appId)` | JavaScript in content page requests to load an embedded app
| **2. Consent Check** | Reader checks Effective Trust Policy | If WHITELISTED, proceed. If CONSENT_REQUIRED, show native dialog.
| **3. App Loading** | Reader queries `Embedded_Apps` table | Retrieve app record by `app_id`, extract `manifest_json`, `entry_html`, `js_code`, `css_code`
| **4. Sandbox Creation** | Reader creates isolated sandbox directory | Create unique sandbox directory: `{cartridge_guid}/{app_id}/sandbox/`
| **5. Resource Injection** | Reader injects app resources into WebEngine | Load `entry_html` as base, inject `js_code` and `css_code`, make sandbox API available
| **6. App Execution** | WebEngine executes app JavaScript | App runs in isolated context with access only to sandbox file system via WebChannel API
| **7. Isolation** | Each app instance isolated | Multiple apps can run simultaneously, each with its own sandbox directory
|===

=== Sandbox File System API

Embedded applications access the sandbox file system through the WebChannel Bridge API (see WebChannel API Specification for complete details):

* `saveSandboxFile(filename, data, callback)` - Save file to app's sandbox directory
* `loadSandboxFile(filename, callback)` - Load file from app's sandbox directory
* `listSandboxFiles(callback)` - List files in app's sandbox directory
* `deleteSandboxFile(filename, callback)` - Delete file from sandbox directory

**Security Constraints:**
* Sandbox directory is scoped to `{cartridge_guid}/{app_id}/sandbox/`
* Apps **cannot** access files outside their sandbox
* Apps **cannot** access the host file system
* Apps **cannot** make network requests
* Sandbox is cleared when cartridge is deleted (optional: user preference to retain)

=== JavaScript Security Sandbox and API Restrictions

Qt WebEngine provides native sandboxing capabilities, but additional restrictions are required to ensure embedded applications operate securely within the local-only, sandboxed environment.

==== Qt WebEngine Native Sandboxing

**Built-in Security Features:**
* **Process Isolation:** Each `QWebEngineView` runs in a separate renderer process (Chromium's multi-process architecture)
* **V8 JavaScript Engine:** Isolated JavaScript execution context per view
* **Network Interceptor:** `QWebEngineUrlRequestInterceptor` can block network requests at the profile level
* **CSP Support:** Content Security Policy headers can be enforced

**Isolation Strategy:**
* Each embedded app runs in its own `QWebEngineView` instance
* Complete JavaScript isolation between apps
* Each view has its own WebChannel bridge instance
* Apps cannot access each other's JavaScript or DOM

==== Network API Restrictions

**Blocked APIs (via Interceptor + CSP):**
* **`fetch()`** - All network requests blocked
* **`XMLHttpRequest`** - All network requests blocked
* **`WebSocket`** - All WebSocket connections blocked
* **`EventSource` (Server-Sent Events)** - All SSE connections blocked
* **`<script src="http...">`** - External script loading blocked
* **`<link href="http...">`** - External stylesheet loading blocked
* **`<img src="http...">`** - External image loading blocked (unless cached)
* **`<iframe src="http...">`** - External iframe loading blocked

**Implementation:**
* `QWebEngineUrlRequestInterceptor` blocks all HTTP/HTTPS requests
* CSP header: `connect-src 'none';` prevents network connections
* CSP header: `default-src 'self';` restricts resource loading to local content only

==== File System API Restrictions

**Blocked APIs:**
* **File System Access API** (`window.showOpenFilePicker()`, `window.showSaveFilePicker()`) - Blocked (use WebChannel sandbox API instead)
* **FileReader API** (for local files) - Restricted (can only read files provided via sandbox API)
* **FileWriter API** - Blocked (use WebChannel sandbox API instead)

**Allowed APIs:**
* **FileReader API** (for Blob/ArrayBuffer) - Allowed (for in-memory file processing)
* **Blob API** - Allowed (for creating in-memory file objects)
* **URL.createObjectURL()** - Allowed (for creating blob URLs)

**Rationale:** Direct file system access is blocked to prevent access outside the sandbox. All file operations must go through the WebChannel sandbox API, which enforces path validation and sandbox boundaries.

==== Storage API Restrictions

**Allowed APIs:**
* **`localStorage`** - Allowed (scoped to app's origin, isolated per app instance)
* **`sessionStorage`** - Allowed (scoped to app's origin, cleared on app unload)
* **`IndexedDB`** - Allowed (scoped to app's origin, isolated per app instance)

**Rationale:** Browser storage APIs are isolated per origin/view, providing natural isolation. Apps can use these for temporary data storage without security risks.

==== Clipboard API Restrictions

**Allowed APIs:**
* **`navigator.clipboard.readText()`** - Allowed (read from clipboard)
* **`navigator.clipboard.writeText()`** - Allowed (write to clipboard)
* **`navigator.clipboard.read()`** - Allowed (read clipboard data)
* **`navigator.clipboard.write()`** - Allowed (write clipboard data)

**Rationale:** Clipboard access is safe and useful for user experience (copy/paste functionality). Users control clipboard content, so no security risk.

==== Device Access API Restrictions

**Blocked APIs:**
* **`navigator.geolocation`** - Blocked (privacy concern, not needed for local apps)
* **`navigator.mediaDevices.getUserMedia()`** - Blocked (camera/microphone access not needed)
* **`navigator.mediaDevices.enumerateDevices()`** - Blocked (device enumeration not needed)
* **`navigator.getBattery()`** - Blocked (battery API not needed)
* **`navigator.vibrate()`** - Blocked (vibration API not needed)

**Rationale:** Device access APIs are not needed for local-only applications and pose privacy/security risks.

==== Window and Navigation API Restrictions

**Blocked APIs:**
* **`window.open()`** - Blocked (prevents opening external windows/URLs)
* **`window.location.href = "http..."`** - Blocked (prevents navigation to external URLs)
* **`window.location.replace()`** - Restricted (can only navigate within app's local context)
* **`window.location.assign()`** - Restricted (can only navigate within app's local context)
* **`window.history.pushState()`** - Allowed (for SPA navigation within app)
* **`window.history.replaceState()`** - Allowed (for SPA navigation within app)

**Rationale:** External navigation is blocked to prevent network access. Internal navigation (SPA routing) is allowed for app functionality.

==== Communication API Restrictions

**Blocked APIs:**
* **`window.postMessage()`** - Restricted (can only communicate within same origin/app instance)
* **`BroadcastChannel`** - Restricted (can only communicate within same origin/app instance)
* **`SharedWorker`** - Blocked (not needed, potential security risk)
* **`Service Worker`** - Blocked (not needed, potential security risk, network access risk)

**Rationale:** Cross-origin communication is blocked. Same-origin communication is allowed for app internal functionality.

==== Worker API Restrictions

**Allowed APIs:**
* **`new Worker()`** - Allowed (Web Workers for performance, isolated execution)
* **`new SharedWorker()`** - Blocked (not needed, potential security risk)

**Rationale:** Web Workers are allowed for performance (offloading computation), but SharedWorkers are blocked as they're not needed and pose potential security risks.

==== Evaluation API Restrictions

**Allowed APIs (with CSP):**
* **`eval()`** - Allowed (required for many SPAs, controlled via CSP)
* **`Function()` constructor** - Allowed (required for many SPAs, controlled via CSP)
* **`setTimeout(codeString)`** - Allowed (required for some frameworks, controlled via CSP)

**Rationale:** Dynamic code evaluation is necessary for many SPA frameworks. CSP provides some protection, but primary security comes from network blocking and sandbox isolation.

**CSP Configuration:**
* `script-src 'self' 'unsafe-inline' 'unsafe-eval';` - Allows inline scripts and eval (required for SPAs)

==== WebAssembly API Restrictions

**Allowed APIs:**
* **`WebAssembly.compile()`** - Allowed
* **`WebAssembly.instantiate()`** - Allowed
* **`WebAssembly.compileStreaming()`** - Blocked (requires network, use compile() instead)
* **`WebAssembly.instantiateStreaming()`** - Blocked (requires network, use instantiate() instead)

**Rationale:** WebAssembly is allowed for performance, but streaming APIs are blocked as they require network access.

==== Notification API Restrictions

**Allowed APIs:**
* **`new Notification()`** - Allowed (for user notifications within app)
* **`Notification.requestPermission()`** - Allowed (for permission requests)

**Rationale:** Notifications are safe and useful for user experience. They're scoped to the app instance.

==== Content Security Policy (CSP) Configuration

**CSP Header for Embedded Apps:**
```
default-src 'self';
script-src 'self' 'unsafe-inline' 'unsafe-eval';
style-src 'self' 'unsafe-inline';
connect-src 'none';
img-src 'self' data: blob:;
font-src 'self' data:;
object-src 'none';
base-uri 'self';
form-action 'none';
frame-ancestors 'none';
```

**CSP Directives Explained:**
* `default-src 'self'` - Only load resources from same origin (local app content)
* `script-src 'self' 'unsafe-inline' 'unsafe-eval'` - Allow inline scripts and eval (required for SPAs)
* `style-src 'self' 'unsafe-inline'` - Allow inline styles (required for SPAs)
* `connect-src 'none'` - Block all network connections (fetch, XHR, WebSocket, etc.)
* `img-src 'self' data: blob:` - Allow images from same origin, data URIs, and blob URLs
* `font-src 'self' data:` - Allow fonts from same origin and data URIs
* `object-src 'none'` - Block plugins (Flash, etc.)
* `base-uri 'self'` - Restrict base tag URLs
* `form-action 'none'` - Block form submissions (not needed, apps use WebChannel API)
* `frame-ancestors 'none'` - Prevent embedding in iframes

==== Network Request Interceptor Implementation

**Implementation Approach:**
* Create custom `QWebEngineUrlRequestInterceptor` subclass
* Override `interceptRequest()` method
* Block all HTTP/HTTPS requests (return `QWebEngineUrlRequestInterceptor::RequestIntercepted`)
* Allow only `data:`, `blob:`, and `file://` URLs (for local content)
* Log blocked requests for debugging (optional)

**Code Structure (Conceptual):**
[source,cpp]
----
class EmbeddedAppRequestInterceptor : public QWebEngineUrlRequestInterceptor {
public:
    void interceptRequest(QWebEngineUrlRequestInfo &info) override {
        QUrl url = info.requestUrl();
        QString scheme = url.scheme().toLower();
        
        // Block all network requests
        if (scheme == "http" || scheme == "https") {
            info.block(true);
            return;
        }
        
        // Allow local schemes
        if (scheme == "data" || scheme == "blob" || scheme == "file") {
            info.block(false);
            return;
        }
        
        // Block everything else
        info.block(true);
    }
};
----

==== Security Layers Summary

**Defense in Depth:**
. **Process Isolation** (Qt WebEngine native) - Apps run in separate renderer processes
. **Network Interceptor** (Primary defense) - Blocks all network requests at the profile level
. **CSP Headers** (Secondary defense) - Restricts resource loading and connections
. **API Restrictions** (Tertiary defense) - Blocks/restricts dangerous JavaScript APIs
. **Sandbox File System** (Controlled access) - All file operations go through validated WebChannel API

**Security Model:**
* **Default Deny:** All network access denied by default
* **Whitelist Approach:** Only explicitly allowed APIs are available
* **Isolation:** Each app runs in its own isolated context
* **Validation:** All file operations validated for path traversal prevention

== Application Architecture and Window Management

=== Multi-Window Design

The Smartbook Reader SHALL implement a Multi-Window Architecture: a single **Library Manager** and multiple, independent **Reader View** instances, allowing simultaneous viewing of multiple cartridges.

=== Component Isolation

* **Database Isolation:** Each Reader View is isolated to its single cartridge file.
* **WebChannel Scope:** The `SmartbookBridge` is uniquely instantiated per Reader View instance.

=== Window Opening Mechanisms

**Double-Click Opening:**
* **List View:** Double-clicking a cartridge title opens the cartridge in a new Reader View Window
* **Grid View:** Double-clicking a cartridge cover opens the cartridge in a new Reader View Window
* Visual feedback: Brief highlight or selection indicator when double-click is detected
* Opens new window immediately (no confirmation dialog)

**Context Menu Opening:**
* **List View:** Right-clicking a cartridge title displays a context menu
* **Grid View:** Right-clicking a cartridge cover displays a context menu
* Context menu options:
  * **Open** - Opens cartridge in new Reader View Window (primary action)
  * **Open in New Window** - Explicitly opens in new window (redundant but follows platform conventions)
  * **Properties** - Display cartridge metadata (optional, Phase 2)
  * **Delete** - Remove cartridge from library (existing functionality)
* Context menu follows platform conventions (e.g., macOS: native context menu, Windows: Qt context menu)

**Platform Conventions:**
* Behavior should mimic established e-book applications:
  * **Calibre:** Double-click opens book, right-click shows context menu
  * **Apple Books:** Click opens book, right-click shows context menu
  * **Adobe Digital Editions:** Double-click opens book, right-click shows context menu
* Follow platform-specific UI guidelines (macOS Human Interface Guidelines, Windows UI Guidelines, Linux desktop environment guidelines)

=== Window State Persistence

**Window State Components:**
* **Window Geometry:**
  * Width (pixels)
  * Height (pixels)
  * X position (screen coordinates, left edge)
  * Y position (screen coordinates, top edge)
* **Window State:**
  * Maximized flag (boolean)
  * Note: Minimized state is not persisted (window restores to previous non-minimized state)
* **Reading Position:** (See "Reading Position Persistence" section)
  * `page_id`
  * `anchor_id` (optional)
  * `scroll_position` (pixels from top)

**Save Window State:**
* Triggered when Reader View Window is closed (user closes window or application quits)
* Save to `Local_Window_State` table:
  * Insert or update entry for `cartridge_guid`
  * Store window geometry (width, height, x, y)
  * Store maximized state
  * Update `last_updated` timestamp
* Save reading position to `Local_Reading_Position` table (see "Reading Position Persistence" section)
* Both saves occur atomically (in same transaction if possible)

**Window State Save Algorithm:**
. **On Window Close Event:**
   a. Get current window geometry: `QMainWindow::geometry()` or `QMainWindow::frameGeometry()`
   b. Get window state: `QMainWindow::isMaximized()`
   c. Get reading position from WebEngine view (current page, scroll position)
   d. Open transaction on local database
   e. Insert or update `Local_Window_State` entry
   f. Insert or update `Local_Reading_Position` entry
   g. Commit transaction
   h. Close window

. **On Application Quit:**
   a. Iterate through all open Reader View Windows
   b. For each window, save window state and reading position (as above)
   c. Close all windows

**Window State Validation:**
* Before restoring window state, validate saved geometry:
  * Check if saved position is within current screen bounds (accounting for multi-monitor setups)
  * Check if saved size is within reasonable bounds (minimum: 400x300, maximum: screen size)
  * If validation fails, use default window size and position

=== Window State Restoration

**Restore Window State:**
* Triggered when cartridge is opened in new Reader View Window
* Query `Local_Window_State` table for `cartridge_guid`
* If entry exists:
  * Restore window geometry (width, height, x, y)
  * Restore maximized state (if was maximized, restore maximized)
  * If entry doesn't exist, use default window size and position
* Query `Local_Reading_Position` table for `cartridge_guid`
* If entry exists:
  * Navigate to saved `page_id`
  * Navigate to saved `anchor_id` (if present)
  * Scroll to saved `scroll_position`
* If no reading position exists, navigate to first page

**Window State Restoration Algorithm:**
. **On Cartridge Open:**
   a. Create new `ReaderViewInstance` window
   b. Query `Local_Window_State` for `cartridge_guid`
   c. If entry found:

      * Validate saved geometry (see "Window State Validation" above)
      * If valid: Set window geometry using `QMainWindow::setGeometry()` or `QMainWindow::resize()` and `QMainWindow::move()`
      * If was maximized: Call `QMainWindow::showMaximized()`
      * If invalid: Use default geometry
   d. If entry not found:

      * Use default window size (e.g., 1024x768) and center on screen
   e. Show window
   f. Load cartridge content
   g. Query `Local_Reading_Position` for `cartridge_guid`
   h. If entry found:

      * Navigate to saved `page_id`
      * If `anchor_id` present, scroll to anchor
      * If `scroll_position` present, scroll to position
   i. If entry not found:

      * Navigate to first page

**Default Window Geometry:**
* **Default Size:** 1024x768 pixels (or 80% of primary screen size, whichever is smaller)
* **Default Position:** Centered on primary screen
* **Default State:** Normal (not maximized)

**Multi-Monitor Handling:**
* If saved window position is on a monitor that no longer exists:
  * Move window to primary monitor
  * Center window on primary monitor
* If saved window size exceeds current screen size:
  * Resize to fit within screen bounds
  * Maintain aspect ratio if possible

=== Window Minimize and Restore Behavior

**Standard OS Behavior:**
* **Minimize:** Follow platform conventions:
  * **Windows:** Window minimizes to taskbar
  * **macOS:** Window minimizes to Dock (if enabled) or hides
  * **Linux:** Window minimizes to taskbar/panel (desktop environment dependent)
* **Restore:** Follow platform conventions:
  * **Windows:** Click taskbar icon to restore
  * **macOS:** Click Dock icon or use Mission Control
  * **Linux:** Click taskbar/panel icon to restore

**Implementation:**
* Use Qt's standard window management:
  * `QMainWindow::showMinimized()` - Minimize window
  * `QMainWindow::showNormal()` - Restore from minimized/maximized
  * `QMainWindow::showMaximized()` - Maximize window
* Minimized state is NOT persisted (window restores to previous non-minimized state)
* Window state (normal/maximized) is persisted, but minimized state is transient

**Window State Transitions:**
* **Normal → Minimized:** Window minimizes, state not saved
* **Minimized → Normal:** Window restores to previous size/position (from `Local_Window_State`)
* **Normal → Maximized:** Window maximizes, state saved on close
* **Maximized → Normal:** Window restores to saved size/position, state saved on close
* **Maximized → Minimized:** Window minimizes, maximized state preserved (restores to maximized when unminimized)

=== Window Closing Behavior

**User-Initiated Close:**
* User clicks window close button (X button)
* User selects File → Close from menu
* User presses platform-specific close shortcut (e.g., Ctrl+W, Cmd+W)
* Before closing:
  * Save window state (geometry, position, maximized state)
  * Save reading position (page, anchor, scroll position)
  * Close window

**Application Quit:**
* User quits application (File → Quit, platform-specific quit shortcut)
* Before quitting:
  * Save window state for all open Reader View Windows
  * Save reading position for all open Reader View Windows
  * Close all windows
  * Exit application

**Close Confirmation (Optional):**
* No confirmation dialog by default (follows platform conventions)
* Reading position and window state are automatically saved
* User can immediately reopen cartridge to continue reading

**Multiple Windows:**
* Each Reader View Window is independent
* Closing one window does not affect other open windows
* Each window saves its own state independently
* Library Manager window state is NOT persisted (always opens with default geometry)

== Creator Tool's Cartridge Packaging Algorithm

=== Phase 1: Content Assembly and GUID Generation

[cols="1,1,1", options="header", grid="all"]
|===
^.^| Step ^.^| Action by Creator Tool ^.^| Output

| **1. Initialize Database** | Create a new, empty SQLite file and define all required table schemas. | Empty Cartridge DB
| **2. Generate GUID** | Generate a new, globally unique **UUID Version 4** string. | `cartridge_guid`
| **3. Populate Metadata** | Insert `cartridge_guid`, `title`, and other metadata (including `publication_year`) into `Metadata`. | Metadata Table Populated
| **4. Insert Content** | Insert all content data into `Content_Pages`, `Form_Definitions`, etc. | Content Tables Populated
|===
=== Phase 2: Hash Calculation and Security Preparation

[cols="1,1,1", options="header", grid="all"]
|===
^.^| Step ^.^| Action by Creator Tool ^.^| Output 

| **1. Serialize Critical Tables** | Export the binary representation of the critical tables using the Content Hash Algorithm (see "Content Hash Algorithm Specification" section below). | Binary Content Blob
| **2. Calculate Content Hash (H1)** | Calculate the hash using SHA-256 algorithm as specified in the Content Hash Algorithm Specification. | H1 (Content Hash) 
| **3. Determine Signing Method** | Prompt author to choose signing method (Level 1, 2, or 3). | Signing Intent 
|===

=== Phase 3: Signature Application and Finalization

[cols="1,1,1", options="header", grid="all"]
|===
^.^| Step ^.^| Action by Creator Tool ^.^| Output 

| **1. Apply Signature** | *If Level 1/2 selected:* Use Private Key to sign H1, creating the `digital_signature`. | `digital_signature` 
| **2. Extract Key Info** | Extract the `digest_type` and the `public_key_fingerprint`. | Key Info 
| **3. Populate Security Table** | Insert one row into the `Cartridge_Security` table with H1, `digital_signature`, and key info. *If Level 3 selected, this table remains empty.* | `Cartridge_Security` Table Populated 
| **4. Finalize Cartridge** | Close and optimize the SQLite database connection. Export the final `.sqlite` file. | Final, Secured Cartridge File 
|===

== C++ Class Hierarchy and Data Flow (Implementation Design)

[NOTE]
====
See `diagrams.adoc` for visual representations including:

* Component Interaction Diagram - Shows how components interact during cartridge loading
* Data Flow Diagrams - Illustrate cartridge data flow and form data persistence flow
* Sequence Diagrams - Cartridge loading, embedded app execution, form data save, import, and trust revocation processes
====

=== Core Application Management Classes

[cols="1, 1, 3, 2", options="header", grid="all"]
|===
^.^| Class Name ^.^| Inheritance ^.^| Responsibility ^.^| Dependencies

| **`SmartbookApp`** | `QApplication` | Manages the application lifecycle, initialization of the local DB, and the set of active `ReaderViewInstance` windows. | `LocalDBManager`
| **`LocalDBManager`** | `QObject` | Manages connections to the `Local_Library_Manifest` and `Local_Trust_Registry`. Provides centralized trust/metadata lookup. | SQLite API
|===

=== Reader View Instance Classes (Per Cartridge)

[cols="1, ^1, 3, 2"]
|===
^.^| Class Name ^.^| Inheritance ^.^| Responsibility ^.^| Dependencies

| **`ReaderViewInstance`** | `QMainWindow` | **Primary Session Container.** Owns the WebEngine, Bridge, and DB Connector for a single cartridge. Executes the final load based on Policy. | `QWebEngineView`, `SignatureVerifier`, `SmartbookBridge`
| **`CartridgeDBConnector`** | `QObject` | Manages the SQLite connection to the active cartridge file. Executes all persistence CRUD operations (`User_Data`). | SQLite API
| **`SignatureVerifier`** | `QObject` | Executes the 4-phase Verification Algorithm (Sec 6). Outputs the **Effective Trust Policy**. | `LocalDBManager` (read access)
| **`SmartbookBridge`** | `QObject` | Exposes C++ methods to JS via **Qt WebChannel**. Checks the internal trust policy before triggering the native consent dialog. | `ReaderViewInstance` (parent), `QWebChannel`
|===

// Removed Image placeholder

== User Interface (UI) Design Specification (FINAL)

The UI is divided into two primary windows, adhering to the Multi-Window Architecture.

=== Window 1: Library Manager (The Hub) - Dual View (FINAL)

The Library Manager MUST allow the user to toggle between two modes: the visual **Bookshelf View** and the detailed **List-View**.

==== Bookshelf View (Visual Mode)

[cols="1, 1, 1", options="header", grid="all"]
|===
^.^| Element ^.^| Specification Detail ^.^| Visual/Interaction Focus

| **Layout** | Responsive grid simulating a bookshelf (3-4 columns). | Prioritizes visual browsing speed (NFR-3.1).
| **Cartridge Tile Content** | Prominent **Cover Image** (`cover_image_data`). If null, a generic image must be used with the **Title** centered. | Minimal text to maintain visual focus.
| **Security Status Badge** | Color-coded icon (L1/L2/L3) in the tile's corner. | Visual indication of trust level.
| **Location Status Icon** | Dedicated icon for local/remote status (Cloud/Checkmark). | **Phase 2 requirement.**
| **Delete Action** | Context Menu entry on the tile. | Triggers native confirmation dialog (FR-2.5.5).
|===
// Removed Image placeholder

==== List-View (Data Grid Mode)

[cols="1, 1, 1", options="header", grid="all"]
|===
^.^| Element ^.^| Specification Detail ^.^| Visual/Interaction Focus

| **Layout** | Sortable, filterable tabular data grid (`QTableView`). | Prioritizes data management and sorting.
| **Mandatory Columns** | **Title, Author, Edition/Version, Year of Publication.** | Sourced from `Local_Library_Manifest`.
| **Delete Action** | Context Menu and **Delete** keyboard shortcut. | Triggers native confirmation dialog (FR-2.5.5).
| **Trust Management** | Dedicated button or right-click context menu entry. | Access point for **Trust Revocation** (FR-2.4.3).
|===
// Removed Image placeholder

=== Window 2: Reader View (The Content)

[cols="1, 2, 2", options="header", grid="all"]
|===
^.^| Element ^.^| Component / Function ^.^| Security Display Requirement

| **Integrity Warning Bar** | Persistent, non-dismissible colored banner fixed above content. | Must be visible for Level 2 and Level 3 cartridges.
| **Cartridge Loading Consent Dialog** | Native modal dialog displayed when opening Level 2 or Level 3 cartridges. | Detailed requirements in 11.2.1.
| **App Consent Dialog** | Native modal window triggered by `requestAppConsent`. | Detailed requirements in 11.2.2.
|===

==== Cartridge Loading Consent Dialog Requirements

This dialog appears when a user attempts to open a Level 2 (Self-Signed Trust) or Level 3 (No Signature) cartridge, before the cartridge content is loaded. The dialog allows the user to decide whether to load the cartridge and optionally add it to the whitelist for future loads.

=== Dialog Appearance and Positioning

**Modal Dialog Requirements:**
* **Type:** Native OS modal dialog (Qt `QMessageBox` or custom modal dialog)
* **Positioning:** Centered horizontally and vertically on the primary screen
* **Size:** Minimum 400px width, auto-height based on content (maximum 600px height)
* **Modal Behavior:** Blocks all interaction with the Reader application until dismissed
* **Accessibility:** Keyboard navigation (Tab, Enter, Escape), screen reader support

=== Dialog Content and Verbiage

==== For Level 2 (Self-Signed Certificate) Cartridges

**Title:** "Security Warning: Self-Signed Cartridge"

**Main Message:**
----
This cartridge is signed with a self-signed certificate and cannot be verified by a trusted authority.

Cartridge: [Title]
Author: [Author Name]
Security Level: Level 2 (Self-Signed Trust)

⚠️ WARNING: This cartridge has not been verified by a trusted certificate authority. The content may have been modified or could contain potentially unsafe embedded applications.

Do you want to load this cartridge?
----

**Options:**
. "Load and Always Trust" (Adds to whitelist) — Default button
. "Load for This Session Only" (Temporary trust)
. "Cancel" (Do not load)

==== For Level 3 (No Signature) Cartridges

**Title:** "Security Warning: Unsigned Cartridge"

**Main Message:**
----
This cartridge has no digital signature and cannot be verified.

Cartridge: [Title]
Author: [Author Name]
Security Level: Level 3 (No Signature)

⚠️ WARNING: This cartridge has no digital signature. The content cannot be verified and may have been modified. Embedded applications may pose security risks.

Do you want to load this cartridge?
----

**Options:**
. "Load and Always Trust" (Adds to whitelist)
. "Load for This Session Only" (Temporary trust)
. "Cancel" (Do not load)

=== Dismissal Behavior

**When "Load and Always Trust" is selected:**
* Cartridge is added to the `Local_Trust_Registry` with `trust_type = 'PERSISTENT'`
* Cartridge is loaded and displayed in the Reader View Window
* Future loads of this cartridge bypass the consent dialog
* Integrity warning bar is still displayed (as per FR-2.3.2/2.3.3)

**When "Load for This Session Only" is selected:**
* Cartridge is loaded and displayed in the Reader View Window
* No entry is added to `Local_Trust_Registry`
* Consent dialog will appear again on next load
* Integrity warning bar is displayed

**When "Cancel" is selected (or dialog closed via Escape/X button):**
* Cartridge is **not loaded**
* Reader View Window is **not opened**
* User is returned to the Library Manager
* No entry is added to `Local_Trust_Registry`
* No error message is displayed (user choice)

=== Implementation Details

**Dialog Trigger:**
* Dialog appears immediately when user attempts to open a Level 2 or Level 3 cartridge
* Triggered before cartridge content is loaded into memory
* If cartridge is already in `Local_Trust_Registry` with valid trust, dialog is skipped

**Dialog Dismissal Methods:**
* Clicking one of the three action buttons
* Pressing Escape key (treated as "Cancel")
* Clicking the window close button (X) (treated as "Cancel")
* Alt+F4 / Cmd+Q (application quit) — treated as "Cancel" for that cartridge

**Error Handling:**
* If dialog cannot be displayed (UI error), log error and treat as "Cancel"
* If trust registry update fails after "Load and Always Trust", load cartridge but show warning that persistent trust was not saved

==== Native App Consent Dialog Requirements

[cols="1, 2, 2", options="header", grid="all"]
|===
^.^| Element ^.^| Specification Detail ^.^| Required Functionality

| **Appearance** | Must be a native OS modal dialog. | Conveys security authority to the user.
| **Required Content** | Cartridge Security Level, App Name, App Description. | Clear presentation of risk and function.
| **Trust Options (FR-2.4.2)** | Three mutually exclusive radio button choices: a|
. Trust for this session.
. **Always trust this cartridge.**
. Block execution.
|===
// Removed Image placeholder

== Qt WebEngine Configuration Implementation

This section specifies the detailed configuration of Qt WebEngine for the Reader and Creator Tool applications, including profile settings, security configuration, performance optimization, and standards compliance.

=== Qt WebEngine Version Requirements

**Minimum Qt Version:**
* **Qt 6.2+** (recommended: Qt 6.5+)
* **Qt WebEngine Module:** Required module, must be included in build configuration

**Chromium Version:**
* Qt WebEngine 6.2+ uses Chromium 91+
* Qt WebEngine 6.5+ uses Chromium 108+
* **Documentation Requirement:** Application SHALL document the exact Chromium version at build time (display in About dialog or log at startup)

**V8 JavaScript Engine:**
* V8 version is determined by Chromium version
* Qt WebEngine 6.2+ uses V8 9.1+
* Qt WebEngine 6.5+ uses V8 10.8+
* **Documentation Requirement:** Application SHALL document the exact V8 version at build time

**HTML/CSS Standards:**
* **HTML5 Support:** Full support for HTML5 specification as implemented by Chromium version (typically 95%+ compliance)
* **CSS3 Support:** Full support for CSS3 specification as implemented by Chromium version (typically 90%+ compliance)
* **ECMAScript Support:** Full support for ECMAScript 2022 (ES13) and earlier versions

=== WebEngine Profile Configuration

==== Reader Content Rendering Profile

**Profile Purpose:** Render cartridge content pages (HTML content from `Content_Pages` table)

**Profile Configuration:**

[source,cpp]
----
QWebEngineProfile* contentProfile = new QWebEngineProfile("ContentProfile", this);

// Security Settings
contentProfile->settings()->setAttribute(QWebEngineSettings::LocalContentCanAccessRemoteUrls, false);
contentProfile->settings()->setAttribute(QWebEngineSettings::LocalContentCanAccessFileUrls, true);
contentProfile->settings()->setAttribute(QWebEngineSettings::JavascriptEnabled, true);
contentProfile->settings()->setAttribute(QWebEngineSettings::PluginsEnabled, false);
contentProfile->settings()->setAttribute(QWebEngineSettings::WebGLEnabled, true);

// Performance Settings
contentProfile->settings()->setAttribute(QWebEngineSettings::Accelerated2dCanvasEnabled, true);
contentProfile->settings()->setAttribute(QWebEngineSettings::AcceleratedCompositingEnabled, true);
contentProfile->settings()->setAttribute(QWebEngineSettings::SpatialNavigationEnabled, false);

// Cache Settings
contentProfile->setHttpCacheType(QWebEngineProfile::DiskHttpCache);
contentProfile->setHttpCacheMaximumSize(50 * 1024 * 1024); // 50MB cache

// Storage Settings
contentProfile->settings()->setAttribute(QWebEngineSettings::LocalStorageEnabled, true);
contentProfile->settings()->setAttribute(QWebEngineSettings::SessionStorageEnabled, true);

// Service Workers (disabled for security)
contentProfile->setHttpCacheType(QWebEngineProfile::DiskHttpCache); // Note: Service workers disabled via NoCache for embedded apps
----

**Settings Rationale:**
* `LocalContentCanAccessRemoteUrls: false` - Prevents local content from accessing remote URLs (security)
* `LocalContentCanAccessFileUrls: true` - Allows loading local resources (images, fonts, etc.)
* `JavascriptEnabled: true` - Required for interactive content and embedded applications
* `PluginsEnabled: false` - Disables Flash and other plugins (security, plugins are deprecated)
* `WebGLEnabled: true` - Enables WebGL for graphics rendering (if needed by content)
* `Accelerated2dCanvasEnabled: true` - Hardware acceleration for canvas operations (performance)
* `AcceleratedCompositingEnabled: true` - Hardware-accelerated compositing (performance)
* `LocalStorageEnabled: true` - Allows localStorage for content persistence
* `SessionStorageEnabled: true` - Allows sessionStorage for temporary data

==== Embedded Application Profile

**Profile Purpose:** Execute embedded JavaScript applications (from `Embedded_Apps` table)

**Profile Configuration:**

[source,cpp]
----
QWebEngineProfile* embeddedAppProfile = new QWebEngineProfile("EmbeddedAppProfile", this);

// Security Settings (Strict)
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::LocalContentCanAccessRemoteUrls, false);
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::LocalContentCanAccessFileUrls, false);
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::JavascriptEnabled, true);
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::PluginsEnabled, false);
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::WebGLEnabled, true);

// Performance Settings
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::Accelerated2dCanvasEnabled, true);
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::AcceleratedCompositingEnabled, true);

// Cache Settings (No cache to prevent service workers)
embeddedAppProfile->setHttpCacheType(QWebEngineProfile::NoCache);

// Storage Settings (Isolated per app)
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::LocalStorageEnabled, true);
embeddedAppProfile->settings()->setAttribute(QWebEngineSettings::SessionStorageEnabled, true);

// Network Interceptor (Blocks all HTTP/HTTPS)
EmbeddedAppRequestInterceptor* interceptor = new EmbeddedAppRequestInterceptor(this);
embeddedAppProfile->setUrlRequestInterceptor(interceptor);
----

**Key Differences from Content Profile:**
* `LocalContentCanAccessFileUrls: false` - Embedded apps cannot access file: URLs (must use sandbox API)
* `HttpCacheType: NoCache` - Prevents service workers and caching (security)
* Network interceptor attached to block all network requests

==== Creator Tool Editing Profile

**Profile Purpose:** WYSIWYG HTML editing interface in Creator Tool

**Profile Configuration:**

[source,cpp]
----
QWebEngineProfile* editorProfile = new QWebEngineProfile("EditorProfile", this);

// Security Settings (Less restrictive for editing)
editorProfile->settings()->setAttribute(QWebEngineSettings::LocalContentCanAccessRemoteUrls, false);
editorProfile->settings()->setAttribute(QWebEngineSettings::LocalContentCanAccessFileUrls, true);
editorProfile->settings()->setAttribute(QWebEngineSettings::JavascriptEnabled, true);
editorProfile->settings()->setAttribute(QWebEngineSettings::PluginsEnabled, false);

// Performance Settings
editorProfile->settings()->setAttribute(QWebEngineSettings::Accelerated2dCanvasEnabled, true);
editorProfile->settings()->setAttribute(QWebEngineSettings::AcceleratedCompositingEnabled, true);

// Cache Settings (Larger cache for editing performance)
editorProfile->setHttpCacheType(QWebEngineProfile::DiskHttpCache);
editorProfile->setHttpCacheMaximumSize(100 * 1024 * 1024); // 100MB cache

// Storage Settings
editorProfile->settings()->setAttribute(QWebEngineSettings::LocalStorageEnabled, true);
editorProfile->settings()->setAttribute(QWebEngineSettings::SessionStorageEnabled, true);
----

**Key Differences:**
* Larger cache (100MB vs 50MB) for better editing performance
* File URL access enabled for loading local resources during editing
* No network interceptor (editing interface may need to load local resources)

=== Network Request Interceptor Implementation

==== Interceptor Class Definition

**Purpose:** Block all HTTP/HTTPS requests from embedded applications while allowing local resource loading

**Implementation:**

[source,cpp]
----
class EmbeddedAppRequestInterceptor : public QWebEngineUrlRequestInterceptor {
    Q_OBJECT
public:
    explicit EmbeddedAppRequestInterceptor(QObject* parent = nullptr)
        : QWebEngineUrlRequestInterceptor(parent) {}
    
    void interceptRequest(QWebEngineUrlRequestInfo &info) override {
        QUrl url = info.requestUrl();
        QString scheme = url.scheme().toLower();
        
        // Allow data: and blob: URLs (for inline resources)
        if (scheme == "data" || scheme == "blob") {
            return; // Allow request
        }
        
        // Block all HTTP/HTTPS requests
        if (scheme == "http" || scheme == "https") {
            qWarning() << "Blocked network request:" << url.toString();
            info.block(true);
            return;
        }
        
        // Block file: URLs (apps should use sandbox API instead)
        if (scheme == "file") {
            qWarning() << "Blocked file URL request:" << url.toString();
            info.block(true);
            return;
        }
        
        // Allow other schemes (about:, chrome:, etc.) - these are internal
        // Note: Most internal schemes are already handled by WebEngine
    }
};
----

**Interceptor Usage:**
* Attach interceptor to embedded application profile: `embeddedAppProfile->setUrlRequestInterceptor(interceptor)`
* Interceptor applies to all requests from views using that profile
* Log all blocked requests for debugging and security monitoring

=== Content Security Policy (CSP) Configuration

==== CSP Header for Embedded Applications

**CSP Policy String:**
```
default-src 'self' 'unsafe-inline' 'unsafe-eval'; 
script-src 'self' 'unsafe-inline' 'unsafe-eval'; 
style-src 'self' 'unsafe-inline'; 
connect-src 'none'; 
img-src 'self' data: blob:; 
font-src 'self' data:; 
object-src 'none'; 
base-uri 'self'; 
form-action 'none';
```

**Policy Directive Explanation:**
* `default-src 'self' 'unsafe-inline' 'unsafe-eval'` - Default policy allows same-origin resources, inline scripts/styles, and eval (required for SPAs)
* `script-src 'self' 'unsafe-inline' 'unsafe-eval'` - Scripts from same origin, inline scripts, and eval() allowed
* `style-src 'self' 'unsafe-inline'` - Styles from same origin and inline styles allowed
* `connect-src 'none'` - **No network connections allowed** (primary security directive)
* `img-src 'self' data: blob:` - Images from same origin, data URIs, and blob URLs
* `font-src 'self' data:` - Fonts from same origin and data URIs
* `object-src 'none'` - No plugins/objects (Flash, etc.)
* `base-uri 'self'` - Base tag can only point to same origin
* `form-action 'none'` - Forms cannot submit (apps use WebChannel API instead)

**CSP Implementation:**

[source,cpp]
----
void ReaderViewInstance::setCSPHeaders(QWebEnginePage* page) {
    QString cspPolicy = 
        "default-src 'self' 'unsafe-inline' 'unsafe-eval'; "
        "script-src 'self' 'unsafe-inline' 'unsafe-eval'; "
        "style-src 'self' 'unsafe-inline'; "
        "connect-src 'none'; "
        "img-src 'self' data: blob:; "
        "font-src 'self' data:; "
        "object-src 'none'; "
        "base-uri 'self'; "
        "form-action 'none'";
    
    // Set CSP header via custom request interceptor or page load
    // Note: CSP can be set via QWebEngineHttpRequest::setHeader() or
    // by injecting meta tag into HTML content
}
----

**CSP Enforcement:**
* CSP is a **secondary defense layer** - primary network blocking is via `QWebEngineUrlRequestInterceptor`
* CSP violations are logged by Chromium (can be captured via JavaScript console)
* CSP provides defense-in-depth security

=== WebChannel Configuration

==== WebChannel Setup for Reader

**Bridge Registration:**

[source,cpp]
----
void ReaderViewInstance::setupWebChannel(QWebEngineView* view) {
    QWebChannel* channel = new QWebChannel(this);
    SmartbookBridge* bridge = new SmartbookBridge(this, m_cartridgeConnector);
    
    // Register bridge object with name "SmartbookBridge"
    channel->registerObject("SmartbookBridge", bridge);
    
    // Set channel on page
    view->page()->setWebChannel(channel);
    
    // Inject WebChannel script (required for JavaScript-to-C++ communication)
    QFile webChannelJs(":/qtwebchannel/qwebchannel.js");
    if (webChannelJs.open(QIODevice::ReadOnly)) {
        QString script = webChannelJs.readAll();
        view->page()->runJavaScript(script);
    } else {
        qWarning() << "Failed to load qwebchannel.js";
    }
}
----

**WebChannel Script Injection:**
* Qt WebEngine requires `qwebchannel.js` to be injected into the page
* Script is typically bundled with Qt WebEngine module (resource file)
* Script must be injected before any JavaScript code that uses WebChannel
* Script enables JavaScript-to-C++ communication via `SmartbookBridge` object

**JavaScript Usage:**
* After script injection, JavaScript can access: `new QWebChannel(qt.webChannelTransport, function(channel) { ... })`
* Access bridge object: `channel.objects.SmartbookBridge`
* Call C++ methods: `SmartbookBridge.saveFormData(...)`

=== Error Handling Configuration

==== JavaScript Console Error Handling

**Console Message Handler:**

[source,cpp]
----
void ReaderViewInstance::setupErrorHandling(QWebEnginePage* page) {
    // Connect to JavaScript console messages
    connect(page, &QWebEnginePage::javascriptConsoleMessage,
            this, &ReaderViewInstance::onJavaScriptConsoleMessage);
}

void ReaderViewInstance::onJavaScriptConsoleMessage(
    QWebEnginePage::JavaScriptConsoleMessageLevel level,
    const QString& message,
    int lineNumber,
    const QString& sourceID) {
    
    // Log JavaScript errors and warnings
    if (level == QWebEnginePage::ErrorMessageLevel) {
        qWarning() << "JavaScript Error:" << message 
                   << "at line" << lineNumber 
                   << "in" << sourceID;
        // Log to application log file with ERROR level
    } else if (level == QWebEnginePage::WarningMessageLevel) {
        qInfo() << "JavaScript Warning:" << message;
        // Log to application log file with WARN level
    }
    
    // Optionally display error overlay in UI for critical errors
    if (level == QWebEnginePage::ErrorMessageLevel) {
        // Show non-intrusive error indicator
    }
}
----

==== WebEngine Process Crash Handling

**Crash Detection:**

[source,cpp]
----
void ReaderViewInstance::setupCrashHandling(QWebEngineView* view) {
    // Connect to render process terminated signal
    connect(view->page(), &QWebEnginePage::renderProcessTerminated,
            this, &ReaderViewInstance::onRenderProcessTerminated);
}

void ReaderViewInstance::onRenderProcessTerminated(
    QWebEnginePage::RenderProcessTerminationStatus status,
    int exitCode) {
    
    QString statusText;
    switch (status) {
        case QWebEnginePage::NormalTerminationStatus:
            statusText = "Normal termination";
            break;
        case QWebEnginePage::AbnormalTerminationStatus:
            statusText = "Abnormal termination (crash)";
            break;
        case QWebEnginePage::CrashedTerminationStatus:
            statusText = "Process crashed";
            break;
        case QWebEnginePage::KilledTerminationStatus:
            statusText = "Process killed";
            break;
    }
    
    qCritical() << "WebEngine process terminated:" << statusText 
                << "Exit code:" << exitCode;
    
    // Log to application log file with ERROR level
    // Display recovery dialog to user
    showRecoveryDialog();
}

void ReaderViewInstance::showRecoveryDialog() {
    QMessageBox dialog(this);
    dialog.setIcon(QMessageBox::Critical);
    dialog.setWindowTitle("Content Viewer Error");
    dialog.setText("The content viewer encountered an error.");
    dialog.setInformativeText("What would you like to do?");
    dialog.addButton("Reload Page", QMessageBox::ActionRole);
    dialog.addButton("Close Cartridge", QMessageBox::ActionRole);
    dialog.addButton("Continue", QMessageBox::ActionRole);
    
    int result = dialog.exec();
    
    switch (result) {
        case 0: // Reload Page
            reloadPage();
            break;
        case 1: // Close Cartridge
            close();
            break;
        case 2: // Continue
            // Attempt to continue (may not work if process crashed)
            break;
    }
}
----

**Recovery Options:**
* **Reload Page:** Reloads the page content (creates new renderer process)
* **Close Cartridge:** Closes the Reader View Window
* **Continue:** Attempts to continue (may not work if process crashed)

=== Performance Configuration

==== Memory Management

**Memory Usage:**
* Each `QWebEngineView` instance uses approximately 50-100MB RAM
* Monitor memory usage for multiple simultaneous views
* Implement view lifecycle management (destroy unused views)
* Set memory warnings if system memory is low

**View Lifecycle:**
* Create views on-demand (lazy loading)
* Destroy views when cartridge is closed
* Reuse views when possible (but maintain isolation for embedded apps)

**Memory Monitoring:**
* Track memory usage per view
* Display warning if total memory usage exceeds threshold (e.g., 500MB)
* Offer to close other cartridges to free memory

==== Cache Configuration

**HTTP Cache:**
* **Content Rendering:** 50MB disk cache
* **Creator Tool:** 100MB disk cache
* **Embedded Apps:** No cache (prevents service workers)

**Cache Location:**
* Platform-specific cache directories:
  * Windows: `%LOCALAPPDATA%\SmartBook\cache\`
  * macOS: `~/Library/Caches/SmartBook/`
  * Linux: `~/.cache/SmartBook/`

**Cache Cleanup:**
* Clear cache on application exit (optional, user preference)
* Clear cache on cartridge deletion (if cartridge-specific cache)
* Manual cache clear option in settings

=== HTML/CSS Standards Support

==== HTML5 Support

**Supported Features:**
* HTML5 semantic elements (`<article>`, `<section>`, `<nav>`, `<header>`, `<footer>`, etc.)
* HTML5 form elements and validation
* HTML5 media elements (`<audio>`, `<video>`)
* HTML5 canvas and SVG
* HTML5 Web Components (Custom Elements, Shadow DOM)

**Standards Compliance:**
* Chromium's HTML5 implementation (typically 95%+ compliance)
* Specific compliance level depends on Chromium version
* Document exact Chromium version and compliance level in application

==== CSS3 Support

**Supported Features:**
* CSS3 selectors (attribute selectors, pseudo-classes, pseudo-elements)
* CSS3 properties (flexbox, grid, transforms, animations, transitions)
* CSS3 media queries
* CSS3 variables (custom properties)
* CSS3 modules (as implemented by Chromium)

**Standards Compliance:**
* Chromium's CSS3 implementation (typically 90%+ compliance)
* Specific compliance level depends on Chromium version
* Document exact Chromium version and compliance level in application

=== JavaScript Engine Configuration

==== V8 Engine Features

**Supported ECMAScript Versions:**
* ECMAScript 2022 (ES13) - Full support
* ECMAScript 2021 (ES12) - Full support
* ECMAScript 2020 (ES11) - Full support
* ECMAScript 2019 (ES10) - Full support
* ECMAScript 2018 (ES9) - Full support
* ECMAScript 2017 (ES8) - Full support
* ECMAScript 2016 (ES7) - Full support
* ECMAScript 2015 (ES6) - Full support

**JavaScript Features:**
* Classes, modules (ES6 modules), async/await
* Promises, generators, iterators
* Arrow functions, template literals
* Destructuring, spread operator
* Proxy, Reflect, Symbol
* WebAssembly support

**V8 Engine Version Detection:**
* Document exact V8 version at build time
* V8 version determined by Chromium version
* Can be queried at runtime (if needed): Check Qt WebEngine version information

=== Additional Settings

==== Accessibility Settings

**Screen Reader Support:**
* Enable accessibility features: `QWebEngineSettings::ScreenReaderEnabled`
* Ensure ARIA labels are properly rendered
* Support keyboard navigation

**High Contrast Mode:**
* Respect system high contrast settings
* Apply high contrast CSS when system setting is enabled

==== Developer Tools (Optional)

**Developer Console:**
* Disable in production builds: `QWebEngineSettings::DeveloperExtrasEnabled = false`
* Enable in debug builds for development
* Access via: Right-click context menu or keyboard shortcut (if enabled)

**Remote Debugging:**
* Disable in production (security risk)
* Enable only in development builds
* Use `QWebEngineProfile::setHttpUserAgent()` for identification

== SQLite Configuration Implementation

This section specifies the detailed SQLite configuration for the Reader and Creator Tool applications, including version requirements, WAL mode configuration, database optimization settings, connection management, and maintenance operations.

=== SQLite Version Requirements

**Minimum Version:** SQLite 3.51

**Rationale:**
* SQLite 3.51 (released 2024) includes important bug fixes and performance improvements
* WAL mode improvements and checkpoint optimizations
* Better handling of large databases
* Enhanced foreign key constraint support
* Improved query optimizer

**Version Detection:**

[source,cpp]
----
void LocalDBManager::checkSQLiteVersion() {
    QSqlDatabase db = QSqlDatabase::database();
    QVariant versionVar = db.driver()->property("SQLiteVersion");
    QString sqliteVersion = versionVar.toString();
    
    qInfo() << "SQLite version:" << sqliteVersion;
    
    // Parse version string (format: "3.51.0" or similar)
    QStringList parts = sqliteVersion.split(".");
    if (parts.size() >= 2) {
        int major = parts[0].toInt();
        int minor = parts[1].toInt();
        
        if (major < 3 || (major == 3 && minor < 51)) {
            qCritical() << "SQLite version" << sqliteVersion 
                        << "is below minimum required version 3.51";
            // Display error dialog to user
            QMessageBox::critical(nullptr, "SQLite Version Error",
                QString("SQLite version %1 is below minimum required version 3.51.\n"
                       "Please update SQLite or contact support.").arg(sqliteVersion));
        }
    }
}
----

**Version Documentation:**
* Log SQLite version at application startup
* Include version in About dialog (optional)
* Document version in application logs
* Store version information for debugging

=== WAL Mode Configuration

==== WAL Mode Overview

**Write-Ahead Logging (WAL) Benefits:**
* Better concurrency (readers don't block writers, writers don't block readers)
* Improved performance for mixed read/write workloads
* Reduced lock contention
* Better for multi-threaded applications
* Faster checkpoint operations

**WAL Mode Trade-offs:**
* Slightly larger database files (WAL file exists alongside database)
* Requires checkpointing to maintain WAL file size
* WAL file must be present for database to function (both files needed)

==== WAL Mode Implementation

**Enable WAL Mode for Local Database:**

[source,cpp]
----
void LocalDBManager::enableWALMode() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Check current journal mode
    if (query.exec("PRAGMA journal_mode")) {
        if (query.next()) {
            QString mode = query.value(0).toString().toUpper();
            if (mode != "WAL") {
                // Enable WAL mode
                if (query.exec("PRAGMA journal_mode=WAL")) {
                    qInfo() << "WAL mode enabled for local database";
                } else {
                    qWarning() << "Failed to enable WAL mode:" << query.lastError();
                }
            } else {
                qInfo() << "Database already in WAL mode";
            }
        }
    }
}
----

**Enable WAL Mode for Cartridge Files:**

[source,cpp]
----
void CartridgeDBConnector::enableWALMode() {
    QSqlDatabase db = database();
    if (!isWritable()) {
        qInfo() << "Cartridge is read-only, skipping WAL mode enable";
        return;
    }
    
    QSqlQuery query(db);
    if (query.exec("PRAGMA journal_mode=WAL")) {
        qInfo() << "WAL mode enabled for cartridge";
    } else {
        qWarning() << "Failed to enable WAL mode:" << query.lastError();
    }
}
----

**WAL Checkpoint Configuration:**

[source,cpp]
----
void LocalDBManager::configureWALCheckpoint() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Set WAL autocheckpoint threshold (1000 pages = ~4MB with 4KB pages)
    if (!query.exec("PRAGMA wal_autocheckpoint=1000")) {
        qWarning() << "Failed to set WAL autocheckpoint:" << query.lastError();
    }
    
    qInfo() << "WAL autocheckpoint configured: 1000 pages";
}
----

**WAL File Size Monitoring and Manual Checkpoint:**

[source,cpp]
----
qint64 LocalDBManager::getWALFileSize() {
    QString dbPath = QSqlDatabase::database().databaseName();
    QString walPath = dbPath + "-wal";
    QFileInfo walFile(walPath);
    if (walFile.exists()) {
        return walFile.size();
    }
    return 0;
}

void LocalDBManager::checkWALSize() {
    qint64 walSize = getWALFileSize();
    const qint64 maxWALSize = 10 * 1024 * 1024; // 10MB
    
    if (walSize > maxWALSize) {
        qInfo() << "WAL file size:" << walSize << "bytes, performing checkpoint";
        performWALCheckpoint();
    }
}

void LocalDBManager::performWALCheckpoint() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Perform checkpoint (truncates WAL file)
    if (query.exec("PRAGMA wal_checkpoint(TRUNCATE)")) {
        qInfo() << "WAL checkpoint completed";
    } else {
        qWarning() << "WAL checkpoint failed:" << query.lastError();
    }
}
----

**WAL Checkpoint Strategy:**
* Automatic checkpoint: When WAL file exceeds 10MB or 1000 pages written
* Manual checkpoint: After bulk operations, before backups
* Periodic checkpoint: During idle time (optional)

=== Database Optimization Configuration

==== Page Size Configuration

**Page Size: 4096 bytes (4KB)**

**Rationale:**
* 4KB matches modern OS page size (optimal for memory mapping)
* Good balance between performance and memory usage
* Standard size for most SQLite databases
* Optimal for cache efficiency

**Implementation:**

[source,cpp]
----
void LocalDBManager::createDatabase() {
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", "LocalDB");
    db.setDatabaseName(localDatabasePath());
    
    if (!db.open()) {
        qCritical() << "Failed to open local database";
        return;
    }
    
    QSqlQuery query(db);
    
    // Set page size (must be done before creating tables, only for new databases)
    if (!query.exec("PRAGMA page_size=4096")) {
        qWarning() << "Failed to set page size:" << query.lastError();
    }
    
    // Verify page size was set
    if (query.exec("PRAGMA page_size")) {
        if (query.next()) {
            int pageSize = query.value(0).toInt();
            qInfo() << "Database page size:" << pageSize << "bytes";
        }
    }
    
    // Create schema...
}
----

**Note:** Page size can only be set for new databases. Existing databases retain their original page size. To change page size of existing database, use `VACUUM INTO` (SQLite 3.27+).

==== Cache Size Configuration

**Cache Size Settings:**

[source,cpp]
----
void LocalDBManager::configureCache() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Set cache size to 2000 pages (8MB with 4KB pages)
    // Negative value = pages (absolute value in KB)
    if (!query.exec("PRAGMA cache_size=-2000")) {
        qWarning() << "Failed to set cache size:" << query.lastError();
    }
    
    // Verify cache size
    if (query.exec("PRAGMA cache_size")) {
        if (query.next()) {
            int cacheSize = query.value(0).toInt();
            qInfo() << "Cache size configured:" << cacheSize << "pages";
        }
    }
}

void CartridgeDBConnector::configureCache() {
    QSqlDatabase db = database();
    QSqlQuery query(db);
    
    // Set cache size to 1000 pages (4MB with 4KB pages)
    if (!query.exec("PRAGMA cache_size=-1000")) {
        qWarning() << "Failed to set cache size:" << query.lastError();
    }
}
----

**Cache Size Rationale:**
* Local database: 2000 pages (8MB) - larger cache for frequently accessed manifest data
* Cartridge files: 1000 pages (4MB) - smaller cache per cartridge, multiple cartridges may be open simultaneously
* Cache size is per-connection, so each cartridge connection has its own cache

==== Synchronous Configuration

**Synchronous Mode: NORMAL (for WAL mode)**

**Implementation:**

[source,cpp]
----
void LocalDBManager::configureSynchronous() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Set synchronous mode to NORMAL (safe with WAL mode)
    if (!query.exec("PRAGMA synchronous=NORMAL")) {
        qWarning() << "Failed to set synchronous mode:" << query.lastError();
    }
    
    // Verify synchronous mode
    if (query.exec("PRAGMA synchronous")) {
        if (query.next()) {
            int syncMode = query.value(0).toInt();
            // 1 = NORMAL, 2 = FULL, 0 = OFF
            qInfo() << "Synchronous mode:" << syncMode << "(1=NORMAL)";
        }
    }
}
----

**Synchronous Mode Options:**
* `OFF` (0) - Fastest but unsafe (data loss risk on power failure) - **NOT RECOMMENDED**
* `NORMAL` (1) - Safe with WAL mode, good performance - **RECOMMENDED**
* `FULL` (2) - Safest but slower - **NOT NEEDED with WAL mode**

**Rationale:**
* WAL mode provides durability guarantees even with NORMAL synchronous mode
* NORMAL mode with WAL is safe and performant
* FULL mode adds unnecessary overhead with WAL (double-write protection not needed)

==== Foreign Key Constraints

**Enable Foreign Key Enforcement:**

[source,cpp]
----
void LocalDBManager::enableForeignKeys() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Enable foreign key constraints (must be done per connection)
    if (!query.exec("PRAGMA foreign_keys=ON")) {
        qWarning() << "Failed to enable foreign keys:" << query.lastError();
        return;
    }
    
    // Verify foreign keys are enabled
    if (query.exec("PRAGMA foreign_keys")) {
        if (query.next()) {
            int enabled = query.value(0).toInt();
            if (enabled != 1) {
                qWarning() << "Foreign keys not enabled (expected 1, got" << enabled << ")";
            } else {
                qInfo() << "Foreign key constraints enabled";
            }
        }
    }
}
----

**Foreign Key Benefits:**
* Data integrity enforcement at database level
* Prevents orphaned records
* Automatic referential integrity checks
* Cascading deletes/updates (if defined in schema)

**Note:** Foreign keys must be enabled per connection (not persistent in database). Must be enabled after each connection is opened.

==== Query Optimizer Configuration

**Enable Query Optimizer Statistics:**

[source,cpp]
----
void LocalDBManager::updateStatistics() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    qInfo() << "Updating query optimizer statistics";
    
    // Update query optimizer statistics
    if (!query.exec("ANALYZE")) {
        qWarning() << "Failed to update statistics:" << query.lastError();
    } else {
        qInfo() << "Statistics updated successfully";
    }
}
----

**When to Run ANALYZE:**
* After bulk imports (cartridge imports)
* After significant data changes (bulk deletes, updates)
* Periodically (e.g., weekly) for local database
* After schema changes that affect indexes
* After VACUUM operations

**Automatic Statistics Update:**
* Run ANALYZE after import operations complete
* Run ANALYZE after bulk deletes (e.g., cartridge deletion)
* Consider running during idle time (background task)

=== Connection Configuration

==== Connection Setup

**Local Database Connection:**

[source,cpp]
----
void LocalDBManager::initializeConnection() {
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", "LocalDB");
    db.setDatabaseName(localDatabasePath());
    
    // Set connection options (optional)
    // db.setConnectOptions("QSQLITE_ENABLE_REGEXP"); // Enable regexp function
    
    // Set busy timeout (5 seconds)
    db.setConnectOptions("QSQLITE_BUSY_TIMEOUT=5000");
    
    if (!db.open()) {
        qCritical() << "Failed to open local database:" << db.lastError();
        return;
    }
    
    // Configure database settings
    enableWALMode();
    configureCache();
    configureSynchronous();
    enableForeignKeys();
    configureWALCheckpoint();
    
    qInfo() << "Local database connection established and configured";
}
----

**Cartridge Database Connection:**

[source,cpp]
----
void CartridgeDBConnector::openCartridge(const QString& filePath) {
    QString connectionName = QString("Cartridge_%1").arg(QUuid::createUuid().toString());
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", connectionName);
    db.setDatabaseName(filePath);
    
    // Set connection timeout (30 seconds) and busy timeout (5 seconds)
    db.setConnectOptions("QSQLITE_BUSY_TIMEOUT=5000");
    
    if (!db.open()) {
        qCritical() << "Failed to open cartridge:" << db.lastError();
        return;
    }
    
    // Configure database settings (if writable)
    if (isWritable()) {
        enableWALMode();
        configureCache();
        configureSynchronous();
        enableForeignKeys();
    }
    
    qInfo() << "Cartridge database connection established:" << filePath;
}
----

**Connection Cleanup:**

[source,cpp]
----
void CartridgeDBConnector::closeConnection() {
    QSqlDatabase db = database();
    QString connectionName = db.connectionName();
    
    db.close();
    QSqlDatabase::removeDatabase(connectionName);
    
    qInfo() << "Cartridge database connection closed";
}
----

=== Transaction Management

==== Transaction Usage

**Form Data Save Transaction:**

[source,cpp]
----
bool CartridgeDBConnector::saveFormData(const QString& formKey, const QJsonObject& data) {
    QSqlDatabase db = database();
    
    if (!db.transaction()) {
        qWarning() << "Failed to start transaction";
        return false;
    }
    
    try {
        QSqlQuery query(db);
        
        // Delete existing data
        query.prepare("DELETE FROM User_Data WHERE form_key = ?");
        query.addBindValue(formKey);
        if (!query.exec()) {
            throw std::runtime_error("Failed to delete existing data");
        }
        
        // Insert new data
        query.prepare("INSERT INTO User_Data (form_key, serialized_data, timestamp) VALUES (?, ?, ?)");
        query.addBindValue(formKey);
        query.addBindValue(QJsonDocument(data).toJson());
        query.addBindValue(QDateTime::currentDateTime().toSecsSinceEpoch());
        if (!query.exec()) {
            throw std::runtime_error("Failed to insert data");
        }
        
        if (!db.commit()) {
            throw std::runtime_error("Failed to commit transaction");
        }
        
        return true;
    } catch (const std::exception& e) {
        db.rollback();
        qWarning() << "Transaction rolled back:" << e.what();
        return false;
    }
}
----

**Atomic Cartridge Deletion:**

[source,cpp]
----
bool LocalDBManager::deleteCartridge(const QString& cartridgeGuid) {
    QSqlDatabase db = QSqlDatabase::database();
    
    if (!db.transaction()) {
        qWarning() << "Failed to start transaction";
        return false;
    }
    
    try {
        QSqlQuery query(db);
        
        // Delete from manifest
        query.prepare("DELETE FROM Local_Library_Manifest WHERE cartridge_guid = ?");
        query.addBindValue(cartridgeGuid);
        if (!query.exec()) {
            throw std::runtime_error("Failed to delete from manifest");
        }
        
        // Delete from trust registry
        query.prepare("DELETE FROM Local_Trust_Registry WHERE cartridge_guid = ?");
        query.addBindValue(cartridgeGuid);
        if (!query.exec()) {
            throw std::runtime_error("Failed to delete from trust registry");
        }
        
        if (!db.commit()) {
            throw std::runtime_error("Failed to commit transaction");
        }
        
        return true;
    } catch (const std::exception& e) {
        db.rollback();
        qWarning() << "Transaction rolled back:" << e.what();
        return false;
    }
}
----

==== Savepoint Usage

**Form Version Migration with Savepoints:**

[source,cpp]
----
bool CartridgeDBConnector::migrateFormData(const QString& formKey, int fromVersion, int toVersion) {
    QSqlDatabase db = database();
    
    if (!db.transaction()) {
        return false;
    }
    
    QSqlQuery query(db);
    
    // Create savepoint
    if (!query.exec("SAVEPOINT migration")) {
        db.rollback();
        return false;
    }
    
    try {
        // Step 1: Load existing data
        // Step 2: Transform data
        // Step 3: Validate transformed data
        // If any step fails, rollback to savepoint
        
        // Release savepoint (all steps succeeded)
        if (!query.exec("RELEASE SAVEPOINT migration")) {
            throw std::runtime_error("Failed to release savepoint");
        }
        
        if (!db.commit()) {
            throw std::runtime_error("Failed to commit transaction");
        }
        
        return true;
    } catch (const std::exception& e) {
        // Rollback to savepoint (partial rollback)
        query.exec("ROLLBACK TO SAVEPOINT migration");
        db.rollback();
        qWarning() << "Migration rolled back:" << e.what();
        return false;
    }
}
----

=== Database Maintenance

==== Vacuum Operation

**Vacuum Implementation:**

[source,cpp]
----
void LocalDBManager::vacuumDatabase() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    qInfo() << "Starting VACUUM operation";
    
    // VACUUM requires exclusive lock
    if (query.exec("VACUUM")) {
        qInfo() << "VACUUM completed successfully";
        
        // Update statistics after vacuum
        query.exec("ANALYZE");
    } else {
        qWarning() << "VACUUM failed:" << query.lastError();
    }
}
----

**When to Run VACUUM:**
* After large deletions (e.g., bulk cartridge deletion)
* Periodically (e.g., monthly) for local database
* When database file size is significantly larger than data size
* User-initiated optimization (Settings → Optimize Database)

**VACUUM Considerations:**
* Requires exclusive database lock (blocks all other operations)
* Can take time for large databases (show progress if possible)
* Reduces database file size by removing free space
* Rebuilds entire database file (creates new file, replaces old)

==== Integrity Checks

**Quick Integrity Check:**

[source,cpp]
----
bool CartridgeDBConnector::quickIntegrityCheck() {
    QSqlDatabase db = database();
    QSqlQuery query(db);
    
    if (query.exec("PRAGMA quick_check")) {
        if (query.next()) {
            QString result = query.value(0).toString();
            if (result == "ok") {
                qInfo() << "Quick integrity check passed";
                return true;
            } else {
                qWarning() << "Quick check failed:" << result;
                return false;
            }
        }
    }
    return false;
}
----

**Full Integrity Check:**

[source,cpp]
----
bool CartridgeDBConnector::fullIntegrityCheck() {
    QSqlDatabase db = database();
    QSqlQuery query(db);
    
    qInfo() << "Starting full integrity check";
    
    if (query.exec("PRAGMA integrity_check")) {
        QStringList errors;
        while (query.next()) {
            QString result = query.value(0).toString();
            if (result == "ok") {
                qInfo() << "Full integrity check passed";
                return true;
            } else {
                errors << result;
            }
        }
        
        if (!errors.isEmpty()) {
            qCritical() << "Integrity check failed:" << errors;
            return false;
        }
    }
    return false;
}
----

**Integrity Check Strategy:**
* Quick check on cartridge open (fast, catches most issues)
* Full check when corruption is suspected (slower, comprehensive)
* Log all integrity check results
* Display error to user if corruption detected

==== Backup and Restore

**Backup Implementation:**

[source,cpp]
----
bool LocalDBManager::backupDatabase(const QString& backupPath) {
    QSqlDatabase db = QSqlDatabase::database();
    QString dbPath = db.databaseName();
    
    QSqlQuery query(db);
    
    // Use VACUUM INTO (SQLite 3.27+) for backup
    QString vacuumSql = QString("VACUUM INTO '%1'").arg(backupPath);
    if (query.exec(vacuumSql)) {
        qInfo() << "Database backed up to:" << backupPath;
        return true;
    } else {
        qWarning() << "Backup failed:" << query.lastError();
        return false;
    }
}
----

**Backup Strategy:**
* Create backup before schema migrations
* Create backup before major operations (bulk deletes, etc.)
* Store backups in backup directory: `{app_data}/backups/`
* Backup naming: `local_reader.sqlite.backup.YYYY-MM-DD_HH-MM-SS`
* Retain backups for 7 days
* Automatic cleanup of old backups

**Backup Directory:**
* Windows: `%APPDATA%\SmartBook\backups\`
* macOS: `~/Library/Application Support/SmartBook/backups/`
* Linux: `~/.local/share/SmartBook/backups/`

== Platform-Specific Considerations Implementation

This section specifies platform-specific implementation details for the Reader and Creator Tool applications, including platform detection, UI framework configuration, secure storage, certificate validation, universal binary support, and file associations.

=== Platform Detection and Configuration

**Platform Detection:**

[source,cpp]
----
#include <QtGlobal>

enum class Platform {
    Windows,
    macOS,
    Linux
};

Platform getPlatform() {
#ifdef Q_OS_WIN
    return Platform::Windows;
#elif defined(Q_OS_MACOS)
    return Platform::macOS;
#elif defined(Q_OS_LINUX)
    return Platform::Linux;
#else
    #error "Unsupported platform"
#endif
}
----

**Architecture Detection:**

[source,cpp]
----
#include <QtGlobal>

enum class Architecture {
    X86_64,
    ARM64,
    Unknown
};

Architecture getArchitecture() {
#if defined(Q_PROCESSOR_X86_64)
    return Architecture::X86_64;
#elif defined(Q_PROCESSOR_ARM_64) || defined(Q_PROCESSOR_ARM_V8)
    return Architecture::ARM64;
#else
    return Architecture::Unknown;
#endif
}
----

=== Qt Fusion Widget Set Configuration

**Apply Fusion Style:**

[source,cpp]
----
#include <QApplication>
#include <QStyleFactory>

void applyFusionStyle(QApplication* app) {
    // Set Fusion style for uniform appearance
    app->setStyle(QStyleFactory::create("Fusion"));
    
    // Optional: Apply custom palette for theming
    QPalette palette;
    palette.setColor(QPalette::Window, QColor(240, 240, 240));
    palette.setColor(QPalette::WindowText, QColor(0, 0, 0));
    palette.setColor(QPalette::Base, QColor(255, 255, 255));
    palette.setColor(QPalette::AlternateBase, QColor(245, 245, 245));
    palette.setColor(QPalette::ToolTipBase, QColor(255, 255, 220));
    palette.setColor(QPalette::ToolTipText, QColor(0, 0, 0));
    palette.setColor(QPalette::Text, QColor(0, 0, 0));
    palette.setColor(QPalette::Button, QColor(240, 240, 240));
    palette.setColor(QPalette::ButtonText, QColor(0, 0, 0));
    palette.setColor(QPalette::BrightText, QColor(255, 0, 0));
    palette.setColor(QPalette::Link, QColor(0, 0, 255));
    palette.setColor(QPalette::Highlight, QColor(0, 120, 215));
    palette.setColor(QPalette::HighlightedText, QColor(255, 255, 255));
    
    app->setPalette(palette);
}
----

**Application Initialization:**

[source,cpp]
----
int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    
    // Apply Fusion style for uniform appearance
    applyFusionStyle(&app);
    
    // Platform-specific initialization
    Platform platform = getPlatform();
    switch (platform) {
        case Platform::macOS:
            // macOS-specific initialization
            // Set up menu bar integration
            break;
        case Platform::Windows:
            // Windows-specific initialization
            // Set up system tray (if needed)
            break;
        case Platform::Linux:
            // Linux-specific initialization
            // Set up system tray (if needed)
            break;
    }
    
    // Continue application startup...
}
----

=== Platform-Specific Data Directories

**Directory Path Resolution:**

[source,cpp]
----
#include <QStandardPaths>
#include <QDir>

QString getApplicationDataDirectory() {
    QString basePath = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    
    // Ensure directory exists
    QDir dir(basePath);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    
    return basePath;
}

QString getCacheDirectory() {
    QString cachePath = QStandardPaths::writableLocation(QStandardPaths::CacheLocation);
    QDir dir(cachePath);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    return cachePath;
}

QString getLogDirectory() {
    QString logPath = getApplicationDataDirectory() + "/logs";
    QDir dir(logPath);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    return logPath;
}

QString getBackupDirectory() {
    QString backupPath = getApplicationDataDirectory() + "/backups";
    QDir dir(backupPath);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    return backupPath;
}
----

**Platform-Specific Paths:**
* **Windows:**
  * Application Data: `%APPDATA%\SmartBook\` (via `QStandardPaths::AppDataLocation`)
  * Cache: `%LOCALAPPDATA%\SmartBook\cache\` (via `QStandardPaths::CacheLocation`)
* **macOS:**
  * Application Data: `~/Library/Application Support/SmartBook/` (via `QStandardPaths::AppDataLocation`)
  * Cache: `~/Library/Caches/SmartBook/` (via `QStandardPaths::CacheLocation`)
* **Linux:**
  * Application Data: `~/.local/share/SmartBook/` (via `QStandardPaths::AppDataLocation`)
  * Cache: `~/.cache/SmartBook/` (via `QStandardPaths::CacheLocation`)

=== Platform-Specific Secure Storage

**Secure Storage Interface:**

[source,cpp]
----
class SecureStorage {
public:
    static bool storeCredential(const QString& key, const QString& value);
    static QString retrieveCredential(const QString& key);
    static bool deleteCredential(const QString& key);
    
private:
    static QString getServiceName() { return "SmartBook"; }
};
----

**Windows Implementation (Credential Manager):**

[source,cpp]
----
#ifdef Q_OS_WIN
#include <windows.h>
#include <wincred.h>

bool SecureStorage::storeCredential(const QString& key, const QString& value) {
    QString targetName = getServiceName() + "/" + key;
    QByteArray targetNameUtf8 = targetName.toUtf8();
    QByteArray valueUtf8 = value.toUtf8();
    
    CREDENTIAL cred = {0};
    cred.Type = CRED_TYPE_GENERIC;
    cred.TargetName = const_cast<LPSTR>(targetNameUtf8.data());
    cred.CredentialBlobSize = valueUtf8.size();
    cred.CredentialBlob = reinterpret_cast<LPBYTE>(const_cast<char*>(valueUtf8.data()));
    cred.Persist = CRED_PERSIST_LOCAL_MACHINE;
    cred.UserName = const_cast<LPSTR>("SmartBook");
    
    return CredWrite(&cred, 0) == TRUE;
}

QString SecureStorage::retrieveCredential(const QString& key) {
    QString targetName = getServiceName() + "/" + key;
    QByteArray targetNameUtf8 = targetName.toUtf8();
    
    PCREDENTIAL cred = nullptr;
    if (CredRead(targetNameUtf8.data(), CRED_TYPE_GENERIC, 0, &cred)) {
        QByteArray blob(reinterpret_cast<const char*>(cred->CredentialBlob), 
                       cred->CredentialBlobSize);
        CredFree(cred);
        return QString::fromUtf8(blob);
    }
    return QString();
}
#endif
----

**macOS Implementation (Keychain):**

[source,cpp]
----
#ifdef Q_OS_MACOS
#include <Security/Security.h>

bool SecureStorage::storeCredential(const QString& key, const QString& value) {
    QString service = getServiceName();
    QByteArray serviceUtf8 = service.toUtf8();
    QByteArray keyUtf8 = key.toUtf8();
    QByteArray valueUtf8 = value.toUtf8();
    
    OSStatus status = SecKeychainAddGenericPassword(
        nullptr,
        serviceUtf8.length(),
        serviceUtf8.data(),
        keyUtf8.length(),
        keyUtf8.data(),
        valueUtf8.length(),
        valueUtf8.data(),
        nullptr
    );
    
    // If item exists, update it
    if (status == errSecDuplicateItem) {
        SecKeychainItemRef itemRef = nullptr;
        status = SecKeychainFindGenericPassword(
            nullptr,
            serviceUtf8.length(),
            serviceUtf8.data(),
            keyUtf8.length(),
            keyUtf8.data(),
            nullptr,
            nullptr,
            &itemRef
        );
        
        if (status == errSecSuccess) {
            status = SecKeychainItemModifyContent(
                itemRef,
                nullptr,
                valueUtf8.length(),
                valueUtf8.data()
            );
            CFRelease(itemRef);
        }
    }
    
    return status == errSecSuccess;
}

QString SecureStorage::retrieveCredential(const QString& key) {
    QString service = getServiceName();
    QByteArray serviceUtf8 = service.toUtf8();
    QByteArray keyUtf8 = key.toUtf8();
    
    void* passwordData = nullptr;
    UInt32 passwordLength = 0;
    
    OSStatus status = SecKeychainFindGenericPassword(
        nullptr,
        serviceUtf8.length(),
        serviceUtf8.data(),
        keyUtf8.length(),
        keyUtf8.data(),
        &passwordLength,
        &passwordData,
        nullptr
    );
    
    if (status == errSecSuccess) {
        QByteArray password(reinterpret_cast<const char*>(passwordData), passwordLength);
        SecKeychainItemFreeContent(nullptr, passwordData);
        return QString::fromUtf8(password);
    }
    
    return QString();
}
#endif
----

**Linux Implementation (libsecret):**

[source,cpp]
----
#ifdef Q_OS_LINUX
#include <libsecret/secret.h>

bool SecureStorage::storeCredential(const QString& key, const QString& value) {
    const SecretSchema* schema = secret_schema_new(
        "com.smartbook.credential",
        SECRET_SCHEMA_DONT_MATCH_NAME,
        "key", SECRET_SCHEMA_ATTRIBUTE_STRING,
        nullptr
    );
    
    GError* error = nullptr;
    secret_password_store_sync(
        schema,
        SECRET_COLLECTION_DEFAULT,
        getServiceName().toUtf8().constData(),
        value.toUtf8().constData(),
        nullptr,
        &error,
        "key", key.toUtf8().constData(),
        nullptr
    );
    
    secret_schema_unref(schema);
    
    if (error) {
        g_error_free(error);
        return false;
    }
    
    return true;
}

QString SecureStorage::retrieveCredential(const QString& key) {
    const SecretSchema* schema = secret_schema_new(
        "com.smartbook.credential",
        SECRET_SCHEMA_DONT_MATCH_NAME,
        "key", SECRET_SCHEMA_ATTRIBUTE_STRING,
        nullptr
    );
    
    GError* error = nullptr;
    gchar* password = secret_password_lookup_sync(
        schema,
        nullptr,
        &error,
        "key", key.toUtf8().constData(),
        nullptr
    );
    
    secret_schema_unref(schema);
    
    if (error) {
        g_error_free(error);
        return QString();
    }
    
    if (password) {
        QString result = QString::fromUtf8(password);
        secret_password_free(password);
        return result;
    }
    
    return QString();
}
#endif
----

=== Certificate Validation

**Platform-Specific Certificate Store:**

[source,cpp]
----
#include <QSslSocket>
#include <QSslCertificate>

void configureCertificateValidation() {
    Platform platform = getPlatform();
    
    switch (platform) {
        case Platform::Windows:
            // Windows uses Windows Certificate Store automatically via Qt
            // QSslSocket::defaultCaCertificates() uses system store
            break;
        case Platform::macOS:
            // macOS uses Keychain automatically via Qt
            // QSslSocket::defaultCaCertificates() uses system store
            break;
        case Platform::Linux:
            // Linux: Use system CA bundle
            QStringList possiblePaths = {
                "/etc/ssl/certs/ca-certificates.crt",
                "/etc/pki/tls/certs/ca-bundle.crt",
                "/usr/share/ca-certificates/ca-certificates.crt"
            };
            
            QString caBundlePath;
            for (const QString& path : possiblePaths) {
                if (QFile::exists(path)) {
                    caBundlePath = path;
                    break;
                }
            }
            
            if (!caBundlePath.isEmpty()) {
                QList<QSslCertificate> certs = QSslCertificate::fromPath(caBundlePath);
                QSslSocket::setDefaultCaCertificates(certs);
            }
            break;
    }
}
----

=== Universal Binary Support (macOS)

**CMake Configuration for Universal Binary:**

[source,cmake]
----
if(APPLE)
    # Check if building for universal binary
    if(CMAKE_OSX_ARCHITECTURES)
        # Already specified
    else
        # Set to build universal binary (ARM64 + X86_64)
        set(CMAKE_OSX_ARCHITECTURES "arm64;x86_64")
    endif()
    
    # Set minimum macOS version
    set(CMAKE_OSX_DEPLOYMENT_TARGET "26.1")
    
    # Code signing (if certificate available)
    set(CMAKE_OSX_CODE_SIGN_IDENTITY "Developer ID Application")
endif()
----

**Verify Universal Binary:**

[source,bash]
----
# Verify architectures in binary
lipo -info build/SmartBook.app/Contents/MacOS/SmartBook

# Expected output:
# Architectures in the fat file: build/SmartBook.app/Contents/MacOS/SmartBook are: arm64 x86_64
----

=== File Associations

**Windows File Association (Registry):**

[source,reg]
----
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\.sqlite]
@="SmartBook.Cartridge"

[HKEY_CURRENT_USER\Software\Classes\SmartBook.Cartridge]
@="SmartBook Cartridge"

[HKEY_CURRENT_USER\Software\Classes\SmartBook.Cartridge\DefaultIcon]
@="C:\\Program Files\\SmartBook\\SmartBook.exe,0"

[HKEY_CURRENT_USER\Software\Classes\SmartBook.Cartridge\shell\open\command]
@="\"C:\\Program Files\\SmartBook\\SmartBook.exe\" \"%1\""
----

**macOS File Association (Info.plist):**

[source,xml]
----
<key>CFBundleDocumentTypes</key>
<array>
    <dict>
        <key>CFBundleTypeExtensions</key>
        <array>
            <string>sqlite</string>
        </array>
        <key>CFBundleTypeIconFile</key>
        <string>CartridgeIcon</string>
        <key>CFBundleTypeName</key>
        <string>SmartBook Cartridge</string>
        <key>CFBundleTypeRole</key>
        <string>Viewer</string>
        <key>LSItemContentTypes</key>
        <array>
            <string>com.smartbook.cartridge</string>
        </array>
    </dict>
</array>
----

**Linux File Association (.desktop file):**

[source,ini]
----
[Desktop Entry]
Version=1.0
Type=Application
Name=SmartBook
Comment=SmartBook Cartridge Reader
Exec=/usr/bin/smartbook %f
Icon=smartbook
MimeType=application/x-sqlite3;application/vnd.sqlite3;
Terminal=false
Categories=Office;Viewer;
----

=== URL Scheme Handling

**macOS URL Scheme (Info.plist):**

[source,xml]
----
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLName</key>
        <string>com.smartbook.cartridge</string>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>smartbook</string>
        </array>
    </dict>
</array>
----

**Windows URL Scheme (Registry):**

[source,reg]
----
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\smartbook]
@="URL:SmartBook Protocol"
"URL Protocol"=""

[HKEY_CURRENT_USER\Software\Classes\smartbook\shell\open\command]
@="\"C:\\Program Files\\SmartBook\\SmartBook.exe\" \"%1\""
----

**Linux URL Scheme (.desktop file):**

[source,ini]
----
[Desktop Entry]
...
MimeType=application/x-sqlite3;application/vnd.sqlite3;x-scheme-handler/smartbook;
----

== Series and Edition Grouping Implementation

This section defines how series, edition, and custom collection grouping is implemented in the Reader application.

=== Series and Edition Metadata

**Metadata Fields:**
* `series_name` (TEXT, nullable): Series identifier (e.g., "Lensman Series")
* `edition_name` (TEXT, nullable): Edition identifier (e.g., "Classic Traveller")
* `series_order` (INTEGER, nullable): Position within series for ordering

**Metadata Usage:**
* Metadata fields are set by Creator Tool during cartridge creation/editing
* Metadata fields are read by Library Manager for auto-grouping
* Metadata fields are stored in cartridge database (portable across systems)

=== Auto-Grouping by Series

**Series Detection:**
. On library load or cartridge import, query `Local_Library_Manifest`:
   `SELECT DISTINCT series_name FROM Local_Library_Manifest WHERE series_name IS NOT NULL`
. For each unique `series_name`, create or update `Local_Cartridge_Groups` entry:
   * `group_type` = "series"
   * `group_name` = series_name
   * Auto-created groups are read-only (managed by system)

**Series Membership:**
. Query cartridges for series:
   `SELECT cartridge_guid FROM Local_Library_Manifest WHERE series_name = ?`
. For each cartridge, ensure membership in series group:
   * Query `Local_Cartridge_Group_Members` for existing membership
   * If not exists, insert membership record
   * Use `series_order` from metadata for `display_order` (if available)

**Series Display:**
. Load series groups: `SELECT * FROM Local_Cartridge_Groups WHERE group_type = 'series' ORDER BY group_name`
. For selected series, load members:
   ```
   SELECT m.*, g.display_order 
   FROM Local_Library_Manifest m
   JOIN Local_Cartridge_Group_Members gm ON m.cartridge_guid = gm.cartridge_guid
   JOIN Local_Cartridge_Groups g ON gm.group_id = g.group_id
   WHERE g.group_name = ? AND g.group_type = 'series'
   ORDER BY COALESCE(g.display_order, m.series_order, m.title)
   ```

=== Auto-Grouping by Edition

**Edition Detection:**
. On library load or cartridge import, query `Local_Library_Manifest`:
   `SELECT DISTINCT edition_name FROM Local_Library_Manifest WHERE edition_name IS NOT NULL`
. For each unique `edition_name`, create or update `Local_Cartridge_Groups` entry:
   * `group_type` = "edition"
   * `group_name` = edition_name
   * Auto-created groups are read-only (managed by system)

**Edition Membership:**
. Query cartridges for edition:
   `SELECT cartridge_guid FROM Local_Library_Manifest WHERE edition_name = ?`
. For each cartridge, ensure membership in edition group:
   * Query `Local_Cartridge_Group_Members` for existing membership
   * If not exists, insert membership record
   * `display_order` is NULL (alphabetical by title)

**Edition Display:**
. Load edition groups: `SELECT * FROM Local_Cartridge_Groups WHERE group_type = 'edition' ORDER BY group_name`
. For selected edition, load members:
   ```
   SELECT m.*
   FROM Local_Library_Manifest m
   JOIN Local_Cartridge_Group_Members gm ON m.cartridge_guid = gm.cartridge_guid
   JOIN Local_Cartridge_Groups g ON gm.group_id = g.group_id
   WHERE g.group_name = ? AND g.group_type = 'edition'
   ORDER BY m.title
   ```

=== Custom Collections

**Create Custom Collection:**
. User provides collection name (and optional description)
. Insert into `Local_Cartridge_Groups`:
   ```sql
   INSERT INTO Local_Cartridge_Groups (group_name, group_type, created_timestamp, last_modified_timestamp, description)
   VALUES (?, 'custom_collection', ?, ?, ?)
   ```
. Return `group_id` for adding members

**Add Cartridge to Collection:**
. User selects cartridge(s) and target collection
. For each cartridge, insert into `Local_Cartridge_Group_Members`:
   ```sql
   INSERT INTO Local_Cartridge_Group_Members (group_id, cartridge_guid, added_timestamp, display_order)
   VALUES (?, ?, ?, ?)
   ```
. Update collection's `last_modified_timestamp`

**Remove Cartridge from Collection:**
. User selects cartridge and collection
. Delete membership:
   ```sql
   DELETE FROM Local_Cartridge_Group_Members 
   WHERE group_id = ? AND cartridge_guid = ?
   ```
. Update collection's `last_modified_timestamp`

**Rename Custom Collection:**
. User provides new name
. Update `Local_Cartridge_Groups`:
   ```sql
   UPDATE Local_Cartridge_Groups 
   SET group_name = ?, last_modified_timestamp = ?
   WHERE group_id = ? AND group_type = 'custom_collection'
   ```

**Delete Custom Collection:**
. User confirms deletion
. Delete all memberships:
   ```sql
   DELETE FROM Local_Cartridge_Group_Members WHERE group_id = ?
   ```
. Delete collection:
   ```sql
   DELETE FROM Local_Cartridge_Groups WHERE group_id = ? AND group_type = 'custom_collection'
   ```

**Display Custom Collection:**
. Load collection: `SELECT * FROM Local_Cartridge_Groups WHERE group_id = ?`
. Load members:
   ```
   SELECT m.*, gm.display_order
   FROM Local_Library_Manifest m
   JOIN Local_Cartridge_Group_Members gm ON m.cartridge_guid = gm.cartridge_guid
   WHERE gm.group_id = ?
   ORDER BY COALESCE(gm.display_order, m.title)
   ```

=== Grouping UI Implementation

**Browse by Series View:**
. Display list of all series (from `Local_Cartridge_Groups` where `group_type = 'series'`)
. User selects series
. Display all cartridges in series (ordered by `series_order` or title)
. User can open cartridges from series view

**Browse by Edition View:**
. Display list of all editions (from `Local_Cartridge_Groups` where `group_type = 'edition'`)
. User selects edition
. Display all cartridges in edition (ordered alphabetically by title)
. User can open cartridges from edition view

**Custom Collections View:**
. Display list of all custom collections (from `Local_Cartridge_Groups` where `group_type = 'custom_collection'`)
. User can:
   * Create new collection
   * Select collection to view members
   * Add/remove cartridges from collection
   * Rename/delete collection

**Grouping Filters:**
. Add filter dropdown or sidebar to Library Manager
. Filter options:
   * "All Cartridges" (default)
   * "By Series" (shows series list)
   * "By Edition" (shows edition list)
   * "Custom Collections" (shows user collections)
. When filter selected, update library view to show filtered content

**Search by Series/Edition:**
. Add search field with autocomplete
. Search suggestions include:
   * Series names
   * Edition names
   * Custom collection names
. On selection, filter library view to matching group

=== Grouping Maintenance

**On Cartridge Import:**
. After importing cartridge, check metadata for `series_name` and `edition_name`
. If `series_name` present:
   * Ensure series group exists in `Local_Cartridge_Groups`
   * Add cartridge to series group membership
. If `edition_name` present:
   * Ensure edition group exists in `Local_Cartridge_Groups`
   * Add cartridge to edition group membership

**On Cartridge Deletion:**
. Before deleting cartridge, remove from all group memberships:
   ```sql
   DELETE FROM Local_Cartridge_Group_Members WHERE cartridge_guid = ?
   ```
. Delete cartridge from library
. If series/edition group becomes empty, optionally remove group (or keep for future imports)

**On Cartridge Metadata Update:**
. If `series_name` or `edition_name` changes:
   * Remove from old group memberships
   * Add to new group memberships (if applicable)
. If `series_order` changes:
   * Update `display_order` in group membership (for series groups)

=== Performance Considerations

**Grouping Queries:**
* All grouping queries use `Local_Library_Manifest` (fast, indexed)
* Group memberships are cached or queried efficiently
* Grouping operations complete within < 500ms (NFR-3.1)

**Indexes:**
* Index on `Local_Cartridge_Groups.group_type` for filtering
* Index on `Local_Cartridge_Group_Members(group_id, cartridge_guid)` for membership queries
* Index on `Local_Library_Manifest.series_name` and `edition_name` for auto-grouping

== Help System and User Manual Implementation

This section specifies the implementation of the help system and user manual for both Reader and Creator Tool applications.

=== Help System Architecture

**Help Content Structure:**
* **Source Format:** AsciiDoc source documents (single source of truth)
* **HTML Output:** Generated HTML for integrated help viewer
* **PDF Output:** Generated PDF for distribution and offline reading
* **Content Location:** `{install_dir}/help/` or `{install_dir}/Resources/help/` (macOS)

**Help Content Organization:**
```
help/
├── index.html (or index.adoc)
├── getting-started/
│   ├── installation.html
│   ├── first-launch.html
│   └── basic-operations.html
├── reader/
│   ├── library-management.html
│   ├── reading.html
│   ├── navigation.html
│   ├── search.html
│   ├── forms.html
│   └── embedded-apps.html
├── creator/
│   ├── content-authoring.html
│   ├── form-building.html
│   ├── cartridge-creation.html
│   ├── signing.html
│   └── export.html
├── security/
│   ├── trust-levels.html
│   ├── consent-dialogs.html
│   └── certificates.html
├── reference/
│   ├── keyboard-shortcuts.html
│   └── faq.html
└── troubleshooting/
    └── common-issues.html
```

=== Help System Access Implementation

**Help Menu Integration:**

[source,cpp]
----
void MainWindow::setupHelpMenu() {
    QMenu* helpMenu = menuBar()->addMenu(tr("&Help"));
    
    // User Manual (HTML)
    QAction* userManualAction = helpMenu->addAction(tr("&User Manual"));
    userManualAction->setShortcut(QKeySequence::HelpContents); // F1
    connect(userManualAction, &QAction::triggered, this, &MainWindow::showUserManual);
    
    // User Manual (PDF)
    QAction* pdfManualAction = helpMenu->addAction(tr("User Manual (&PDF)"));
    connect(pdfManualAction, &QAction::triggered, this, &MainWindow::openPDFManual);
    
    helpMenu->addSeparator();
    
    // About
    QAction* aboutAction = helpMenu->addAction(tr("&About SmartBook"));
    connect(aboutAction, &QAction::triggered, this, &MainWindow::showAboutDialog);
}

void MainWindow::showUserManual() {
    QString helpPath = getHelpDirectory() + "/index.html";
    QUrl helpUrl = QUrl::fromLocalFile(helpPath);
    
    // Open in integrated help viewer or external browser
    if (useIntegratedHelpViewer()) {
        showHelpViewer(helpUrl);
    } else {
        QDesktopServices::openUrl(helpUrl);
    }
}

void MainWindow::openPDFManual() {
    QString pdfPath = getPDFManualPath();
    if (QFile::exists(pdfPath)) {
        QDesktopServices::openUrl(QUrl::fromLocalFile(pdfPath));
    } else {
        QMessageBox::warning(this, tr("Manual Not Found"),
            tr("User manual PDF not found at:\n%1").arg(pdfPath));
    }
}
----

**Platform-Specific Help Paths:**

[source,cpp]
----
QString MainWindow::getHelpDirectory() {
    QString basePath = QCoreApplication::applicationDirPath();
    
#ifdef Q_OS_MACOS
    // macOS: Resources directory in app bundle
    basePath += "/../Resources/help";
#else
    // Windows/Linux: help directory in install directory
    basePath += "/help";
#endif
    
    return QDir(basePath).canonicalPath();
}

QString MainWindow::getPDFManualPath() {
    QString basePath = QCoreApplication::applicationDirPath();
    
#ifdef Q_OS_MACOS
    // macOS: Resources directory
    basePath += "/../Resources/SmartBook_User_Manual.pdf";
#elif defined(Q_OS_WIN)
    // Windows: docs directory
    basePath += "/docs/SmartBook_User_Manual.pdf";
#else
    // Linux: share/doc directory or install directory
    basePath = "/usr/share/doc/smartbook/SmartBook_User_Manual.pdf";
    if (!QFile::exists(basePath)) {
        basePath = QCoreApplication::applicationDirPath() + "/SmartBook_User_Manual.pdf";
    }
#endif
    
    return basePath;
}
----

=== Integrated Help Viewer

**Help Viewer Window:**

[source,cpp]
----
class HelpViewer : public QMainWindow {
    Q_OBJECT
public:
    explicit HelpViewer(QWidget* parent = nullptr);
    void loadHelpContent(const QUrl& url);
    
private slots:
    void onLinkClicked(const QUrl& url);
    void goBack();
    void goForward();
    void goHome();
    void searchHelp();
    
private:
    QWebEngineView* m_webView;
    QToolBar* m_toolbar;
    QLineEdit* m_addressBar;
    QAction* m_backAction;
    QAction* m_forwardAction;
    QAction* m_homeAction;
    QAction* m_searchAction;
    QUrl m_homeUrl;
};

HelpViewer::HelpViewer(QWidget* parent)
    : QMainWindow(parent) {
    setWindowTitle(tr("SmartBook Help"));
    setMinimumSize(800, 600);
    
    // Create WebEngine view for HTML help content
    m_webView = new QWebEngineView(this);
    setCentralWidget(m_webView);
    
    // Setup toolbar
    m_toolbar = addToolBar(tr("Navigation"));
    m_backAction = m_toolbar->addAction(tr("Back"));
    m_forwardAction = m_toolbar->addAction(tr("Forward"));
    m_homeAction = m_toolbar->addAction(tr("Home"));
    m_toolbar->addSeparator();
    m_searchAction = m_toolbar->addAction(tr("Search"));
    
    // Address bar
    m_addressBar = new QLineEdit(this);
    m_toolbar->addWidget(m_addressBar);
    
    // Connect signals
    connect(m_webView, &QWebEngineView::urlChanged, 
            this, [this](const QUrl& url) {
        m_addressBar->setText(url.toString());
    });
    
    connect(m_webView, &QWebEngineView::linkClicked,
            this, &HelpViewer::onLinkClicked);
    
    connect(m_backAction, &QAction::triggered, this, &HelpViewer::goBack);
    connect(m_forwardAction, &QAction::triggered, this, &HelpViewer::goForward);
    connect(m_homeAction, &QAction::triggered, this, &HelpViewer::goHome);
    connect(m_searchAction, &QAction::triggered, this, &HelpViewer::searchHelp);
    
    // Load home page
    m_homeUrl = QUrl::fromLocalFile(getHelpDirectory() + "/index.html");
    loadHelpContent(m_homeUrl);
}

void HelpViewer::loadHelpContent(const QUrl& url) {
    m_webView->setUrl(url);
}

void HelpViewer::onLinkClicked(const QUrl& url) {
    // Only allow local file URLs (help content)
    if (url.scheme() == "file" || url.scheme().isEmpty()) {
        loadHelpContent(url);
    } else {
        // External links - open in system browser
        QDesktopServices::openUrl(url);
    }
}
----

=== PDF Manual Generation

**PDF Generation Process:**

[source,bash]
----
# Generate PDF from AsciiDoc source
asciidoctor-pdf -a pdf-style=theme.yml \
                -a pdf-fontsdir=fonts \
                -a imagesdir=images \
                -o SmartBook_User_Manual.pdf \
                user-manual.adoc
----

**PDF Generation Requirements:**
* **Source:** Single AsciiDoc source document (`user-manual.adoc`)
* **Tool:** Asciidoctor PDF or similar
* **Output:** `SmartBook_User_Manual.pdf`
* **Format:** PDF/A compliant for long-term archival
* **Features:** Table of contents, bookmarks, cross-references, images, code syntax highlighting

**PDF Distribution:**
* **Windows:** Include in installer, install to `{install_dir}/docs/`
* **macOS:** Include in app bundle at `SmartBook.app/Contents/Resources/` or DMG
* **Linux:** Include in package, install to `/usr/share/doc/smartbook/` or user-accessible location

=== Context-Sensitive Help

**Dialog Help Integration:**

[source,cpp]
----
void SettingsDialog::setupHelp() {
    // Add help button to dialog
    QPushButton* helpButton = new QPushButton(tr("&Help"), this);
    connect(helpButton, &QPushButton::clicked, this, &SettingsDialog::showHelp);
    
    // Add to button box
    QDialogButtonBox* buttonBox = findChild<QDialogButtonBox*>();
    if (buttonBox) {
        buttonBox->addButton(helpButton, QDialogButtonBox::HelpRole);
    }
}

void SettingsDialog::showHelp() {
    // Open help to relevant section
    QUrl helpUrl = QUrl::fromLocalFile(getHelpDirectory() + "/reference/settings.html");
    QDesktopServices::openUrl(helpUrl);
}
----

**Tooltip Help:**

[source,cpp]
----
void MainWindow::setupTooltips() {
    // Add tooltips to UI elements
    m_libraryView->setToolTip(tr("Double-click a cartridge to open it. Right-click for options."));
    m_searchButton->setToolTip(tr("Search cartridges in your library (Ctrl+F)"));
    m_importButton->setToolTip(tr("Import cartridge files into your library"));
}
----

**"What's This?" Mode:**

[source,cpp]
----
void MainWindow::enableWhatsThis() {
    // Enable Qt's "What's This?" mode
    QAction* whatsThisAction = QWhatsThis::createAction(this);
    whatsThisAction->setShortcut(QKeySequence(Qt::SHIFT | Qt::Key_F1));
    helpMenu()->addAction(whatsThisAction);
    
    // Add "What's This?" help text to widgets
    m_libraryView->setWhatsThis(tr(
        "The library view displays all cartridges in your library. "
        "Double-click to open, right-click for options, or use the toolbar buttons."
    ));
}
----

=== Platform-Specific Help Integration

**macOS Help Book:**

[source,xml]
----
<!-- Info.plist entries for macOS Help Book -->
<key>CFBundleHelpBookFolder</key>
<string>SmartBook.help</string>
<key>CFBundleHelpBookName</key>
<string>com.smartbook.help</string>
----

**Help Book Structure (macOS):**
```
SmartBook.app/Contents/Resources/
└── SmartBook.help/
    ├── Contents/
    │   ├── Info.plist
    │   └── Resources/
    │       ├── index.html
    │       ├── getting-started/
    │       ├── reader/
    │       └── ...
    └── SmartBook_User_Manual.pdf
```

**Windows Help Integration:**

[source,cpp]
----
#ifdef Q_OS_WIN
void MainWindow::setupWindowsHelp() {
    // Register help file with Windows Help system
    QString helpFile = getHelpDirectory() + "/index.html";
    
    // Windows Help integration (optional)
    // Can use HTML Help Workshop (.chm) or simple HTML help
}
#endif
----

**Linux Desktop Integration:**

[source,ini]
----
# .desktop file entry for help
[Desktop Entry]
...
X-GNOME-Help=smartbook
----

=== User Manual Content Specification

**Manual Structure:**

. **Introduction**
   * What is SmartBook
   * System requirements
   * Installation instructions

. **Getting Started**
   * First launch
   * Library setup
   * Importing cartridges
   * Opening cartridges

. **Reader Application**
   * Library management
   * Reading cartridges
   * Navigation (TOC, bookmarks, history)
   * Search (document and in-page)
   * Forms (filling, saving, loading)
   * Embedded applications
   * Theming
   * Printing

. **Creator Tool**
   * Content authoring
   * Page and chapter management
   * Form building
   * Embedded app creation
   * Cartridge creation and signing
   * Export and publishing
   * Templates and imports

. **Security and Trust**
   * Trust levels explained
   * Consent dialogs
   * Certificate management
   * Trust revocation

. **Reference**
   * Keyboard shortcuts
   * File formats
   * Troubleshooting
   * FAQ

. **Appendix**
   * Glossary
   * Technical specifications
   * Support information

=== Help Content Maintenance

**Version Control:**
* Help content version SHALL match application version
* Help content SHALL be versioned independently for updates
* Version information SHALL be displayed in help viewer or About dialog

**Update Mechanism:**
* Help content MAY be updated via application update
* Help content MAY be updated independently (separate download)
* Users SHALL be notified if help content is outdated

**Build Integration:**
* Help content generation SHALL be part of build process
* PDF generation SHALL be automated
* Help content SHALL be included in distribution packages

== Error Handling and Logging Implementation

=== Error Handling Strategy

The Reader and Creator Tool applications implement comprehensive error handling with graceful degradation, user-friendly error messages, and detailed logging for debugging.

=== Reader Application Error Handling

==== Cartridge File Errors

**Detection:**
* File existence check before opening
* SQLite format validation
* File corruption detection via SQLite integrity checks

**Handling:**
* **File Not Found:** Display user-friendly error: "Cartridge file not found. It may have been moved or deleted."
* **Invalid SQLite Format:** Display error: "Invalid cartridge format. The file may be corrupted."
* **File Corruption:** Attempt SQLite recovery if possible. If recovery fails, display error with option to delete corrupted cartridge.
* **Permission Errors:** Display error: "Cannot access cartridge file. Check file permissions."

**Logging:** All cartridge file errors SHALL be logged with ERROR level, including file path and error details.

==== Database Connection Errors

**Detection:**
* Connection attempt with timeout
* SQLite error code checking
* Disk space monitoring

**Handling:**
* **Database Locked:** Retry with exponential backoff (max 3 retries). If still locked, display error: "Cartridge is in use by another application."
* **Disk Full:** Display error: "Insufficient disk space. Free up space and try again."
* **SQLite Corruption:** Attempt recovery using `PRAGMA integrity_check`. If recovery fails, display error with option to delete corrupted cartridge.
* **Connection Timeout:** Display error: "Database connection timeout. The cartridge may be on a slow storage device."

**Logging:** Database errors SHALL be logged with ERROR level, including SQLite error codes and operation context.

==== Signature Verification Errors

**Error Types and Messages:**

[cols="2, 4", options="headers"]
|===
^.^| Error Type ^.^| User Message

| Invalid Signature | "Cartridge signature is invalid. The content may have been tampered with or corrupted."
| Expired Certificate | "The cartridge's security certificate has expired. Contact the publisher for an updated version."
| Untrusted CA | "The cartridge's security certificate is not from a trusted authority. Proceed with caution."
| Corrupted Security Data | "Cartridge security data is corrupted. The file may be damaged."
| Hash Mismatch (Tampering) | "Cartridge integrity check failed. The file has been modified since it was signed. For security reasons, execution is blocked."
|===

**Handling:**
* All signature verification errors SHALL block app execution
* Hash mismatch errors SHALL be logged as security events with WARN level
* User SHALL be informed of the specific error type

==== File System Errors

**Handling:**
* **Disk Full:** Check available disk space before operations. Display error: "Insufficient disk space. Free up [X] MB and try again."
* **Permission Denied:** Display error: "Permission denied. Check file permissions or run as administrator."
* **Path Too Long:** Display error: "File path is too long. Move the cartridge to a shorter path."
* **Invalid Characters:** Sanitize paths and display warning if sanitization occurred.

**Logging:** File system errors SHALL be logged with WARN or ERROR level depending on severity.

==== Manifest Update Error Handling

**Two Types of Manifests:**

. **Embedded App Manifest** (`Embedded_App_Manifest` JSON in `Embedded_Apps.manifest_json`):
   * Created/updated when cartridge is created/updated by Creator Tool
   * Stored within the cartridge database itself
   * Failures typically occur during cartridge creation/update in Creator Tool
   * Error handling: See "Creator Tool Manifest Error Handling" below

. **Local Library Manifest** (`Local_Library_Manifest` table in Reader's local database):
   * Updated when cartridge is added/updated/removed from library
   * Stored in Reader's local database (`local_reader.sqlite`)
   * Failures typically due to disk space or file permissions
   * Error handling: See "Local Library Manifest Error Handling" below

===== Creator Tool: Embedded App Manifest Error Handling

**When Manifest is Created/Updated:**
* During cartridge creation: When author defines embedded applications
* During cartridge update: When author modifies embedded application definitions
* Manifest is validated before being saved to cartridge database

**Error Scenarios:**
* JSON validation errors (invalid manifest structure)
* Schema validation errors (missing required fields, invalid field types)
* Database write errors (cartridge file locked, disk full, permissions)

**Error Dialog Requirements:**
* Display error dialog to user with:
  * **Operation:** "Create Embedded App Manifest" or "Update Embedded App Manifest"
  * **App ID:** The `app_id` of the embedded app being created/updated
  * **Error Type:** Brief description (e.g., "JSON Validation Error", "Database Write Error")
  * **Error Message:** Detailed error message from validation or database operation
  * **Context:** Cartridge file path, operation timestamp
  * **Suggested Resolution:** Actionable steps to resolve the error
* Error dialog should include "Copy Error Details" button to copy full error information for debugging
* Error dialog should allow user to retry operation or cancel

**Error Dialog Example:**
```
Title: "Failed to Save Embedded App Manifest"

Message:
"Failed to save embedded app manifest for app 'character_generator'.

Error: JSON validation failed - missing required field 'appId'

Cartridge: /path/to/cartridge.sqlite
Operation: Create Embedded App Manifest
Timestamp: 2025-12-14 10:30:45

Suggested Resolution:
. Check that all required fields are present in the manifest
. Verify JSON structure is valid
. Try saving again

[Copy Error Details] [Retry] [Cancel]"
```

**Logging:**
* Log error with ERROR level
* Include: operation type, app ID, error message, cartridge path, stack trace (if available)

===== Reader: Local Library Manifest Error Handling

**When Manifest is Updated:**
* **On Cartridge Import:** When new cartridge is added to library
* **On Cartridge Open:** When cartridge is opened and content hash (H2) is recalculated
* **On Cartridge Update:** When cartridge file is detected at new path or with changed content
* **On Cartridge Deletion:** When cartridge is removed from library

**Error Scenarios:**
* **Disk Space Exhaustion:** Insufficient disk space to write to local database
* **File Permissions:** No write permission to local database file or directory
* **Database Locked:** Local database file is locked by another process
* **Database Corruption:** Local database file is corrupted or inaccessible
* **Path Issues:** Invalid or inaccessible local database path

**Error Handling Strategy:**
* If manifest update fails, operation SHALL continue (non-blocking for cartridge operations)
* Error SHALL be logged with ERROR level
* User SHALL be notified via error dialog with sufficient information to reproduce and debug

**Error Dialog Requirements:**
* Display error dialog to user with:
  * **Operation:** "Update Library Manifest" or "Add to Library" or "Remove from Library"
  * **Cartridge:** Cartridge title and `cartridge_guid`
  * **Error Type:** Brief description (e.g., "Disk Space Error", "Permission Denied")
  * **Error Message:** Detailed error message from database operation
  * **Context:** Local database path, operation timestamp, SQLite error code (if applicable)
  * **Suggested Resolution:** Actionable steps to resolve the error
* Error dialog should include "Copy Error Details" button to copy full error information for debugging
* Error dialog should allow user to retry operation or dismiss

**Error Dialog Example:**
```
Title: "Failed to Update Library Manifest"

Message:
"Failed to update library manifest for cartridge 'D&D 5e Player's Handbook'.

Error: SQLite error 14 - unable to open database file
SQLite Error Code: 14
Error Message: disk I/O error

Cartridge GUID: abc-123-def-456
Local Database: /Users/username/.local/share/SmartBook/local_reader.sqlite
Operation: Update Library Manifest
Timestamp: 2025-12-14 10:30:45

Suggested Resolution:
. Check that you have write permissions to the database directory
. Verify sufficient disk space is available
. Ensure the database file is not locked by another process
. Try restarting the application

[Copy Error Details] [Retry] [Dismiss]"
```

**Logging:**
* Log error with ERROR level
* Include: operation type, cartridge_guid, error message, local database path, SQLite error code, stack trace (if available)

**Retry Strategy:**
* Update SHALL be retried on next application launch
* If retry fails, error dialog is displayed again
* User can manually retry via error dialog

**Non-Blocking Behavior:**
* Cartridge operations (open, import, delete) continue even if manifest update fails
* Library view may show stale data until manifest update succeeds
* User is informed that library data may be out of date

== Cartridge Import Process Specification

This section defines the complete workflow for importing cartridges into the Reader's library.

=== Import Mechanisms

**Drag-and-Drop:**
* Users can drag one or more `.sqlite` cartridge files from the file system
* Drop target: Library Manager window (main library view area)
* Visual feedback: Highlight drop target area when files are dragged over window
* Accepts: Files with `.sqlite` extension
* Rejects: Non-cartridge files (display error message)

**File Picker Dialog:**
* Accessible via: Menu item (File → Import) or toolbar button
* Native file picker dialog (Qt's `QFileDialog`)
* Supports: Single file selection or multiple file selection
* File filter: "SmartBook Cartridges (*.sqlite)" or "All Files (*)"
* Default directory: Last used import directory or user's Documents folder

=== Import Storage Location

**Default Library Directory:**
* **Windows:** `%USERPROFILE%\Documents\SmartBook\Library\`
* **macOS:** `~/Documents/SmartBook/Library/`
* **Linux:** `~/Documents/SmartBook/Library/`

**Rationale:**
* Follows operating system standards for user document storage
* Documents folder is typically backed up by OS backup systems
* Accessible to users for manual file management
* Consistent across platforms

**User Configuration:**
* Users can configure custom library directory via application settings
* Setting stored in application configuration (QSettings)
* Library directory preference persists across sessions
* If custom directory doesn't exist, create it on first import
* If custom directory becomes inaccessible, fall back to default directory and notify user

**Storage Strategy:**
* Imported cartridges are copied to the library directory
* Original file location is not required after import
* Cartridge files are stored with their original filename (or renamed if duplicate filename exists)
* Library directory structure is flat (no subdirectories) for simplicity

=== Import Progress Dialog

**Dialog Components:**
* **Title:** "Importing Cartridges"
* **Progress Bar:** Shows overall progress (percentage or file count)
* **Status Text:** Current operation description (e.g., "Copying file: example.sqlite")
* **File List:** List of files being imported with status indicators (pending, in progress, completed, failed)
* **Cancel Button:** Abort import operation (closes dialog, stops import)

**Progress Updates:**
* Update progress bar as each file is processed
* Update status text for each operation step
* Update file list with status indicators
* Enable cancel button throughout import process

**Cancel Behavior:**
* If user clicks Cancel:
  * Stop processing remaining files
  * Complete current file operation (if in progress)
  * Roll back any partial imports (delete copied files, remove manifest entries)
  * Close progress dialog
  * Display summary: "Import cancelled. X of Y files imported."

=== Duplicate Detection and Handling

**Duplicate Detection:**
* After copying file to library directory, open cartridge and read `cartridge_guid` from `Metadata` table
* Query `Local_Library_Manifest` table for existing entry with same `cartridge_guid`
* If duplicate found, display confirmation dialog before proceeding

**Duplicate Confirmation Dialog:**
* **Title:** "Duplicate Cartridge Detected"
* **Message:** "A cartridge with the same identifier already exists in your library."
* **Existing Cartridge Information:**
  * Title
  * Author
  * File path
  * File size
  * Last modified date
* **New Cartridge Information:**
  * Title
  * Author
  * File path (source)
  * File size
  * Last modified date
* **Options:**
  * **Replace:** Delete existing cartridge file, import new cartridge, update manifest entry
  * **Skip:** Abort import for this cartridge, continue with next file (if multiple)
  * **Keep Both:** Rename new file (add suffix like "_1", "_2") and import as separate entry
* **Checkbox (if multiple files):** "Apply this choice to all duplicates" - allows batch handling

**Replace Operation:**
* Delete existing cartridge file from library directory
* Copy new cartridge file to library directory
* Update manifest entry (new path, new hash, new metadata)
* Preserve trust registry entry (if exists) - user's trust decision remains
* Preserve user settings (if exists) - user preferences remain
* Preserve bookmarks and reading position (if exists) - user data remains

**Skip Operation:**
* Do not copy new cartridge file
* Do not update manifest
* Continue with next file in import batch
* Log skipped duplicate for user reference

**Keep Both Operation:**
* Generate unique filename: `{original_name}_{suffix}.sqlite` where suffix is incremented until unique
* Copy new cartridge file with new filename
* Create new manifest entry (different `local_path`, same `cartridge_guid`)
* Note: This creates two entries with same `cartridge_guid` but different paths
* User can manually delete one later if desired

=== Import Validation

**Validation Steps:**
. **File Format Validation:**
   * Verify file exists and is readable
   * Verify file has `.sqlite` extension (or is valid SQLite database)
   * Attempt to open as SQLite database
   * If fails: Display error "Invalid cartridge file format" and skip

. **Schema Validation:**
   * Verify `Metadata` table exists
   * Verify `cartridge_guid` column exists and contains valid UUID v4
   * Verify `schema_version` column exists
   * Verify required tables exist (`Content_Pages`, etc.)
   * If fails: Display error "Invalid cartridge structure" and skip

. **Version Compatibility:**
   * Read `schema_version` from `Metadata` table
   * Compare with Reader's supported format versions
   * If newer version: Display error "Cartridge requires newer Reader version" and skip
   * If older version: Proceed (migration handled during load)

. **Metadata Extraction:**
   * Read `title`, `author`, `publication_year` from `Metadata` table
   * Read `cover_image_path` and load cover image data
   * Verify required metadata fields are present
   * If fails: Display error "Missing required metadata" and skip

**Validation Error Handling:**
* Display error dialog for each validation failure
* Include: File name, error type, error details
* Allow user to continue with other files (if batch import)
* Log all validation errors

=== Import Workflow Algorithm

**Step 1: File Selection**
. User initiates import (drag-drop or file picker)
. Collect list of files to import
. Filter to only `.sqlite` files (warn about non-cartridge files)

**Step 2: Progress Dialog Display**
. Display import progress dialog
. Initialize progress bar to 0%
. Add all files to file list with "pending" status

**Step 3: Process Each File**
For each file in import list:

. **Update Status:** Set file status to "in progress" in progress dialog
. **Validate File:** Perform import validation (see "Import Validation" above)
. **If Validation Fails:**
   * Set file status to "failed" in progress dialog
   * Display error dialog
   * Continue with next file
. **If Validation Succeeds:**
   * **Check for Duplicate:**
     * Read `cartridge_guid` from cartridge
     * Query manifest for existing entry
     * If duplicate found:
       * Display duplicate confirmation dialog
       * Wait for user choice
       * If "Skip": Set status to "skipped", continue next file
       * If "Replace": Proceed with replace operation
       * If "Keep Both": Generate unique filename
   * **Copy File:**
     * Determine destination path (library directory + filename)
     * Copy file to library directory
     * Update progress: "Copying file..."
   * **Extract Metadata:**
     * Read metadata from cartridge
     * Load cover image data
     * Calculate content hash (H2)
     * Update progress: "Extracting metadata..."
   * **Create Manifest Entry:**
     * Insert/update entry in `Local_Library_Manifest` table
     * Update progress: "Updating library..."
   * **Set Status:** Set file status to "completed" in progress dialog

**Step 4: Completion**
. Update progress bar to 100%
. Close progress dialog (or show completion summary)
. Refresh library view to display imported cartridges
. Display success notification (optional): "Successfully imported X cartridges"

**Step 5: Error Summary (if any failures)**
. If any files failed validation or were skipped:
. Display summary dialog: "Import completed with X errors. Y files imported successfully, Z files skipped/failed."
. Provide option to view error log

=== Import Error Handling

**File Access Errors:**
* **File Not Found:** Display error "File not found. It may have been moved or deleted."
* **Permission Denied:** Display error "Permission denied. Check file permissions."
* **Disk Full:** Display error "Insufficient disk space. Free up space and try again."

**Database Errors:**
* **Invalid SQLite Format:** Display error "Invalid cartridge format. The file may be corrupted."
* **Database Locked:** Display error "Cartridge file is locked. Close other applications using this file."
* **Corruption:** Display error "Cartridge file is corrupted. Cannot import."

**Manifest Update Errors:**
* If manifest update fails during import:
  * File is copied but manifest entry not created
  * Display error dialog (see "Manifest Update Error Handling" section)
  * User can retry manifest update later
  * File remains in library directory but won't appear in library view until manifest is updated

**Logging:**
* Log all import operations with INFO level
* Log validation errors with WARN level
* Log file operation errors with ERROR level
* Include: file paths, cartridge_guid, error details, timestamps

== Database Migration Strategy

This section defines how database schema migrations are handled for both cartridge format versions and the Reader's local database schema.

=== Cartridge Format Version Migration

Cartridge format version is stored in the `Metadata.schema_version` field and indicates the Smartbook Format Specification version used when the cartridge was created.

==== Version Detection

**When Cartridge is Opened:**
. Reader reads `schema_version` from `Metadata` table
. Reader compares cartridge `schema_version` with current supported format version
. If versions match: Cartridge is loaded normally
. If versions don't match: Migration process is triggered

**Supported Versions:**
* **Phase 1:** Format version "1.0" is the initial and only supported version
* Future phases may introduce new format versions (e.g., "1.1", "2.0")
* Reader must support all format versions from Phase 1 forward (backward compatibility)

==== Migration Strategy

**Backward Compatibility:**
* Reader SHALL support reading cartridges from all previous format versions
* Reader SHALL NOT modify cartridge files during migration (cartridges are read-only from Reader perspective)
* Migration is performed in-memory during cartridge loading
* Original cartridge file remains unchanged

**Forward Compatibility:**
* Reader SHALL detect cartridges with newer format versions than it supports
* Reader SHALL display error message: "This cartridge requires a newer version of SmartBook Reader. Please update the application."
* Reader SHALL NOT attempt to load cartridges with unsupported newer format versions

**Migration Process:**
. **Detect Version:** Read `schema_version` from cartridge `Metadata` table
. **Check Compatibility:** Compare with Reader's supported format versions
. **If Older Version:**
   a. Determine migration path (e.g., 1.0 → 1.1 → 2.0)
   b. Apply migration transformations in-memory
   c. Load cartridge with migrated schema
   d. Log migration operation
. **If Same Version:** Load cartridge normally
. **If Newer Version:** Display error and refuse to load

==== Format Version Changes

**Breaking Changes (Require Version Increment):**
* Table schema changes (columns added/removed/renamed, data type changes)
* Table structure changes (new tables, removed tables)
* Required field additions
* Data format changes (JSON structure changes, encoding changes)

**Non-Breaking Changes (No Version Increment):**
* Optional field additions
* New optional tables
* Extended validation rules (more restrictive)
* Additional metadata fields

**Version Numbering:**
* Format: `MAJOR.MINOR` (e.g., "1.0", "1.1", "2.0")
* **MAJOR** increment: Breaking changes that require migration
* **MINOR** increment: Non-breaking changes, backward compatible

==== Migration Transformations

**Table Schema Migrations:**
* **Add Column:** Add new column with default value or NULL
* **Remove Column:** Drop column (data loss, but backward compatible for reading)
* **Rename Column:** Map old column name to new column name
* **Change Data Type:** Transform data type (e.g., TEXT to INTEGER with parsing)
* **Add Table:** Create new table structure in-memory
* **Remove Table:** Ignore table if not present in older version

**Data Transformations:**
* **JSON Structure Changes:** Transform JSON data to match new schema
* **Encoding Changes:** Convert text encoding if needed
* **Default Values:** Apply default values for new required fields

**Migration Rules:**
* Migration rules are defined in Reader code (not stored in cartridges)
* Each format version transition has specific migration code
* Migration code is tested and validated before release

==== Migration Error Handling

**Migration Failures:**
* If migration fails, Reader SHALL display error dialog:
  * "Failed to migrate cartridge from format version X to version Y"
  * Include cartridge title, format version, error details
  * Suggest updating cartridge with Creator Tool or contacting publisher
* Reader SHALL log migration errors with full context
* Reader SHALL NOT attempt to load cartridge if migration fails

**Partial Migration:**
* If migration partially succeeds (some data cannot be migrated):
  * Reader SHALL load cartridge with available data
  * Reader SHALL display warning: "Some data could not be migrated. Some features may not work correctly."
  * Reader SHALL log which data could not be migrated

**Migration Validation:**
* After migration, validate migrated schema against current format version
* Verify all required tables and columns are present
* Verify data integrity (foreign keys, constraints)
* If validation fails, treat as migration failure

=== Reader Local Database Schema Migration

The Reader's local database (`local_reader.sqlite`) contains the `Local_Library_Manifest`, `Local_Trust_Registry`, and `Local_User_Settings` tables. The schema may change between Reader application versions.

==== Version Tracking

**Database Version Table:**
* Reader SHALL maintain a `_schema_version` table in the local database
* Table structure:
  * `version` (TEXT, PRIMARY KEY): Schema version number (e.g., "1.0")
  * `applied_date` (INTEGER): Timestamp when migration was applied
* If `_schema_version` table doesn't exist, database is treated as version "1.0" (initial schema)

**Version Detection:**
* On application startup, Reader checks `_schema_version` table
* Compares stored version with current schema version
* If versions don't match, migration process is triggered

==== Migration Process

**Migration on Startup:**
. **Check Version:** Query `_schema_version` table for current database version
. **Compare Versions:** Compare with Reader's current schema version
. **If Versions Match:** Continue normal startup
. **If Versions Don't Match:**
   a. Determine migration path (e.g., 1.0 → 1.1 → 2.0)
   b. Create backup of local database
   c. Apply migration transformations sequentially
   d. Update `_schema_version` table
   e. Validate migrated database
   f. If validation fails, restore from backup and display error

**Migration Transformations:**
* **Add Column:** `ALTER TABLE table_name ADD COLUMN column_name TYPE DEFAULT value`
* **Remove Column:** SQLite doesn't support DROP COLUMN directly - use table recreation:
  * Create new table with desired schema
  * Copy data from old table (excluding removed columns)
  * Drop old table
  * Rename new table to original name
* **Rename Column:** Use table recreation (same as remove column)
* **Add Table:** `CREATE TABLE new_table (...)`
* **Remove Table:** `DROP TABLE old_table` (with data loss warning)
* **Modify Constraints:** Use table recreation

**Migration Backup:**
* Before migration, create backup: `local_reader.sqlite.backup`
* Backup is created in same directory as database
* If migration fails, restore from backup
* Backup is kept until next successful migration or user manually deletes it

==== Migration Error Handling

**Migration Failures:**
* If migration fails, Reader SHALL:
  * Restore database from backup
  * Display error dialog:
    * "Failed to migrate local database from version X to version Y"
    * Include error details, backup location
    * Suggest manual database repair or contacting support
  * Log migration error with full context
  * Continue with previous schema version (may limit functionality)

**Migration Validation:**
* After migration, validate database schema:
  * Verify all expected tables exist
  * Verify all expected columns exist
  * Verify data integrity (run PRAGMA integrity_check)
  * If validation fails, restore from backup

**User Notification:**
* If migration succeeds, optionally display brief notification: "Database updated successfully"
* If migration fails, display error dialog (see above)
* User can continue using application with previous schema (with limitations)

==== Schema Version History

**Version 1.0 (Phase 1 - Initial Schema):**
* `Local_Library_Manifest` table with columns: manifest_id, cartridge_guid, cartridge_hash, local_path, title, author, version, publication_year, cover_image_data, last_opened, location_status
* `Local_Trust_Registry` table with columns: registry_id, cartridge_guid, app_trust_policy, trust_timestamp, content_hash_at_trust
* `Local_User_Settings` table with columns: setting_id, cartridge_guid, setting_key, setting_value
* `Local_Bookmarks` table with columns: bookmark_id, cartridge_guid, bookmark_name, page_id, anchor_id, created_timestamp
* `Local_Reading_Position` table with columns: position_id, cartridge_guid, page_id, anchor_id, scroll_position, last_access_timestamp

**Future Versions:**
* Schema changes will be documented here as they are introduced
* Each version will include migration instructions

=== Handling Older Format Cartridges

**Detection:**
* Reader detects older format cartridges by reading `schema_version` from `Metadata` table
* Reader compares with supported format versions

**Loading Strategy:**
* **Supported Older Versions:** Apply migration transformations and load
* **Unsupported Older Versions:** Display error: "This cartridge format is no longer supported. Please contact the publisher for an updated version."
* **Newer Versions:** Display error: "This cartridge requires a newer version of SmartBook Reader. Please update the application."

**User Experience:**
* Migration is transparent to user (automatic, in-memory)
* User is only notified if migration fails or if cartridge format is unsupported
* Cartridge loading may be slightly slower if migration is required

**Creator Tool Compatibility:**
* Creator Tool can open and migrate older format cartridges
* Creator Tool can save cartridges in current format version
* Creator Tool can optionally save in older format versions (for compatibility testing)

==== WebEngine Errors

**Handling:**
* **JavaScript Errors:** Logged but do not crash application. Display error overlay in WebEngine view with option to reload.
* **WebEngine Crash:** Catch crash signals, log error, display recovery dialog: "The content viewer encountered an error. Reload page or close cartridge?"
* **Memory Exhaustion:** Monitor memory usage, display warning if approaching limits, offer to close other cartridges.

**Logging:** WebEngine errors SHALL be logged with ERROR level, including JavaScript console output where available.

=== Creator Tool Error Handling

==== Content Validation Errors

**Validation Points:**
* Before saving cartridge
* Before exporting cartridge
* On form definition creation
* On embedded app definition

**Error Messages:**
* **Invalid HTML:** "Invalid HTML detected at line [X]. Fix syntax errors before saving."
* **Malformed JSON:** "Form schema JSON is invalid: [error details]"
* **Missing Metadata:** "Required metadata field '[field]' is missing."
* **Invalid Form Definition:** "Form definition validation failed: [specific field errors]"
* **Resource Reference Error:** "Referenced resource '[path]' not found."

**Handling:**
* Validation errors SHALL prevent save/export operations
* Errors SHALL be displayed in validation panel with line numbers and details
* User SHALL be able to fix errors and retry

==== Cartridge Creation Errors

**Handling:**
* **Database Initialization Failure:** Roll back any partial changes, display error: "Failed to create cartridge database. Check disk space and permissions."
* **GUID Generation Failure:** Retry GUID generation. If persistent failure, display error: "Failed to generate unique identifier. Try again."
* **Schema Creation Error:** Roll back database, display error: "Failed to create cartridge structure. The cartridge file may be corrupted."

**Logging:** All creation errors SHALL be logged with ERROR level.

==== Signing Errors

**Error Messages:**
* **Invalid Certificate Format:** "Certificate file is invalid or corrupted. Select a valid certificate file."
* **Expired Certificate:** "Certificate has expired. Use a valid certificate or generate a new one."
* **Missing Private Key:** "Private key file not found. Provide the private key for signing."
* **Signing Failure:** "Failed to sign cartridge. Check certificate and key files."
* **Certificate Import Error:** "Failed to import certificate. Verify the certificate file format."

**Handling:**
* Signing errors SHALL prevent export
* User SHALL be able to correct certificate/key issues and retry
* Errors SHALL be displayed with actionable guidance

==== Export Errors

**Handling:**
* **File Write Error:** Display error: "Failed to write cartridge file. Check disk space and permissions."
* **Disk Full:** Display error: "Insufficient disk space. Free up [X] MB and try again."
* **Permission Error:** Display error: "Permission denied. Check file permissions or choose a different location."
* **Hash Calculation Failure:** Display error: "Failed to calculate content hash. Try exporting again."

**Recovery:**
* Export errors SHALL NOT affect the working cartridge
* User SHALL be able to retry export after resolving the issue
* Working cartridge state SHALL be preserved

=== Logging Implementation

==== Logging Framework

**Requirements:**
* Minimal logging: Only errors, warnings, and critical security events
* Automatic log rotation: When file reaches 10MB or daily (whichever comes first)
* Maximum retention: 5 rotated log files before deletion
* Platform-appropriate log locations

==== Log File Locations

[cols="2, 4", options="headers"]
|===
^.^| Platform ^.^| Log Directory

| Windows | `%APPDATA%\SmartBook\logs\`
| macOS | `~/Library/Application Support/SmartBook/logs/`
| Linux | `~/.local/share/SmartBook/logs/`
|===

**Log File Naming:**
* Current log: `smartbook.log`
* Rotated logs: `smartbook.log.1`, `smartbook.log.2`, etc. (oldest deleted first)

==== Log Format

**Format:** `[TIMESTAMP] [LEVEL] [COMPONENT] MESSAGE`

**Example:**
```
[2025-12-14 10:23:45.123] [ERROR] [CartridgeDBConnector] Failed to open cartridge: /path/to/file.sqlite - SQLite error: database disk image is malformed
[2025-12-14 10:23:46.456] [WARN] [SignatureVerifier] Hash mismatch detected for cartridge_guid: abc-123-def
[2025-12-14 10:23:47.789] [INFO] [LocalDBManager] Manifest updated: 5 entries
```

**Fields:**
* **TIMESTAMP:** ISO 8601 format with milliseconds
* **LEVEL:** ERROR, WARN, INFO (DEBUG excluded in production)
* **COMPONENT:** Component name (e.g., CartridgeDBConnector, SignatureVerifier)
* **MESSAGE:** Human-readable error message with context

==== Log Rotation Algorithm

**Trigger Conditions:**
. Log file size >= 10MB
. Daily rotation (at midnight or application start if >24 hours since last rotation)

**Rotation Process:**
. Close current log file
. Rename existing rotated files: `smartbook.log.N` → `smartbook.log.N+1`
. Rename current log: `smartbook.log` → `smartbook.log.1`
. Delete `smartbook.log.6` if it exists (keep only 5 rotated files)
. Create new `smartbook.log` file
. Continue logging to new file

**Implementation Notes:**
* Rotation SHALL be atomic (no log entries lost)
* Rotation SHALL occur automatically without user intervention
* Rotation SHALL be logged (one INFO entry per rotation)

==== Log Levels

**ERROR:** Critical errors that prevent operation or indicate security issues
* Database failures
* File system errors
* Signature verification failures
* Security violations (path traversal, tampering)

**WARN:** Non-critical issues that may affect functionality
* Hash mismatches (tampering detection)
* Manifest update failures
* Resource not found (non-critical)
* Performance warnings

**INFO:** Important operational events
* Application startup/shutdown
* Cartridge import/export
* Log rotation
* Trust decisions

**DEBUG:** Detailed debugging information (excluded from production logs unless explicitly enabled)

==== Error Context Logging

When logging errors, the following context SHALL be included:

* Error code (if applicable)
* Component name
* Operation being performed
* Relevant identifiers (cartridge_guid, app_id, form_id, etc.)
* File paths (sanitized to avoid sensitive data)
* Error message
* Stack trace (where available)

**Sensitive Data Exclusion:**
* User data (form data, file contents) SHALL NOT be logged
* File paths SHALL be sanitized (remove user home directory, show relative paths)
* Passwords and keys SHALL NEVER be logged

== Test Suite Requirements and Acceptance Criteria (EXPANDED)

This suite ensures validation of all critical security, trust persistence, and architectural isolation requirements from the SRS.

=== Security and Trust Verification

[cols="1, 2, 4", options="header", grid="all"]
|===
^.^| Test Case ID ^.^| Requirement ^.^| Acceptance Criteria (AC)

| **T-SEC-01** | Commercial Trust (FR-2.3.1) | Load an L1 (CA-Signed) cartridge. **AC:** The content renders immediately, and the `requestAppConsent` call returns TRUE without displaying the native dialog.
| **T-SEC-02** | Initial Consent (FR-2.3.2/2.3.3) | Load an L2 (Self-Signed) or L3 (Unsigned) cartridge. **AC:** The content renders, and the first `requestAppConsent` call triggers the native modal dialog defined in DDD 11.2.1.
| **T-SEC-03** | Persistent Trust (FR-2.4.1) | Execute T-SEC-02. Select "Always Trust this cartridge." **AC:** A new record is written to `Local_Trust_Registry` with `app_trust_policy: PERSISTENT`. Subsequent loads skip the dialog.
| **T-SEC-04** | Tampering Detection (FR-2.4.4) | Load a persistently trusted cartridge, manually corrupt the file (changing content tables). **AC:** Verification Phase 3 (H1 vs. H2 check) fails, the load is blocked, and an "Rejected (Tampered)" error is displayed *before* any content rendering or application execution.
| **T-SEC-05** | Trust Revocation (FR-2.4.3) | Revoke persistent trust for a cartridge via the UI. **AC:** The corresponding entry in `Local_Trust_Registry` is updated to `app_trust_policy: REVOKED`. The next load forces the user to re-consent (T-SEC-02).
|===

=== Architectural and Persistence Validation

[cols="1, 2, 4", options="header", grid="all"]
|===
^.^| Test Case ID ^.^| Requirement ^.^| Acceptance Criteria (AC)

| **T-PERS-01** | Manifest Creation (FR-2.5.1) | Import a new cartridge file. **AC:** A new entry is created in `Local_Library_Manifest` containing the correct `cartridge_guid`, `cartridge_hash`, `title`, and the newly required `publication_year`.
| **T-PERS-02** | Multi-Window Isolation (FR-2.1.1) | Open Cartridge A and Cartridge B simultaneously. Save form data in B, then load data in A. **AC:** Data saved in B is isolated to B's `User_Data` table and does not corrupt or appear in A's session. Both Reader View Instances remain fully responsive.
| **T-PERS-03** | Cartridge Deletion (FR-2.5.5) | Delete a cartridge via the List-View context menu. **AC:** The cartridge file is deleted from the file system. Its records are removed from both the `Local_Library_Manifest` and the `Local_Trust_Registry`.
| **T-UI-01** | Library Performance (NFR-3.1) | Open the Library Manager containing 100 cartridges. **AC:** The Library View (Bookshelf or List) loads and displays all required metadata fields within 500 milliseconds, demonstrating reliance on the manifest data, not file parsing.
| **T-UI-02** | UI Dual View (DDD 11.1) | Toggle between the Bookshelf and List-View. **AC:** Both views load instantly. The List-View displays the required columns: Title, Author, Edition/Version, and Year of Publication, sourced correctly from the manifest.
|===

