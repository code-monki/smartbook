= Smartbook Project High-Level Design (HLD) - FINAL REVISED
:author: Gemini AI Assistant
:revdate: 2025-12-14
:doctype: article
:toc: left
:toclevels: 3
:sectnums:

== Introduction and Goals

This document outlines the macro-architecture, key components, data flow, and architectural constraints for the Smartbook Reader application, ensuring all SRS requirements are addressed at a high level.

== Architectural Overview: Multi-Window Isolation

The system employs a Multi-Window Architecture to guarantee separation of concerns and security isolation. The application is divided into a single **Library Manager** and multiple, independent **Reader View Instances**.

=== System Architecture Diagram

The following diagram illustrates the high-level system architecture:

[NOTE]
====
See `diagrams.adoc` (System Architecture Overview diagram) for the complete visual representation of the Multi-Window Architecture with Library Manager, Reader View Instances, Data Management Layer, and Security Layer.
====


=== Key Components and Responsibilities

[cols="2, 4, ^2, 4", options="headers"]
|===
^.^| Component ^.^| Responsibility ^.^| Pattern ^.^| Key Constraint / Security

| **Library Manager (The Hub)** | Handles application launch, library browsing, import/delete, and Trust Revocation. | Main Application | **MUST** rely exclusively on the Manifest for fast loading (NFR-3.1).
| **Reader View Instance** | Container for a single opened cartridge. Owns the web view and data connector. | Per-Cartridge Process | Enforces security policy and data isolation (FR-2.1.1).
| **WebChannel Bridge** | IPC layer between embedded JS and native C++ code. | Per-Instance | Exposes restricted API (`saveFormData`, `requestAppConsent`).
| **Signature Verifier** | Executes the 4-Phase Verification Algorithm (DDD 6). | Utility Class | Determines the final **Effective Trust Policy** before content execution.
|===

== Data Management Layer (DML) Specification

The DML handles all persistence and is partitioned into global and per-instance components.

=== DML Components and Patterns

[cols="2, 4, ^3, 5"]
|===
^.^| Component ^.^| Database Target ^.^| Pattern ^.^| Function

| **LocalDBManager** | `local_reader.sqlite` (Manifest, Trust Registry) | **Singleton (Global)** | Manages the single connection to the global manifest and trust registry. Used by the Library Manager and the Signature Verifier.
| **CartridgeDBConnector** | `*.sqlite` (Cartridge file) | **Per-Instance** | Manages the connection and transactional persistence for one specific cartridge's content and `User_Data`.
|===

=== Data Flow Constraints

* **Library Load Performance (NFR-3.1 Constraint):** The **Library Manager** component **MUST** retrieve all library display data (Title, Year, Cover Image) by querying the `Local_Library_Manifest` table via the **Singleton `LocalDBManager`**. It is forbidden from parsing cartridge files at runtime to maintain the < 500ms load time.
* **Isolation (FR-2.1.1 Constraint):** Each **Reader View Instance** is guaranteed data isolation because its `CartridgeDBConnector` is unique to that instance and only connects to its specific cartridge file, never to the global `Local Reader Database`.

== Security and Trust Flow

The core security logic is centralized in the `SignatureVerifier` utility class.

=== 4-Phase Verification Algorithm

The following sequence diagram illustrates the 4-Phase Verification Algorithm:

[source,plantuml]
----
include::diagrams.adoc[tags=verification-algorithm]
----

// See `diagrams.adoc` for the complete 4-Phase Verification Algorithm sequence diagram.

=== Trust Policy Determination

1.  **Identity:** The `SignatureVerifier` reads the `cartridge_guid` and security data (H1) from the cartridge.
2.  **Integrity Check:** The verifier recalculates H2 (content hash) and compares H1 vs. H2 (Tampering Detection, FR-2.4.4).
3.  **Local Trust Check:** The verifier queries the **Singleton `LocalDBManager`** to check the `Local_Trust_Registry` for a user-granted `PERSISTENT` policy.
4.  **Final Policy:** A final **Effective Trust Policy** is determined: `WHITELISTED`, `CONSENT_REQUIRED`, or `REJECTED`.

=== Embedded Application Execution

When embedded JavaScript calls `requestAppConsent()`, the **WebChannel Bridge** checks the **Effective Trust Policy**:
* If `WHITELISTED` (L1 or Persistent Trust, and H1=H2): The native dialog is skipped.
* If `CONSENT_REQUIRED` (L2 or L3): The native consent dialog is displayed (FR-2.3.2/2.3.3).

== Custom Navigation Bar Architecture

The Reader supports custom navigation bars defined within cartridges, enabling specialized navigation for magazine collections and similar content types.

=== Navigation Bar Components

**Navigation Structure:**
* Stored in `Navigation_Structure` table within cartridge database
* Defines navigation groups (Browse, Departments, Bibliographies, etc.)
* Each group contains menu items with navigation targets
* Supports hierarchical navigation (sub-menus via `parent_item_id`)

**Navigation Rendering:**
* Custom navigation bar rendered as HTML/CSS within Reader View
* Positioned above main content area
* Styled using cartridge CSS and themes
* Separate from application menu (cartridge-specific)

**Navigation Targets:**
* **Page ID:** Direct navigation to specific page
* **Anchor:** Navigation to anchor on current or specified page
* **Page and Anchor:** Combined page and anchor navigation
* **Custom Handler:** JavaScript-based navigation (e.g., Browse by Creator/Issue/Title)

=== Navigation Flow

1. **Load Navigation Structure:** Reader queries `Navigation_Structure` table on cartridge open
2. **Render Navigation Bar:** HTML navigation bar generated from structure data
3. **User Interaction:** User selects menu item from dropdown
4. **Target Resolution:** Reader resolves navigation target (page_id, anchor, custom handler)
5. **Navigation:** Reader navigates to target and updates reading position/history

**Browse Navigation:**
* Custom handlers filter content by metadata (Creator, Issue, Title)
* Results displayed as filtered content view or index page
* Filter criteria defined in `metadata_json` field

**Department Navigation:**
* Direct navigation to department-specific pages or sections
* Supports hierarchical department structures

**Bibliography Navigation:**
* Navigation to citation format reference pages
* Target format: page and anchor (e.g., bibliography page with format sections)

== Series and Edition Grouping Architecture

The Library Manager supports organizing cartridges by series, edition, and user-defined custom collections.

=== Grouping Components

**Metadata-Based Grouping:**
* Cartridge `Metadata` table includes optional `series_name`, `edition_name`, and `series_order` fields
* Author-defined series/editions are portable across systems
* Library Manager auto-groups cartridges by series/edition metadata

**Local Grouping System:**
* `Local_Cartridge_Groups` table stores group definitions (series, editions, custom collections)
* `Local_Cartridge_Group_Members` junction table links cartridges to groups
* Custom collections are user-defined and stored locally

=== Grouping Flow

**Auto-Grouping (Series/Edition):**
1. On library load or cartridge import, Library Manager queries `Local_Library_Manifest` for unique `series_name` and `edition_name` values
2. For each unique value, creates or updates group in `Local_Cartridge_Groups` (group_type: "series" or "edition")
3. Adds cartridges to group memberships based on metadata
4. Auto-grouped series/editions are read-only (managed by system)

**Custom Collections:**
1. User creates custom collection via Library Manager UI
2. Collection stored in `Local_Cartridge_Groups` (group_type: "custom_collection")
3. User adds/removes cartridges to/from collection
4. Custom collections are user-managed and local-only

**Grouping Display:**
1. Library Manager provides filter/view options: "All", "By Series", "By Edition", "Custom Collections"
2. When filter selected, Library Manager queries appropriate groups and displays members
3. Series members ordered by `series_order` (if available), otherwise alphabetical
4. Edition and custom collection members ordered alphabetically (or by user-defined `display_order`)

=== Grouping Performance

**Query Optimization:**
* All grouping queries use `Local_Library_Manifest` (fast, indexed, < 500ms per NFR-3.1)
* Group memberships queried efficiently via indexed junction table
* No cartridge file parsing required for grouping operations

**Indexes:**
* Index on `Local_Cartridge_Groups.group_type` for filtering
* Index on `Local_Cartridge_Group_Members(group_id, cartridge_guid)` for membership queries
* Index on `Local_Library_Manifest.series_name` and `edition_name` for auto-grouping