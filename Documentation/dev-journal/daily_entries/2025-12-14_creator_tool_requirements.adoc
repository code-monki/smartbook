= Creator Tool Requirements Specification and Documentation Consolidation
:author: AI Assistant
:revdate: 2025-12-14
:doctype: article
:toc: left
:toclevels: 3
:sectnums:

== ADR 006: Creator Tool Requirements Specification Approach

[cols=">1, 5"]
|===
| **Status** | Accepted
| **Date** | 2025-12-14
| **Decision Driver** | Need for comprehensive Creator Tool specifications to enable Phase 1 development. Initial focus was on Reader application; Creator Tool requirements were identified as a critical gap.
| **Decision** | Creator Tool requirements SHALL be documented in the main SRS document alongside Reader requirements, rather than in a separate document. A comprehensive set of 73 functional requirements (FR-CT-3.1 through FR-CT-3.73) has been added covering all major Creator Tool functionality.
| **Consequences** | 
* Single source of truth for Phase 1 requirements
* Easier cross-referencing between Reader and Creator Tool requirements
* Requirements may be refined during detailed design phase
* Document structure remains manageable (~250+ lines)
|===

== ADR 007: SRS Document Consolidation

[cols=">1, 5"]
|===
| **Status** | Accepted
| **Date** | 2025-12-14
| **Decision Driver** | Two SRS documents existed (`srs.adoc` and `srs-addendum-1.adoc`) with unclear relationship and potential for confusion.
| **Decision** | The addendum content has been merged into the main `srs.adoc` document, and `srs-addendum-1.adoc` has been deleted. The main SRS now contains all requirements with enhanced formatting (rationale columns in NFR section).
| **Consequences** | 
* Single authoritative SRS document
* No ambiguity about which document is current
* Improved NFR section formatting with rationale columns
* All requirements consolidated in one location
|===

== Creator Tool Requirements Scope

The following major functional areas have been specified for the Creator Tool:

=== Core Authoring Capabilities

* **Content Authoring (FR-CT-3.1-3.5):** WYSIWYG HTML editing using Qt WebEngineView, rich text editing tools, direct HTML editing capability, standard edit operations (cut/copy/paste/undo/redo), and preview functionality (live or manual refresh - design decision pending).

* **Page Management (FR-CT-3.6-3.9):** Page selection, CRUD operations, page ordering, and chapter organization.

* **Stylesheet Management (FR-CT-3.10-3.11):** CSS stylesheet attachment and editing capabilities.

* **JavaScript and Embedded Applications (FR-CT-3.12-3.14):** Custom JavaScript storage, embedded application definition using `Embedded_App_Manifest` structure, and JavaScript management interface.

* **Form Definition Management (FR-CT-3.15-3.18):** Form creation using Form Definition JSON Schema, visual form builder interface, form schema validation, and form integration into content pages.

=== Document and Resource Management

* **Metadata Management (FR-CT-3.19-3.22):** Document-level metadata (title, author, publication year, version, tags, cover image), cover image management, automatic UUID v4 GUID generation, and schema version management.

* **Resource Management (FR-CT-3.23-3.24):** Asset management for embedded resources (images, fonts, media) and resource storage within cartridge.

* **Search Functionality (FR-CT-3.25-3.26):** Content search across entire smartbook or current page, with search result navigation.

=== Cartridge Lifecycle

* **Cartridge Creation and Export (FR-CT-3.27-3.35):** New cartridge creation, opening existing cartridges, saving, content validation, hash calculation (H1), cartridge signing at three trust levels (CA-signed, self-signed, unsigned), certificate management, export process following DDD Section 7 algorithm, and export validation.

=== Enhanced Features

* **Auto-Save and Recovery (FR-CT-3.36-3.39):** Configurable auto-save intervals, visual indicators, and crash recovery.

* **Draft and Publishing States (FR-CT-3.40-3.43):** Draft mode, published state distinction, state management, and publish workflow.

* **Content Templates (FR-CT-3.44-3.47):** Template creation, template library, template application, and template management.

* **Import Capabilities (FR-CT-3.48-3.52):** Markdown, DOCX, and HTML import with validation and configurable options.

* **Version History (FR-CT-3.53-3.57):** Version tracking, version snapshots, version comparison, version restoration, and version metadata.

* **Error Recovery and Data Integrity (FR-CT-3.58-3.62):** Corruption detection, incomplete save recovery, backup creation, data validation, and transaction safety.

* **Accessibility (FR-CT-3.63-3.68):** Keyboard navigation, screen reader support, high contrast mode, font scaling, WCAG 2.1 Level AA compliance, and keyboard shortcuts documentation.

* **Multi-Language Support (FR-CT-3.69-3.73):** UI localization using Qt i18n, language selection, content language support including RTL, language pack management, and metadata localization.

* **Theming Support (FR-CT-3.74-3.80):** Built-in themes (Light, Dark, Sepia), theme selection and persistence, custom theme creation and management, theme preview, and theme export/import.

== ADR 008: Creator Tool Theming Requirements

[cols=">1, 5"]
|===
| **Status** | Accepted
| **Date** | 2025-12-14
| **Decision Driver** | Multiple user requests for theming support in Creator Tool. Theming was already specified for Reader application in Product Concept but was missing from Creator Tool requirements.
| **Decision** | Creator Tool SHALL support theming with three built-in themes (Light, Dark, Sepia) plus custom theme creation/management capabilities. Seven new requirements (FR-CT-3.74 through FR-CT-3.80) have been added to specify theming functionality.
| **Consequences** | 
* Creator Tool will match Reader's theming capabilities
* Users can customize interface appearance
* Custom themes can be shared via export/import
* Theme selection persists across sessions
* High contrast themes support accessibility requirements
|===

== ADR 009: Creator Tool Wireframe Design Decisions

[cols=">1, 5"]
|===
| **Status** | Accepted
| **Date** | 2025-12-14
| **Decision Driver** | Need for visual design reference for Creator Tool main interface. Initial wireframe created to guide implementation.
| **Decision** | 
* Creator Tool main interface wireframe created using SVG format with detailed AsciiDoc description
* Three-panel layout: Page Management (left), Main Editor (center), Properties Panel (right)
* Theme selector added to View menu area as dropdown
* Status bar excluded from initial design (may be added later if needed)
* Tabbed editor interface for Editor/Preview/HTML Source/CSS/JavaScript
| **Consequences** | 
* Visual reference available for development team
* Layout decisions documented
* Theme selector placement established
* Status bar deferred to future iteration
|===

== ADR 010: Embedded Application Concept and Schema Definition

[cols=">1, 5"]
|===
| **Status** | Accepted
| **Date** | 2025-12-14
| **Decision Driver** | Schema mismatch between Product Concept (`Embedded_Apps` table) and DDD (`Embedded_App_Manifest` JSON). Need to clarify what embedded applications are and how they're stored/executed.
| **Decision** | 
* **Embedded Apps Defined:** Single Page Applications (SPAs) or similar interactive components that provide functionality like character generators, design tools (vehicle/weapon/armor), calculators, artifact generators
* **Security Model:** Embedded apps operate **locally only** with **no network access** and have access only to a sandboxed local file system
* **Schema Resolved:** Complete `Embedded_Apps` table schema defined in DDD with columns: `app_id`, `app_name`, `manifest_json`, `entry_html`, `js_code`, `css_code`, `additional_resources`
* **Manifest Storage:** `Embedded_App_Manifest` JSON stored in `manifest_json` column of `Embedded_Apps` table
* **Sandbox API:** Four new WebChannel API methods added for sandbox file operations: `saveSandboxFile`, `loadSandboxFile`, `listSandboxFiles`, `deleteSandboxFile`
* **Execution Flow:** Complete 7-step execution flow documented in DDD
| **Consequences** | 
* Schema mismatch resolved
* Security model clearly defined (local-only, sandboxed)
* Execution flow documented for implementation
* Sandbox file system API enables app persistence without security risks
* Clear separation between embedded apps and regular content pages
|===

== Design Decisions Pending

The following items require design decisions during detailed design phase:

* **HTML Storage Format:** Whether to store content as full HTML pages or HTML fragments (FR-CT-3.1). *Recommendation: HTML fragments for portability.*

* **Preview Implementation:** Whether to implement live preview (real-time updates) or manual refresh preview (FR-CT-3.5). *Recommendation: Start with manual refresh, consider live preview if performance allows.*

== Documentation Updates

* **SRS Document:** 
** Updated to include Creator Tool requirements (initially 73, now 80 requirements: FR-CT-3.1 through FR-CT-3.80)
** Added theming requirements (FR-CT-3.74 through FR-CT-3.80) based on user feedback
** Updated FR-2.2.2 to clarify embedded apps are local-only with sandboxed file system
* **DDD Document:**
** Added complete `Embedded_Apps` table schema definition (Section 3)
** Added Embedded Application Specification section with concept, security model, and execution flow
** Clarified relationship between `Embedded_App_Manifest` JSON and database table
** Documented 7-step execution flow for embedded apps
** Added sandbox file system specification
* **WebChannel API Specification:**
** Added four sandbox file system API methods: `saveSandboxFile`, `loadSandboxFile`, `listSandboxFiles`, `deleteSandboxFile`
** Documented security constraints for sandbox operations
** Added comprehensive error handling for all API methods with standard callback patterns, error codes, and error messages
** Documented error code categories and logging requirements
* **Error Handling:**
** Added 18 error handling requirements to SRS (FR-ERR-4.1 through FR-ERR-4.18)
** Added comprehensive error handling strategy to DDD covering Reader and Creator Tool
** Specified logging requirements: minimal logging, automatic rotation (10MB or daily), 5 file retention
** Standardized error code categories and callback patterns
* **Wireframes:** 
** Created Creator Tool main interface wireframe (SVG format)
** Created detailed wireframe description document (AsciiDoc)
** Added theme selector to wireframe design
** Excluded status bar from initial design
* **Documentation Review:** 
** Updated to mark Creator Tool specifications gap as resolved
** Updated to mark Embedded Applications schema and execution gap as resolved
* **Introduction:** Updated to clarify that both Reader and Creator Tool are documented in single SRS, with rationale for unified approach

== ADR 011: Network Access for Embedded Applications

[cols=">1, 5"]
|===
| **Status** | Rejected (Deferred)
| **Date** | 2025-12-14
| **Decision Driver** | Discussion of whether to allow users to opt-in to network access for embedded applications on a per-cartridge basis, given security concerns and current internet security landscape.
| **Decision** | 
* **Network access for embedded apps will NOT be implemented in Phase 1**
* Embedded applications SHALL remain **local-only** with **no network access**
* All network requests from embedded apps SHALL be blocked via interceptor
* Content pages can still have external links that open in system browser (via link delegation)
* Sandbox file system provides app persistence without network risks
* This decision may be revisited in future phases if clear user demand emerges
| **Rationale** | 
* **Security-first approach:** Keeps security model simple and predictable, reduces attack surface
* **Liability concerns:** Even for open source project, security incidents harm reputation
* **Current threat landscape:** Internet security risks make network access particularly risky
* **Sufficient functionality:** Most use cases (character generators, calculators, design tools) work offline
* **User understanding:** Users may not fully understand security implications of enabling network access
* **Implementation complexity:** Adds significant complexity for uncertain benefit
* **Future flexibility:** Can be added later with stricter controls if needed
| **Consequences** | 
* Simpler security model (one permission: app execution)
* Reduced attack surface
* Clear security boundaries
* Some advanced use cases requiring network access will not be supported in Phase 1
* External links must be handled via content pages (opened in system browser)
* Sandbox file system remains primary persistence mechanism
|===

== Next Steps

* Proceed with detailed design of Creator Tool based on specified requirements
* Resolve pending design decisions (HTML format, preview implementation)
* Begin addressing remaining documentation gaps (Embedded Applications schema, Error Handling specifications)
* Consider UI/UX design specifications for Creator Tool in DDD
* Implement theming system matching Reader's theming capabilities
* Review wireframe with stakeholders and refine as needed
* **Note:** Network access feature deferred - embedded apps remain local-only

=== ADR 013: Settings Table Specification and User Override Model

**Date:** 2025-12-14

**Context:** The Product Concept document mentioned a `Settings` table for book-specific rendering defaults, but it was not fully specified in the DDD or referenced in requirements. The documentation review identified this as a gap.

**Decision:** 
1. **Settings Table in Cartridge:** The `Settings` table is part of the cartridge schema (defined in DDD Section 3). Authors define initial rendering defaults (font size, font family, theme, margins, line spacing, etc.) that are stored directly in the cartridge file.
2. **User Override Storage:** User preference overrides are stored separately in the Reader's local database (`Local_User_Settings` table), scoped per cartridge by `cartridge_guid`.
3. **Reset Functionality:** The original author-defined defaults are preserved in the cartridge, allowing users to reset their overrides and restore the author's intended appearance.

**Requirements Added:**
* **Reader:** FR-2.2.3, FR-2.2.4, FR-2.6.1 through FR-2.6.5 (settings reading, user override, reset, persistence, priority)
* **Creator Tool:** FR-CT-3.12a through FR-CT-3.12d (settings definition, editor, validation, preview)

**Schema Details:**
* `Settings` table: `setting_key` (PRIMARY KEY), `setting_value`, `setting_type`, `description`
* `Local_User_Settings` table: `settings_id`, `cartridge_guid`, `setting_key`, `setting_value`, `timestamp`
* Settings priority: 1) User override, 2) Author default, 3) Application default

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

=== ADR 014: Form Rendering and Interaction Specification

**Date:** 2025-12-14

**Context:** Form Definition JSON Schema was defined, but specifications for form rendering, embedding, validation, persistence, and printing were missing. Forms needed to be seamlessly integrated into content pages (not as add-ons like PDF forms).

**Decision:**
1. **HTML Form Rendering:** Forms SHALL be rendered using standard HTML form elements (`<form>`, `<input>`, `<textarea>`, `<select>`, etc.) based on the form definition JSON schema. Forms are seamlessly integrated into content pages as part of the document flow.
2. **Form Embedding:** Forms are embedded in content pages using HTML markers (`<div data-smartbook-form="form_id">` or `<smartbook-form>`). Reader detects markers and dynamically renders forms.
3. **Dual Persistence:** Forms support two persistence mechanisms:

   * **Cartridge Persistence:** Save to `User_Data` table via `saveFormData` API (persists across sessions)
   * **Sandbox Persistence:** Save to sandbox file system via `saveSandboxFile` API (enables embedded app access)
4. **Form Printing:** Forms can be printed, displaying field values instead of input controls in print-friendly format.
5. **Form State Management:** Auto-save (configurable interval), reset to defaults, clear form, and multiple instance support.

**Requirements Added:**
* **Reader:** FR-2.7.1 through FR-2.7.10 (form rendering, embedding, validation, persistence, printing, state management)

**DDD Specifications Added:**
* **Section:** "Form Rendering and Interaction Specification" with:
  * Form embedding syntax and detection flow
  * Field type to HTML element mapping
  * Form structure generation algorithm
  * Client-side validation implementation
  * Validation error display patterns
  * Dual persistence mechanisms (cartridge and sandbox)
  * Print functionality algorithm and CSS
  * Form state management (auto-save, reset, multiple instances)

**Key Features:**
* Forms are integral part of document (not overlays/popups)
* Standard HTML forms ensure compatibility and accessibility
* Sandbox persistence enables embedded app integration
* Print functionality provides professional output
* Multiple instances support complex document structures

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

**Update (2025-12-14):** Added sandbox file picker requirement (FR-2.7.5a) for selecting files when saving/loading form data to/from sandbox. File picker MUST be restricted to sandbox directory only for security. Added `openSandboxFilePicker` WebChannel API method specification with security constraints.

=== ADR 015: Content Navigation Specification

**Date:** 2025-12-14

**Context:** Content navigation was mentioned but not detailed in specifications. Users need forward/backward navigation, table of contents, bookmarking, and reading position persistence.

**Decision:**
1. **Forward/Backward Navigation:** Sequential navigation based on `page_order` with wrap-around or boundary handling
2. **Table of Contents:** Generated from `chapter_title` (primary) and HTML headings (secondary), configurable depth (1-3 levels, default 2)
3. **Tabbed Pane:** TOC and Search Results in shared tabbed interface
4. **Internal Links:** Support for `smartbook://page/{id}` and anchor links (`#anchor-id`), external links open in system browser
5. **Bookmarking:** Full bookmark functionality with user labels, stored in `Local_Bookmarks` table
6. **Reading Position:** Automatic save/restore in `Local_Reading_Position` table, updates on navigation and close
7. **Navigation History:** Browser-style back/forward history stack per Reader View Window
8. **Page Numbering:** Deferred for Phase 1 - not essential for electronic publications, challenging for print with variable paper sizes

**Requirements Added:**
* **Reader:** FR-2.8.1 through FR-2.8.8 (navigation, TOC, bookmarking, reading position, history, page numbering decision)

**DDD Specifications Added:**
* **Tables:** `Local_Bookmarks` and `Local_Reading_Position` schemas
* **Section:** "Content Navigation Implementation Specification" with:
  * Forward/backward navigation algorithm
  * TOC generation algorithm (chapters + headings)
  * Tabbed pane structure
  * Internal link processing and navigation
  * Bookmarking implementation (add, manage, navigate)
  * Reading position persistence (save/restore)
  * Navigation history stack management

**Key Features:**
* TOC generated from both chapter structure and HTML headings
* Configurable TOC depth (1-3 levels)
* Tabbed interface for TOC and Search Results
* Bookmarking with labels and precise position restoration
* Automatic reading position persistence
* Browser-style navigation history
* Page numbering deferred (not essential for electronic format)

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

=== ADR 016: Search Functionality Specification

**Date:** 2025-12-14

**Context:** Product Concept mentioned full-text search, but no detailed requirements or UI specifications existed. Users need both document-wide search and in-page find functionality.

**Decision:**
1. **Document Search:** Modal dialog with search input, case sensitivity toggle, search type dropdown (Normal, Boolean, Fuzzy, Regex), and Search button. Results displayed in Search Results tab (shared with TOC) in Adobe Reader-style format.
2. **Search Types:**

   * Normal: Exact text matching with optional case sensitivity
   * Boolean: AND, OR, NOT operators for complex queries
   * Fuzzy: Approximate matching using edit distance for typos/misspellings
   * Regex: Regular expression pattern matching (advanced feature with error handling)
3. **In-Page Search:** Chrome-style find-in-page with compact dialog, term highlighting, match navigation, result count, case sensitivity, auto-scroll, and search persistence across pages.

**Requirements Added:**
* **Reader:** FR-2.9.1 through FR-2.9.8 (document search), FR-2.10.1 through FR-2.10.7 (in-page search)

**DDD Specifications Added:**
* **Section:** "Search Functionality Implementation Specification" with:
  * Document search modal UI specification
  * Normal search algorithm (HTML stripping, context snippets)
  * Boolean search algorithm (query parsing, expression evaluation)
  * Fuzzy search algorithm (edit distance, similarity scoring)
  * Regex search algorithm (pattern validation, error handling)
  * Search results display format (Adobe Reader-style)
  * Search performance optimization (indexing, caching strategies)
  * In-page search dialog specification
  * Term highlighting implementation (CSS classes, dynamic updates)
  * Match navigation (array tracking, scroll-to-match)
  * Result count display
  * Case sensitivity handling
  * Search persistence across pages

**Key Features:**
* Four search types (Normal, Boolean, Fuzzy, Regex) for different use cases
* Regex marked as advanced feature with clear error handling
* Adobe Reader-style result presentation for familiarity
* Chrome-style in-page search for consistency with user expectations
* Performance optimization strategies (indexing, caching)
* Search persistence across page navigation

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

=== ADR 017: Content Theme Manager Specification

**Date:** 2025-12-14

**Context:** UI prototype provided for Content Theme Manager dialog. This is distinct from UI theming - it manages themes that apply to smartbook content (how content appears in the Reader), not the Creator Tool interface itself.

**Decision:**
1. **Content Theme Manager Dialog:** Two-panel layout with Available Themes list (left) and Theme Configuration/Preview (right)
2. **Theme Management:** Add, Delete, Copy, Rename actions for custom themes; built-in themes (Light Content, Dark Content, Warm Content) are immutable
3. **Theme Configuration:** Core Colors section with color pickers/swatches, Preset dropdown, Reset button, Live Preview showing sample content
4. **Theme Storage:** Content themes stored in `Content_Themes` table within cartridge, allowing each smartbook to have its own themes
5. **Theme Application:** Themes generate CSS that applies to content rendering in both Creator Tool preview and Reader

**Requirements Added:**
* **Creator Tool:** FR-CT-3.82 through FR-CT-3.90 (Content Theme Manager dialog, theme list, theme actions, configuration, preview, storage, application)

**DDD Specifications Added:**
* **Table:** `Content_Themes` table schema with `theme_id`, `theme_name`, `is_builtin`, `theme_config_json`, `is_active` columns
* **Section:** "Content Theme Manager Implementation Specification" with:
  * Dialog structure (two-panel layout)
  * Left panel: Available Themes list, action buttons, "Persist on add" checkbox
  * Right panel: Name section, Core Colors section, Live Preview section
  * Theme management operations (Add, Delete, Copy, Rename, Apply, Save, Revert)
  * Theme configuration storage (database operations, JSON schema)
  * Theme application to content (CSS generation, injection)
  * Built-in themes specification

**Key Features:**
* Content themes (for smartbook content) separate from UI themes (for Creator Tool interface)
* Built-in themes (Light Content, Dark Content, Warm Content) are immutable
* Custom themes can be created, edited, copied, renamed, deleted
* Live preview shows how theme affects content rendering
* Themes stored in cartridge, allowing each smartbook to have custom themes
* "Persist on add" option for automatic saving

**Design Rationale - CSS vs Theme Separation:**
By separating structural concerns (CSS) from visual appearance concerns (themes), the system achieves a balanced approach:

* **Author Control:** Authors maintain control over page structure, layout, and organization through CSS, ensuring content is presented as intended
* **User Customization:** Users can customize visual appearance (colors, fonts) through theme selection and user settings, accommodating personal preferences and accessibility needs
* **Middle Ground:** This separation provides a reasonable middle ground between strict author control (no customization) and complete user control (which could break author intent), allowing both parties to achieve their goals without conflict

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

=== ADR 018: Print Functionality Specification

**Date:** 2025-12-14

**Context:** Product Concept mentioned print support, but no detailed requirements existed. Users need to print documents, pages, or selections with proper formatting for common paper sizes.

**Decision:**
1. **Print Capabilities:** Support printing entire document, current page only, or selected text/content
2. **System Print Dialog:** Use native Qt `QPrintDialog` for standard print configuration
3. **Print CSS:** Provide built-in print stylesheets optimized for US Letter and A4 paper sizes, with `@media print` rules
4. **Offscreen Rendering:** Support offscreen rendering if required by Qt's printing implementation
5. **Print Preview:** Provide preview capability before printing
6. **Print Quality:** Ensure high-quality output for text, images, and colors

**Requirements Added:**
* **Reader:** FR-2.11.1 through FR-2.11.8 (print capabilities, system dialog, print CSS, offscreen rendering, preview, quality, keyboard shortcut)

**DDD Specifications Added:**
* **Section:** "Print Functionality Implementation Specification" with:
  * Print capabilities (document, page, selection)
  * Print dialog integration (Qt `QPrintDialog`)
  * Built-in print CSS for US Letter and A4 paper sizes
  * Print rendering implementation (onscreen/offscreen strategies)
  * Print preview implementation
  * Print quality considerations (text, images, colors, backgrounds)
  * CSS priority and application order
  * Multi-page document printing and page break handling

**Key Features:**
* Three print scopes: document, page, selection
* Native system print dialog integration
* Built-in print CSS for common paper sizes (US Letter, A4)
* Print CSS works with structural CSS and theme CSS
* Offscreen rendering support for Qt compatibility
* Print preview before printing
* High-quality output considerations

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

=== ADR 019: Text Selection and Copy Functionality Specification

**Date:** 2025-12-14

**Context:** Product Concept mentioned text selection, copy, and highlight, but no detailed requirements existed. Users need to select and copy text from Reader content, with the ability to paste into forms within the book or external documents.

**Decision:**
1. **Text Selection:** Support standard text selection methods (mouse, keyboard, double-click word, triple-click paragraph)
2. **Copy to Clipboard:** Copy selected text as plain text without formatting, removing background colors to prevent interference when pasting
3. **Paste into Forms:** Allow pasting copied text into form fields within smartbook content
4. **Paste into External Documents:** Ensure copied text is pasteable into external applications as plain text
5. **Context Menu:** Provide right-click context menu with copy option
6. **Note:** Persistent text highlighting/annotations deferred for Phase 1

**Requirements Added:**
* **Reader:** FR-2.12.1 through FR-2.12.6 (text selection, copy to clipboard, background removal, paste into forms, paste into external documents, context menu)

**DDD Specifications Added:**
* **Section:** "Text Selection and Copy Implementation Specification" with:
  * Text selection methods and behavior
  * Copy to clipboard implementation with background removal algorithm
  * Paste functionality for forms and external documents
  * Context menu implementation
  * Clipboard integration using Qt `QClipboard`
  * Form field paste handling
  * Selection persistence behavior

**Key Features:**
* Standard text selection methods (mouse, keyboard, word/paragraph selection)
* Plain text copy without background formatting
* Background removal algorithm to strip styling from copied text
* Paste into form fields within smartbook
* Paste into external applications as plain text
* Context menu with copy option
* Creator Tool already has cut/copy/paste (FR-CT-3.4)

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

=== ADR 021: Certificate Validation and Management

**Date:** 2025-12-14

**Context:** The security model references CA-signed and self-signed certificates, but the documentation lacked specifications for certificate storage/management, validation against trusted CAs, expiration handling, revocation checking, and trusted CA list management.

**Decision:**
1. **System Certificate Store Integration:** Use Qt's `QSslCertificate` class to validate certificates against the system's trusted root CA store (Windows Certificate Store, macOS Keychain, Linux CA bundle). No manual CA list maintenance required.

2. **Certificate Storage:** Add `certificate_data` column (BLOB) to `Cartridge_Security` table to store the X.509 certificate (DER or PEM format) used for signing.

3. **Certificate Validation Algorithm:**

   * Extract certificate from `certificate_data`
   * Use `QSslCertificate::verify()` to determine if certificate is CA-signed or self-signed
   * Check certificate expiration dates (`effectiveDate()` and `expiryDate()`)
   * Determine final certificate status: `CA_VALID`, `CA_EXPIRED`, `SELF_SIGNED`, `INVALID`, or `NONE`

4. **Expired CA Certificate Handling:** Expired CA-signed certificates are downgraded to Level 2 (Self-Signed Trust) rather than being rejected. This allows users to make informed trust decisions for content that was signed when the certificate was valid.

5. **Certificate Revocation:** Certificate revocation checking (OCSP/CRL) is deferred for Phase 1 due to network access requirements conflicting with offline-first design, added complexity, and most Phase 1 use cases not requiring revocation checking.

**Consequences:**
* **Positive:** Automatic certificate validation using system trust stores, no manual CA list maintenance, expired certificates handled gracefully (downgrade rather than rejection)
* **Negative:** No revocation checking in Phase 1, expired CA certificates require user consent (may be unexpected)
* **Neutral:** Certificate validation adds a step to signature verification, expired certificate handling requires clear user messaging

**Requirements Updated:**
* Updated signature verification algorithm (Phase 1) to include certificate extraction and validation
* Updated trust level assignment (Phase 2) to handle expired CA certificates (downgrade to Level 2)

**DDD Specifications Added:**
* **Section:** "Certificate Validation Implementation" with:
  * Certificate extraction process
  * System certificate store integration (platform-specific)
  * Certificate validation algorithm (type determination, expiration checking, status determination)
  * Expired CA certificate handling (downgrade to Level 2)
  * Certificate revocation (deferred for Phase 1)

**Status:** [OK] RESOLVED - Fully specified in DDD

=== ADR 022: Public Key Extraction and Fingerprint Verification

**Date:** 2025-12-14

**Context:** DDD mentioned `public_key_fingerprint` but lacked specifications for how public keys are distributed, stored in the Reader, or how key rotation/updates would work. The signature verification algorithm referenced "Use Public Key" without specifying the source of the public key.

**Decision:**
1. **Public Key Source:** Public keys are extracted from X.509 certificates stored in the `certificate_data` column of `Cartridge_Security` table. No separate public key distribution mechanism is required.

2. **Public Key Extraction:** Use Qt's `QSslCertificate::publicKey()` method to extract the public key from the certificate on-demand during signature verification. Public keys are not stored persistently in the Reader.

3. **Fingerprint Verification:** Calculate fingerprint of extracted public key and compare with stored `public_key_fingerprint` to detect certificate tampering. Fingerprint mismatch results in cartridge rejection.

4. **Key Rotation:** Each cartridge is self-contained and independent. New cartridges can use new certificates while old cartridges remain valid with their original certificates. No cross-cartridge key management is required.

5. **Storage:** No persistent public key storage in Reader - keys are extracted fresh from certificates for each verification. Public keys are embedded in certificates stored within cartridges.

**Consequences:**
* **Positive:** Self-contained cartridges (no external dependencies), tamper-resistant (fingerprint verification), follows PKI best practices, simple implementation
* **Negative:** No key revocation mechanism (by design for offline operation), compromised keys cannot invalidate existing cartridges
* **Neutral:** Each cartridge is immutable once signed, key rotation handled by signing new cartridges with new certificates

**Requirements Updated:**
* Updated signature verification algorithm (Phase 1) to include public key extraction from certificate (Step 3) and fingerprint verification (Step 4)
* Updated trust level assignment (Phase 2) to reject cartridges with fingerprint mismatch or missing public key

**DDD Specifications Added:**
* **Section:** "Public Key Extraction and Fingerprint Verification" with:
  * Public key source (extract from certificate)
  * Public key extraction process (certificate parsing, key extraction, usage)
  * Fingerprint verification (calculation, comparison, mismatch handling)
  * Public key storage (no persistent storage in Reader, embedded in cartridge)
  * Key rotation and updates (cartridge independence, certificate expiration, key compromise)
  * Security considerations (advantages, limitations, fingerprint verification benefits)

**Status:** [OK] RESOLVED - Fully specified in DDD

=== ADR 023: Content Hash Algorithm Specification

**Date:** 2025-12-14

**Context:** DDD referenced H1 and H2 hashes but lacked detailed specification for the hash algorithm, which tables to include, and the exact calculation process. The specification said "e.g., SHA-256" without committing to a specific algorithm, and "critical content tables" was not fully defined.

**Decision:**
1. **Hash Algorithm:** SHA-256 (256-bit Secure Hash Algorithm) - specified as the exact algorithm for Phase 1. Rationale: Strong security (256-bit output), efficient performance, widely supported, future-proof.

2. **Tables Included in Hash:**

   * **Content_Pages** - Primary content (HTML pages)
   * **Embedded_Apps** - Embedded JavaScript applications (critical attack surface)
   * **Form_Definitions** - Form schemas and validation rules
   * **Settings** - Author-defined rendering defaults
   * **Content_Themes** - Theme configurations
   * **Metadata** (partial) - Author metadata fields (excludes `cartridge_guid`)

3. **Tables Excluded:**

   * **User_Data** - User input (not part of author content)
   * **Cartridge_Security** - Circular dependency (contains the hash itself)

4. **Hash Calculation Method:** Option A - Concatenate table hashes:

   * Hash each table independently (rows ordered by primary key, columns in alphabetical order)
   * Concatenate table hashes with table name prefixes (first 4 bytes of SHA-256 of table name)
   * Hash the concatenated result to produce final H1/H2

5. **Deterministic Serialization:**

   * Fixed table order: Content_Pages, Content_Themes, Embedded_Apps, Form_Definitions, Metadata, Settings
   * Fixed row order: By primary key (ascending) within each table
   * Fixed column order: Alphabetical by column name
   * UTF-8 encoding for text, big-endian for integers, raw bytes for BLOBs
   * NULL values: Single byte 0x00
   * Row delimiter: Single newline byte (0x0A)

6. **Empty Table Handling:** Include empty tables in hash (hash of empty byte array) to detect table addition/removal.

**Consequences:**
* **Positive:** Complete, implementable specification; covers all attack surfaces (especially Embedded_Apps); deterministic and reproducible; cryptographically secure
* **Negative:** More complex than single-pass hashing (but provides better debugging and verification capabilities)
* **Neutral:** SHA-256 is standard and well-supported; algorithm is deterministic but requires careful implementation

**Requirements Updated:**
* Updated `digest_type` column description to specify "SHA-256" for Phase 1
* Updated signature verification algorithm (Phase 1, Step 2) to reference Content Hash Algorithm Specification
* Updated Creator Tool packaging algorithm (Phase 2) to reference Content Hash Algorithm Specification

**DDD Specifications Added:**
* **Section:** "Content Hash Algorithm Specification" with:
  * Hash algorithm (SHA-256) with rationale
  * Tables included/excluded with rationale
  * Hash calculation algorithm (Option A: Concatenate table hashes)
  * Table ordering (fixed order)
  * Row ordering (by primary key)
  * Row serialization (column order, value encoding, delimiters)
  * Empty table handling
  * Hash calculation pseudocode
  * Verification process (H1 vs H2)
  * Security considerations (attack surface coverage, collision resistance, deterministic calculation)

**Status:** [OK] RESOLVED - Fully specified in DDD

=== ADR 024: JavaScript Security Sandbox and API Restrictions

**Date:** 2025-12-14

**Context:** Embedded JavaScript execution was mentioned but lacked detailed specification for JavaScript security sandbox, which APIs should be available/restricted, CSP configuration, and how to prevent access to file system, network, etc.

**Decision:**
1. **Qt WebEngine Native Sandboxing:** Leverage Qt WebEngine's built-in process isolation (separate renderer processes) and V8 JavaScript engine isolation. Each embedded app runs in its own QWebEngineView instance for complete isolation.

2. **Network API Restrictions:** Block all network APIs (fetch, XMLHttpRequest, WebSocket, EventSource, external resource loading) via QWebEngineUrlRequestInterceptor (primary defense) and CSP headers (secondary defense).

3. **File System API Restrictions:** Block direct file system APIs (File System Access API, FileReader for local files). All file operations must use WebChannel sandbox API, which enforces path validation and sandbox boundaries.

4. **Storage APIs:** Allow localStorage, sessionStorage, and IndexedDB (isolated per app instance, no security risk).

5. **Clipboard APIs:** Allow navigator.clipboard APIs (safe for UX, users control clipboard content).

6. **Device Access APIs:** Block geolocation, getUserMedia, battery, vibrate APIs (not needed for local apps, privacy/security risks).

7. **Window/Navigation APIs:** Block external navigation (window.open, window.location to external URLs), allow internal navigation (SPA routing).

8. **Communication APIs:** Block cross-origin communication, allow same-origin (postMessage, BroadcastChannel within app).

9. **Worker APIs:** Allow Web Workers (performance), block SharedWorkers (not needed, security risk).

10. **Evaluation APIs:** Allow eval and Function constructor (required for SPAs), controlled via CSP.

11. **WebAssembly APIs:** Allow compile/instantiate, block streaming APIs (require network).

12. **Notification APIs:** Allow Notification API (safe, useful for UX).

13. **CSP Configuration:** Strict CSP header with connect-src 'none', default-src 'self', script-src with unsafe-inline/unsafe-eval for SPA support.

14. **Network Request Interceptor:** Custom QWebEngineUrlRequestInterceptor implementation to block all HTTP/HTTPS requests, allow only data:, blob:, and file: URLs.

**Consequences:**
* **Positive:** Complete security specification, defense in depth approach, leverages Qt WebEngine native sandboxing, clear API restrictions, implementable CSP configuration
* **Negative:** Some SPA frameworks may require unsafe-inline/unsafe-eval (reduces CSP effectiveness, but network interceptor provides primary defense)
* **Neutral:** CSP is secondary defense layer, network interceptor is primary defense

**Requirements Updated:**
* No new requirements added (security implementation detail)

**DDD Specifications Added:**
* **Section:** "JavaScript Security Sandbox and API Restrictions" with:
  * Qt WebEngine native sandboxing capabilities
  * Network API restrictions (blocked APIs, implementation)
  * File system API restrictions (blocked/allowed APIs, rationale)
  * Storage API restrictions (allowed APIs, rationale)
  * Clipboard API restrictions (allowed APIs, rationale)
  * Device access API restrictions (blocked APIs, rationale)
  * Window/navigation API restrictions (blocked/allowed APIs, rationale)
  * Communication API restrictions (blocked/allowed APIs, rationale)
  * Worker API restrictions (allowed/blocked APIs, rationale)
  * Evaluation API restrictions (allowed APIs, CSP configuration)
  * WebAssembly API restrictions (allowed/blocked APIs, rationale)
  * Notification API restrictions (allowed APIs, rationale)
  * CSP configuration (complete CSP header with explanations)
  * Network request interceptor implementation (code structure)
  * Security layers summary (defense in depth approach)

**Status:** [OK] RESOLVED - Fully specified in DDD

=== ADR 025: Form Versioning and Data Migration

**Date:** 2025-12-14

**Context:** Form data persistence was specified, but there was no handling for form schema changes, migration strategy for user data, or versioning of saved form data. If a form definition changes significantly, stored user data could become invalid.

**Decision:**
1. **Form Versioning:** Add `form_version` column to `Form_Definitions` table. Version starts at 1, incremented on breaking changes (field removed/renamed/type changed, validation rules changed significantly). Non-breaking changes (field added, label changed) don't require version increment.

2. **Data Version Tracking:** Add `form_version` and `migrated_from_version` columns to `User_Data` table to track which version of form schema the data was saved with, and whether data was migrated from an older version.

3. **Migration Rules:** Add `migration_rules_json` column to `Form_Definitions` table for storing field mapping and transformation rules when migrating data from previous versions.

4. **Form Page Structure:** Forms SHALL be placed on dedicated content pages (not intermingled with content text). Form pages contain only the form marker element. Form builder output is injected at designated points. If form page exists, form builder can overwrite it with updated form.

5. **Form Builder Version Management:** Extend Form Builder with version management UI (current version display, version increment, version history), migration mapping interface (field mapping, transformation rules, preview), and version increment workflow (detect breaking changes, prompt for version increment, define migration rules).

6. **Migration Algorithm:** Automatic migration for compatible changes (same fieldId fields copied, new fields get defaults), explicit migration rules for breaking changes (field mappings, transformations), migration validation against new schema, user notification when migration occurs.

7. **Migration Rules JSON Structure:** Complete JSON specification for field mappings (rename, remove, transform, copy actions), new field defaults, version range (fromVersion, toVersion).

8. **Security Considerations:** Validate migration rules JSON structure, validate field mappings reference valid fields, validate transformation rules (prevent code injection), sanitize default values, always validate migrated data against new schema, prevent version downgrades, log all migration operations.

**Consequences:**
* **Positive:** Preserves user data across form updates, clear form management workflow, dedicated form pages improve UX, migration rules provide flexibility for complex changes, version tracking enables audit trail
* **Negative:** Adds complexity to form builder and data loading, migration rules must be carefully defined, breaking changes require migration rules (can't be fully automatic)
* **Neutral:** Forms on dedicated pages may require restructuring existing content, migration adds overhead to data loading (but only when versions don't match)

**Requirements Updated:**
* Updated `Form_Definitions` table schema to include `form_version` and `migration_rules_json` columns
* Updated `User_Data` table schema to include `form_version` and `migrated_from_version` columns
* Updated form data persistence (save/load) to include version tracking and migration
* Extended Form Builder requirements (FR-CT-3.17) to include version management and migration mapping

**DDD Specifications Added:**
* **Section:** "Form Versioning and Data Migration" with:
  * Form versioning strategy (version number, increment triggers, version tracking)
  * Form page structure (dedicated form pages, form embedding, rationale)
  * Form Builder version management (version management UI, version increment workflow, migration mapping interface)
  * Migration rules JSON structure (complete JSON schema with field mappings, actions, transformations)
  * Form data migration algorithm (migration process, automatic migration, migration validation, data saving)
  * Migration security considerations (input validation, data validation, version integrity, user consent)
  * Form Builder migration interface specification (migration mapping dialog, migration preview, version history)

**Status:** [OK] RESOLVED - Fully specified in DDD

=== ADR 026: Manifest Update Lifecycle and Error Handling

**Date:** 2025-12-14

**Context:** DDD mentioned manifest updates but lacked clarity on when manifests are updated, what happens if updates fail, and how to handle errors. Two different types of manifests exist with different update cycles and failure modes.

**Decision:**
1. **Two Types of Manifests Clarified:**

   * **Embedded App Manifest** (`Embedded_App_Manifest` JSON): Created/updated when cartridge is created/updated by Creator Tool, stored in `Embedded_Apps.manifest_json` column within cartridge database
   * **Local Library Manifest** (`Local_Library_Manifest` table): Updated when cartridge is added/updated/removed from library, stored in Reader's local database (`local_reader.sqlite`)

2. **Local Library Manifest Update Triggers:**

   * On cartridge import (new cartridge added to library)
   * On cartridge open (content hash H2 recalculated, manifest updated)
   * On cartridge update (cartridge detected at new path or with changed content)
   * On cartridge deletion (manifest entry removed)

3. **Error Handling Strategy:**

   * **Embedded App Manifest Errors:** Display error dialog in Creator Tool with operation type, app ID, error message, context, and suggested resolution. Include "Copy Error Details" button for debugging. Allow retry or cancel.
   * **Local Library Manifest Errors:** Display error dialog in Reader with operation type, cartridge info, error message, context (database path, SQLite error code), and suggested resolution. Include "Copy Error Details" button for debugging. Operations continue (non-blocking), retry on next launch.

4. **Error Dialog Requirements:** Both error dialogs must include sufficient information to reproduce and debug failures:

   * Operation type (create/update/delete)
   * Affected resource (app ID or cartridge GUID)
   * Error type (brief description)
   * Detailed error message
   * Context (paths, timestamps, error codes)
   * Suggested resolution steps
   * "Copy Error Details" button for debugging

5. **Common Error Scenarios:**

   * **Embedded App Manifest:** JSON validation errors, schema validation errors, database write errors
   * **Local Library Manifest:** Disk space exhaustion, file permissions, database locked, database corruption, path issues

**Consequences:**
* **Positive:** Clear distinction between two manifest types, comprehensive error handling, user-friendly error dialogs with debugging information, non-blocking behavior for library operations
* **Negative:** Error dialogs add complexity to UI, users may see error dialogs for background operations
* **Neutral:** Error handling is essential for robust operation, debugging information helps users and developers

**Requirements Updated:**
* Updated signature verification algorithm to reference manifest update error handling
* Extended error handling requirements to include manifest-specific error dialogs

**DDD Specifications Added:**
* **Section:** "Manifest Update Error Handling" with:
  * Clarification of two manifest types (Embedded App Manifest vs Local Library Manifest)
  * Creator Tool: Embedded App Manifest error handling (when created/updated, error scenarios, error dialog requirements, example, logging)
  * Reader: Local Library Manifest error handling (when updated, error scenarios, error handling strategy, error dialog requirements, example, logging, retry strategy, non-blocking behavior)

**Status:** [OK] RESOLVED - Fully specified in DDD

=== ADR 027: Database Migration Strategy

**Date:** 2025-12-14

**Context:** No specification existed for cartridge format version migration, Reader database schema migration, or handling older format cartridges. This is essential for maintaining backward compatibility and supporting future schema changes.

**Decision:**
1. **Cartridge Format Version Migration:**

   * Version stored in `Metadata.schema_version` field (e.g., "1.0")
   * Reader detects version on cartridge open and compares with supported versions
   * Backward compatibility: Reader supports all previous format versions, migration performed in-memory (cartridge files remain read-only)
   * Forward compatibility: Reader detects newer format versions and displays error requiring application update
   * Migration process: Version detection, compatibility check, in-memory transformation, validation
   * Format version numbering: MAJOR.MINOR (MAJOR for breaking changes, MINOR for non-breaking)
   * Migration transformations: Table schema migrations (add/remove/rename columns, add/remove tables, data type changes), data transformations (JSON structure changes, encoding changes, default values)
   * Migration error handling: Error dialogs with details, logging, partial migration warnings, validation

2. **Reader Local Database Schema Migration:**

   * Version tracking via `_schema_version` table in local database
   * Migration on startup: Version detection, migration path determination, backup creation, sequential transformations, version update, validation
   * Migration transformations: Add/remove columns (using table recreation for SQLite limitations), add/remove tables, modify constraints
   * Migration backup: Automatic backup before migration (`local_reader.sqlite.backup`), restore on failure
   * Migration error handling: Restore from backup on failure, error dialogs, validation, user notification
   * Schema version history: Version 1.0 (Phase 1) documented, future versions to be documented as introduced

3. **Handling Older Format Cartridges:**

   * Detection via `schema_version` field
   * Loading strategy: Supported older versions (migrate and load), unsupported older versions (error message), newer versions (error requiring app update)
   * User experience: Transparent automatic migration, notification only on failure or unsupported format
   * Creator Tool compatibility: Can open/migrate older formats, can save in current format, optional save in older formats for testing

**Consequences:**
* **Positive:** Backward compatibility maintained, forward compatibility handled gracefully, automatic migration provides seamless user experience, backup strategy protects user data, version tracking enables audit trail
* **Negative:** Migration adds complexity to Reader startup, migration code must be maintained for all previous versions, migration failures require error handling and recovery
* **Neutral:** Migration is essential for long-term maintenance, in-memory migration preserves original cartridge files, backup strategy adds disk space overhead

**Requirements Updated:**
* No new requirements added (migration is implementation detail, but may require future requirements for migration UI)

**DDD Specifications Added:**
* **Section:** "Database Migration Strategy" with:
  * Cartridge format version migration (version detection, migration strategy, format version changes, migration transformations, migration error handling)
  * Reader local database schema migration (version tracking, migration process, migration transformations, migration backup, migration error handling, schema version history)
  * Handling older format cartridges (detection, loading strategy, user experience, Creator Tool compatibility)

**Status:** [OK] RESOLVED - Fully specified in DDD

=== ADR 028: Cartridge Import Process Specification

**Date:** 2025-12-14

**Context:** Import functionality was mentioned but not detailed. No specification existed for import mechanisms (drag-drop, file picker), import progress indication, storage location strategy, or duplicate handling.

**Decision:**
1. **Import Mechanisms:**

   * **Drag-and-Drop:** Support dragging `.sqlite` files onto Library Manager window, visual feedback for drop target, accepts `.sqlite` files, rejects non-cartridge files
   * **File Picker Dialog:** Menu item (File  Import) or toolbar button, native file picker (Qt QFileDialog), supports single or multiple file selection, file filter for SmartBook cartridges

2. **Import Storage Location:**

   * **Default Directory:** Follow OS standards (Windows: `%USERPROFILE%\Documents\SmartBook\Library\`, macOS/Linux: `~/Documents/SmartBook/Library/`)
   * **User Configuration:** Users can configure custom library directory via settings, preference persists across sessions, fallback to default if custom directory inaccessible
   * **Storage Strategy:** Imported cartridges copied to library directory, flat directory structure (no subdirectories), original filename preserved (or renamed if duplicate)

3. **Import Progress Dialog:**

   * Progress bar showing overall progress (percentage or file count)
   * Status text for current operation
   * File list with status indicators (pending, in progress, completed, failed)
   * Cancel button to abort import

4. **Duplicate Detection and Handling:**

   * Detect duplicates by comparing `cartridge_guid` from `Metadata` table
   * Display confirmation dialog with existing and new cartridge information (title, author, file path, size, modification date)
   * User options: Replace (delete old, import new, update manifest, preserve trust/settings/bookmarks), Skip (abort import), Keep Both (rename new file, import as separate entry)
   * Checkbox for batch handling ("Apply this choice to all duplicates")

5. **Import Validation:**

   * File format validation (SQLite database, required tables)
   * Schema validation (Metadata table, cartridge_guid, schema_version)
   * Version compatibility check (supported format versions)
   * Metadata extraction (title, author, publication_year, cover image)
   * Error dialogs for validation failures

6. **Import Workflow Algorithm:**

   * Complete step-by-step algorithm: file selection, progress dialog display, process each file (validate, check duplicate, copy file, extract metadata, create manifest entry), completion, error summary

7. **Import Error Handling:**

   * File access errors (not found, permission denied, disk full)
   * Database errors (invalid format, locked, corruption)
   * Manifest update errors (non-blocking, retry later)
   * Comprehensive logging (INFO for operations, WARN for validation errors, ERROR for file errors)

**Consequences:**
* **Positive:** Clear import workflow, user-friendly progress indication, flexible duplicate handling, comprehensive validation, follows OS standards for storage location
* **Negative:** Import progress dialog adds UI complexity, duplicate handling requires user decision (may slow batch imports), file copying adds time to import process
* **Neutral:** Storage location follows OS standards but allows user customization, import validation ensures data integrity but may reject valid files if validation is too strict

**Requirements Added:**
* **FR-2.5.6:** Import mechanisms (drag-drop, file picker dialog)
* **FR-2.5.7:** Import storage location (default OS standard, user-configurable)
* **FR-2.5.8:** Import progress indication (progress dialog with status, file list, cancel button)
* **FR-2.5.9:** Duplicate detection (compare cartridge_guid, confirmation dialog with Replace/Skip/Keep Both options)
* **FR-2.5.10:** Import validation (file format, schema, version compatibility, metadata extraction)
* **FR-2.5.11:** Import completion (copy file, extract metadata, create manifest entry, refresh library view)

**DDD Specifications Added:**
* **Section:** "Cartridge Import Process Specification" with:
  * Import mechanisms (drag-and-drop, file picker dialog)
  * Import storage location (default directory, user configuration, storage strategy)
  * Import progress dialog (components, progress updates, cancel behavior)
  * Duplicate detection and handling (detection, confirmation dialog, replace/skip/keep both operations)
  * Import validation (validation steps, error handling)
  * Import workflow algorithm (complete step-by-step process)
  * Import error handling (file access errors, database errors, manifest update errors, logging)

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

=== ADR 029: Reader View Window Management Specification

**Date:** 2025-12-14

**Context:** Multi-window architecture was specified, but no details existed for how users open windows, window closing behavior, window state persistence (size, position), or minimize/restore behavior. Users need intuitive window management following platform conventions.

**Decision:**
1. **Window Opening Mechanisms:**

   * **Double-Click:** Double-clicking cartridge title (List View) or cover (Grid View) opens cartridge in new Reader View Window
   * **Context Menu:** Right-clicking cartridge title or cover displays context menu with "Open" option
   * **Platform Conventions:** Follow established e-book application patterns (Calibre, Apple Books, Adobe Digital Editions)
   * Visual feedback on double-click, immediate window opening (no confirmation dialog)

2. **Window State Persistence:**

   * **New Table:** `Local_Window_State` table stores window geometry (width, height, x, y), maximized state, and last updated timestamp per cartridge
   * **Save Trigger:** Window state saved when Reader View Window is closed (user closes window or application quits)
   * **Components Saved:** Window size, window position, maximized state, reading position (in `Local_Reading_Position` table)
   * **Atomic Save:** Window state and reading position saved in same transaction

3. **Window State Restoration:**

   * **Restore Trigger:** When cartridge is opened, query `Local_Window_State` and `Local_Reading_Position` tables
   * **Restore Components:** Window size, window position, maximized state, reading position (page, anchor, scroll)
   * **Validation:** Validate saved geometry (screen bounds, reasonable size), fallback to defaults if invalid
   * **Default Geometry:** 1024x768 pixels centered on screen (or 80% of screen size)
   * **Multi-Monitor Handling:** If saved position on non-existent monitor, move to primary monitor and center

4. **Window Minimize/Restore:**

   * Follow standard OS conventions (Windows taskbar, macOS Dock, Linux taskbar/panel)
   * Use Qt standard window management (`showMinimized()`, `showNormal()`, `showMaximized()`)
   * Minimized state NOT persisted (transient), normal/maximized state IS persisted
   * Window state transitions: Normal  Minimized, Normal  Maximized, Maximized  Minimized

5. **Window Closing Behavior:**

   * User-initiated close (close button, File  Close, keyboard shortcut): Save window state and reading position, then close
   * Application quit: Save state for all open windows, then close all windows
   * No confirmation dialog by default (follows platform conventions)
   * Each window saves state independently

**Consequences:**
* **Positive:** Intuitive window opening (double-click, context menu), automatic state persistence, seamless restoration, follows platform conventions, familiar UX from other e-book apps
* **Negative:** Window state table adds database complexity, state validation required for multi-monitor setups, save operations on every close (minimal overhead)
* **Neutral:** Window state persistence is expected behavior for modern applications, reading position already persisted (extended to include window geometry)

**Requirements Added:**
* **FR-2.1.2:** Window opening (double-click, context menu, platform conventions)
* **FR-2.1.3:** Window state persistence (size, position, maximized state, reading position)
* **FR-2.1.4:** Window state restoration (size, position, reading position, defaults)
* **FR-2.1.5:** Window minimize/restore (standard OS behavior)

**DDD Specifications Added:**
* **New Table:** `Local_Window_State` table schema (state_id, cartridge_guid, window_width, window_height, window_x, window_y, is_maximized, last_updated)
* **Section:** "Application Architecture and Window Management" extended with:
  * Window opening mechanisms (double-click, context menu, platform conventions)
  * Window state persistence (components, save algorithm, validation)
  * Window state restoration (restore algorithm, default geometry, multi-monitor handling)
  * Window minimize/restore behavior (standard OS behavior, state transitions)
  * Window closing behavior (user-initiated close, application quit, multiple windows)

**Status:** [OK] RESOLVED - Fully specified in DDD and SRS

