= SQLite Configuration Specification
:author: AI Assistant
:revdate: 2025-12-14
:doctype: article
:toc: left
:toclevels: 3
:sectnums:

== Introduction

This document specifies the SQLite configuration requirements, design, and testing for the Smartbook Reader and Creator Tool applications. SQLite is used as the core persistence engine for both cartridge files (content storage) and the local reader database (manifest and trust registry).

== Requirements (SRS)

=== SQLite Version and Compatibility

* **FR-SQL-6.1 (Minimum SQLite Version):** The Reader and Creator Tool SHALL require SQLite version 3.51 or higher. The application SHALL detect the SQLite version at runtime and SHALL display an error if the version is insufficient.

* **FR-SQL-6.2 (Version Detection):** The Reader and Creator Tool SHALL detect and log the SQLite version at application startup. The version information SHALL be available in application logs and optionally in the About dialog.

=== WAL Mode Configuration

* **FR-SQL-6.3 (WAL Mode for Local Database):** The Reader SHALL configure the local reader database (`local_reader.sqlite`) to use Write-Ahead Logging (WAL) mode. WAL mode SHALL be enabled immediately after database creation or on first connection to existing databases.

* **FR-SQL-6.4 (WAL Mode for Cartridge Files):** The Creator Tool SHALL configure cartridge files to use WAL mode during creation and editing. Cartridge files exported for distribution MAY use WAL mode or rollback journal mode (design decision: WAL for better performance, rollback journal for maximum compatibility).

* **FR-SQL-6.5 (WAL Checkpoint Configuration):** The Reader and Creator Tool SHALL configure automatic WAL checkpointing with appropriate thresholds. WAL checkpoint SHALL occur when WAL file size exceeds 10MB or when 1000 pages are written, whichever comes first.

* **FR-SQL-6.6 (WAL Mode Detection):** The Reader SHALL detect if an existing database is not in WAL mode and SHALL automatically convert it to WAL mode on first access (if writable) or SHALL log a warning (if read-only).

=== Database Optimization

* **FR-SQL-6.7 (Page Size Configuration):** The Reader and Creator Tool SHALL configure SQLite page size to 4096 bytes (4KB) for optimal performance on modern systems. Page size SHALL be set at database creation time and SHALL NOT be changed for existing databases.

* **FR-SQL-6.8 (Cache Size Configuration):** The Reader and Creator Tool SHALL configure SQLite cache size to appropriate values:
  a. Local reader database: 2000 pages (8MB with 4KB pages)
  b. Cartridge files: 1000 pages (4MB with 4KB pages)
  c. Cache size SHALL be set per connection

* **FR-SQL-6.9 (Synchronous Configuration):** The Reader and Creator Tool SHALL configure synchronous mode to `NORMAL` for databases using WAL mode. Synchronous mode SHALL NOT be set to `OFF` (data integrity risk).

* **FR-SQL-6.10 (Journal Mode Configuration):** The Reader and Creator Tool SHALL configure journal mode to `WAL` for all databases. For read-only cartridge files, journal mode detection SHALL be performed but conversion SHALL NOT be attempted.

* **FR-SQL-6.11 (Foreign Key Constraints):** The Reader and Creator Tool SHALL enable foreign key constraints for all databases. Foreign key enforcement SHALL be enabled per connection using `PRAGMA foreign_keys = ON`.

* **FR-SQL-6.12 (Query Optimizer):** The Reader and Creator Tool SHALL enable the SQLite query optimizer statistics. Statistics SHALL be updated using `ANALYZE` after significant data changes (e.g., after import, after bulk operations).

* **FR-SQL-6.13 (Index Optimization):** The Reader and Creator Tool SHALL ensure all frequently queried columns have appropriate indexes. Indexes SHALL be created as specified in the database schema (DDD Section 3 and 4).

* **FR-SQL-6.14 (Vacuum and Optimization):** The Reader SHALL provide functionality to optimize the local reader database. Optimization SHALL include `VACUUM` and `ANALYZE` operations. Optimization MAY be performed automatically during idle time or manually via user action.

=== Connection Management

* **FR-SQL-6.15 (Connection Pooling):** The Reader SHALL manage database connections efficiently:
  a. Local database: Single connection (Singleton pattern via `LocalDBManager`)
  b. Cartridge files: One connection per open cartridge (Per-Instance pattern via `CartridgeDBConnector`)
  c. Connections SHALL be opened on-demand and closed when no longer needed

* **FR-SQL-6.16 (Connection Timeout):** The Reader and Creator Tool SHALL configure connection timeouts appropriately:
  a. Default timeout: 30 seconds
  b. Retry logic with exponential backoff for locked databases
  c. Maximum 3 retry attempts

* **FR-SQL-6.17 (Busy Handler):** The Reader and Creator Tool SHALL configure SQLite busy handler to handle database lock contention gracefully. Busy handler SHALL wait up to 5 seconds with exponential backoff before returning SQLITE_BUSY error.

=== Transaction Management

* **FR-SQL-6.18 (Transaction Usage):** The Reader and Creator Tool SHALL use transactions for all multi-step database operations to ensure atomicity and data integrity. Transactions SHALL be used for:
  a. Form data saves
  b. Manifest updates
  c. Trust registry updates
  d. Cartridge deletions
  e. Bulk imports

* **FR-SQL-6.19 (Transaction Isolation):** The Reader and Creator Tool SHALL use appropriate transaction isolation levels. SQLite's default isolation (SERIALIZABLE) SHALL be used. Explicit locking SHALL be avoided unless necessary.

* **FR-SQL-6.20 (Savepoint Support):** The Creator Tool SHALL use savepoints for complex operations that may need partial rollback (e.g., form version migration, multi-step imports).

=== Error Handling and Recovery

* **FR-SQL-6.21 (Integrity Checks):** The Reader SHALL perform periodic integrity checks on databases:
  a. On cartridge open: Quick integrity check (`PRAGMA quick_check`)
  b. On corruption suspicion: Full integrity check (`PRAGMA integrity_check`)
  c. Integrity check results SHALL be logged

* **FR-SQL-6.22 (Corruption Recovery):** The Reader and Creator Tool SHALL attempt recovery from database corruption when possible:
  a. Use `.dump` and `.read` for recovery
  b. Recover as much data as possible
  c. Log recovery attempts and results
  d. Notify user of corruption and recovery status

* **FR-SQL-6.23 (Backup and Restore):** The Reader SHALL create automatic backups of the local reader database before major operations (e.g., schema migrations). Backups SHALL be stored in a backup directory and SHALL be retained for 7 days.

== Design Specification (DDD)

=== SQLite Version Requirements

**Minimum Version:** SQLite 3.51

**Rationale:**
* SQLite 3.51 (released 2024) includes important bug fixes and performance improvements
* WAL mode improvements and checkpoint optimizations
* Better handling of large databases
* Enhanced foreign key constraint support

**Version Detection:**
[source,cpp]
----
QString sqliteVersion = QSqlDatabase::database().driver()->property("SQLiteVersion").toString();
qInfo() << "SQLite version:" << sqliteVersion;

// Check minimum version
QStringList versionParts = sqliteVersion.split(".");
if (versionParts.size() >= 2) {
    int major = versionParts[0].toInt();
    int minor = versionParts[1].toInt();
    if (major < 3 || (major == 3 && minor < 51)) {
        qCritical() << "SQLite version" << sqliteVersion << "is below minimum required version 3.51";
        // Display error to user
    }
}
----

**Version Documentation:**
* Log SQLite version at application startup
* Include version in About dialog (optional)
* Document version in application logs

=== WAL Mode Configuration

==== WAL Mode Overview

**Write-Ahead Logging (WAL) Benefits:**
* Better concurrency (readers don't block writers)
* Improved performance for mixed read/write workloads
* Reduced lock contention
* Better for multi-threaded applications

**WAL Mode Trade-offs:**
* Slightly larger database files (WAL file)
* Requires checkpointing to maintain size
* May not be compatible with very old SQLite versions (but 3.51+ supports it)

==== WAL Mode Implementation

**Enable WAL Mode:**

[source,cpp]
----
void LocalDBManager::enableWALMode() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Check current journal mode
    if (query.exec("PRAGMA journal_mode")) {
        if (query.next()) {
            QString mode = query.value(0).toString().toUpper();
            if (mode != "WAL") {
                // Enable WAL mode
                if (query.exec("PRAGMA journal_mode=WAL")) {
                    qInfo() << "WAL mode enabled for local database";
                } else {
                    qWarning() << "Failed to enable WAL mode:" << query.lastError();
                }
            } else {
                qInfo() << "Database already in WAL mode";
            }
        }
    }
}
----

**WAL Checkpoint Configuration:**

[source,cpp]
----
void LocalDBManager::configureWALCheckpoint() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Set WAL autocheckpoint threshold (1000 pages = ~4MB with 4KB pages)
    if (!query.exec("PRAGMA wal_autocheckpoint=1000")) {
        qWarning() << "Failed to set WAL autocheckpoint:" << query.lastError();
    }
    
    // Alternatively, use size-based checkpointing
    // Check WAL file size periodically and checkpoint if > 10MB
}
----

**Manual Checkpoint:**

[source,cpp]
----
void LocalDBManager::performWALCheckpoint() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Perform checkpoint (truncates WAL file)
    if (query.exec("PRAGMA wal_checkpoint(TRUNCATE)")) {
        qInfo() << "WAL checkpoint completed";
    } else {
        qWarning() << "WAL checkpoint failed:" << query.lastError();
    }
}
----

**WAL File Size Monitoring:**

[source,cpp]
----
qint64 LocalDBManager::getWALFileSize() {
    QString dbPath = QSqlDatabase::database().databaseName();
    QString walPath = dbPath + "-wal";
    QFileInfo walFile(walPath);
    if (walFile.exists()) {
        return walFile.size();
    }
    return 0;
}

void LocalDBManager::checkWALSize() {
    qint64 walSize = getWALFileSize();
    if (walSize > 10 * 1024 * 1024) { // 10MB
        qInfo() << "WAL file size:" << walSize << "bytes, performing checkpoint";
        performWALCheckpoint();
    }
}
----

==== WAL Mode for Cartridge Files

**Creator Tool - WAL Mode:**

[source,cpp]
----
void CartridgeDBConnector::enableWALMode() {
    QSqlDatabase db = database();
    QSqlQuery query(db);
    
    // Enable WAL mode for cartridge being edited
    if (query.exec("PRAGMA journal_mode=WAL")) {
        qInfo() << "WAL mode enabled for cartridge";
    }
}
----

**Export Consideration:**
* **Option A:** Keep WAL mode in exported cartridges (better performance, requires SQLite 3.7.0+)
* **Option B:** Convert to rollback journal before export (maximum compatibility)
* **Recommendation:** Keep WAL mode (SQLite 3.51+ is required, so compatibility is ensured)

=== Database Optimization Configuration

==== Page Size Configuration

**Page Size: 4096 bytes (4KB)**

**Rationale:**
* 4KB is optimal for modern systems (matches OS page size)
* Good balance between performance and memory usage
* Standard size for most SQLite databases

**Implementation:**

[source,cpp]
----
void LocalDBManager::createDatabase() {
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", "LocalDB");
    db.setDatabaseName(localDatabasePath());
    
    if (!db.open()) {
        qCritical() << "Failed to open local database";
        return;
    }
    
    QSqlQuery query(db);
    
    // Set page size (must be done before creating tables)
    if (!query.exec("PRAGMA page_size=4096")) {
        qWarning() << "Failed to set page size:" << query.lastError();
    }
    
    // Create schema...
}
----

**Note:** Page size can only be set for new databases. Existing databases retain their original page size.

==== Cache Size Configuration

**Cache Size Settings:**

[source,cpp]
----
void LocalDBManager::configureCache() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Set cache size to 2000 pages (8MB with 4KB pages)
    if (!query.exec("PRAGMA cache_size=-2000")) {
        qWarning() << "Failed to set cache size:" << query.lastError();
    }
}

void CartridgeDBConnector::configureCache() {
    QSqlDatabase db = database();
    QSqlQuery query(db);
    
    // Set cache size to 1000 pages (4MB with 4KB pages)
    if (!query.exec("PRAGMA cache_size=-1000")) {
        qWarning() << "Failed to set cache size:" << query.lastError();
    }
}
----

**Cache Size Rationale:**
* Negative value = pages (absolute value in KB)
* Local database: 2000 pages (8MB) - larger cache for frequently accessed manifest data
* Cartridge files: 1000 pages (4MB) - smaller cache per cartridge, multiple cartridges may be open

==== Synchronous Configuration

**Synchronous Mode: NORMAL (for WAL mode)**

**Implementation:**

[source,cpp]
----
void LocalDBManager::configureSynchronous() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Set synchronous mode to NORMAL (safe with WAL mode)
    if (!query.exec("PRAGMA synchronous=NORMAL")) {
        qWarning() << "Failed to set synchronous mode:" << query.lastError();
    }
}
----

**Synchronous Mode Options:**
* `OFF` - Fastest but unsafe (data loss risk on power failure) - **NOT RECOMMENDED**
* `NORMAL` - Safe with WAL mode, good performance - **RECOMMENDED**
* `FULL` - Safest but slower - **NOT NEEDED with WAL mode**

**Rationale:**
* WAL mode provides durability guarantees
* NORMAL mode with WAL is safe and performant
* FULL mode adds unnecessary overhead with WAL

==== Foreign Key Constraints

**Enable Foreign Key Enforcement:**

[source,cpp]
----
void LocalDBManager::enableForeignKeys() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Enable foreign key constraints (must be done per connection)
    if (!query.exec("PRAGMA foreign_keys=ON")) {
        qWarning() << "Failed to enable foreign keys:" << query.lastError();
    }
    
    // Verify foreign keys are enabled
    if (query.exec("PRAGMA foreign_keys")) {
        if (query.next()) {
            int enabled = query.value(0).toInt();
            if (enabled != 1) {
                qWarning() << "Foreign keys not enabled (expected 1, got" << enabled << ")";
            }
        }
    }
}
----

**Foreign Key Benefits:**
* Data integrity enforcement
* Prevents orphaned records
* Automatic referential integrity checks

**Note:** Foreign keys must be enabled per connection (not persistent in database).

==== Query Optimizer Configuration

**Enable Query Optimizer Statistics:**

[source,cpp]
----
void LocalDBManager::updateStatistics() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    // Update query optimizer statistics
    if (!query.exec("ANALYZE")) {
        qWarning() << "Failed to update statistics:" << query.lastError();
    }
}
----

**When to Run ANALYZE:**
* After bulk imports
* After significant data changes
* Periodically (e.g., weekly) for local database
* After schema changes that affect indexes

**Automatic Statistics Update:**
* Run ANALYZE after import operations
* Run ANALYZE after bulk deletes
* Consider running during idle time

=== Connection Configuration

==== Connection Setup

**Local Database Connection:**

[source,cpp]
----
void LocalDBManager::initializeConnection() {
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", "LocalDB");
    db.setDatabaseName(localDatabasePath());
    
    // Set connection options
    db.setConnectOptions("QSQLITE_ENABLE_REGEXP"); // Enable regexp function (optional)
    
    if (!db.open()) {
        qCritical() << "Failed to open local database:" << db.lastError();
        return;
    }
    
    // Configure database settings
    enableWALMode();
    configureCache();
    configureSynchronous();
    enableForeignKeys();
    
    qInfo() << "Local database connection established";
}
----

**Cartridge Database Connection:**

[source,cpp]
----
void CartridgeDBConnector::openCartridge(const QString& filePath) {
    QString connectionName = QString("Cartridge_%1").arg(QUuid::createUuid().toString());
    QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", connectionName);
    db.setDatabaseName(filePath);
    
    if (!db.open()) {
        qCritical() << "Failed to open cartridge:" << db.lastError();
        return;
    }
    
    // Configure database settings (if writable)
    if (isWritable()) {
        enableWALMode();
        configureCache();
        configureSynchronous();
        enableForeignKeys();
    }
    
    qInfo() << "Cartridge database connection established:" << filePath;
}
----

==== Busy Handler Configuration

**Busy Handler Implementation:**

[source,cpp]
----
int busyHandler(void* data, int count) {
    // Exponential backoff: wait 1ms, 2ms, 4ms, 8ms, etc.
    int delayMs = qMin(1000, (1 << qMin(count, 10))); // Max 1 second
    QThread::msleep(delayMs);
    
    // Return 0 to continue waiting, non-zero to abort
    if (count > 5) { // Max 5 retries (~31ms total)
        return 1; // Abort
    }
    return 0; // Continue waiting
}

void LocalDBManager::setBusyHandler() {
    QSqlDatabase db = QSqlDatabase::database();
    // Note: Qt's QSQLITE driver may handle busy automatically
    // For custom handling, may need to use SQLite C API directly
}
----

**Qt SQLite Driver Busy Handling:**
* Qt's QSQLITE driver handles busy automatically with timeout
* Default timeout: 5 seconds
* Can be configured via `QSqlDatabase::setConnectOptions()`

=== Transaction Management

==== Transaction Usage

**Form Data Save Transaction:**

[source,cpp]
----
bool CartridgeDBConnector::saveFormData(const QString& formKey, const QJsonObject& data) {
    QSqlDatabase db = database();
    db.transaction();
    
    try {
        QSqlQuery query(db);
        
        // Delete existing data
        query.prepare("DELETE FROM User_Data WHERE form_key = ?");
        query.addBindValue(formKey);
        if (!query.exec()) {
            throw std::runtime_error("Failed to delete existing data");
        }
        
        // Insert new data
        query.prepare("INSERT INTO User_Data (form_key, serialized_data, timestamp) VALUES (?, ?, ?)");
        query.addBindValue(formKey);
        query.addBindValue(QJsonDocument(data).toJson());
        query.addBindValue(QDateTime::currentDateTime().toSecsSinceEpoch());
        if (!query.exec()) {
            throw std::runtime_error("Failed to insert data");
        }
        
        db.commit();
        return true;
    } catch (...) {
        db.rollback();
        qWarning() << "Transaction rolled back";
        return false;
    }
}
----

**Atomic Cartridge Deletion:**

[source,cpp]
----
bool LocalDBManager::deleteCartridge(const QString& cartridgeGuid) {
    QSqlDatabase db = database();
    db.transaction();
    
    try {
        QSqlQuery query(db);
        
        // Delete from manifest
        query.prepare("DELETE FROM Local_Library_Manifest WHERE cartridge_guid = ?");
        query.addBindValue(cartridgeGuid);
        if (!query.exec()) {
            throw std::runtime_error("Failed to delete from manifest");
        }
        
        // Delete from trust registry
        query.prepare("DELETE FROM Local_Trust_Registry WHERE cartridge_guid = ?");
        query.addBindValue(cartridgeGuid);
        if (!query.exec()) {
            throw std::runtime_error("Failed to delete from trust registry");
        }
        
        db.commit();
        return true;
    } catch (...) {
        db.rollback();
        qWarning() << "Transaction rolled back";
        return false;
    }
}
----

==== Savepoint Usage

**Form Version Migration with Savepoints:**

[source,cpp]
----
bool CartridgeDBConnector::migrateFormData(const QString& formKey, int fromVersion, int toVersion) {
    QSqlDatabase db = database();
    db.transaction();
    
    // Create savepoint
    QSqlQuery query(db);
    if (!query.exec("SAVEPOINT migration")) {
        db.rollback();
        return false;
    }
    
    try {
        // Perform migration steps
        // If any step fails, rollback to savepoint
        // ...
        
        // Release savepoint
        query.exec("RELEASE SAVEPOINT migration");
        db.commit();
        return true;
    } catch (...) {
        // Rollback to savepoint
        query.exec("ROLLBACK TO SAVEPOINT migration");
        db.rollback();
        return false;
    }
}
----

=== Database Maintenance

==== Vacuum Operation

**Vacuum Implementation:**

[source,cpp]
----
void LocalDBManager::vacuumDatabase() {
    QSqlDatabase db = QSqlDatabase::database();
    QSqlQuery query(db);
    
    qInfo() << "Starting VACUUM operation";
    
    if (query.exec("VACUUM")) {
        qInfo() << "VACUUM completed successfully";
        
        // Update statistics after vacuum
        query.exec("ANALYZE");
    } else {
        qWarning() << "VACUUM failed:" << query.lastError();
    }
}
----

**When to Run VACUUM:**
* After large deletions
* Periodically (e.g., monthly) for local database
* When database file size is significantly larger than data size
* User-initiated optimization

**VACUUM Considerations:**
* Requires exclusive database lock
* Can take time for large databases
* Reduces database file size
* Rebuilds database file

==== Integrity Checks

**Quick Integrity Check:**

[source,cpp]
----
bool CartridgeDBConnector::quickIntegrityCheck() {
    QSqlDatabase db = database();
    QSqlQuery query(db);
    
    if (query.exec("PRAGMA quick_check")) {
        if (query.next()) {
            QString result = query.value(0).toString();
            if (result == "ok") {
                return true;
            } else {
                qWarning() << "Quick check failed:" << result;
                return false;
            }
        }
    }
    return false;
}
----

**Full Integrity Check:**

[source,cpp]
----
bool CartridgeDBConnector::fullIntegrityCheck() {
    QSqlDatabase db = database();
    QSqlQuery query(db);
    
    qInfo() << "Starting full integrity check";
    
    if (query.exec("PRAGMA integrity_check")) {
        QStringList errors;
        while (query.next()) {
            QString result = query.value(0).toString();
            if (result == "ok") {
                qInfo() << "Integrity check passed";
                return true;
            } else {
                errors << result;
            }
        }
        
        qCritical() << "Integrity check failed:" << errors;
        return false;
    }
    return false;
}
----

**Integrity Check Strategy:**
* Quick check on cartridge open (fast, catches most issues)
* Full check when corruption is suspected (slower, comprehensive)
* Log all integrity check results

==== Backup and Restore

**Backup Implementation:**

[source,cpp]
----
bool LocalDBManager::backupDatabase(const QString& backupPath) {
    QSqlDatabase db = QSqlDatabase::database();
    QString dbPath = db.databaseName();
    
    // Use SQLite backup API via .backup command
    QSqlQuery query(db);
    QString backupSql = QString(".backup '%1'").arg(backupPath);
    
    // Note: .backup is a command-line tool command
    // For programmatic backup, use SQLite C API or QSqlDatabase::database().backup()
    
    // Alternative: Use VACUUM INTO (SQLite 3.27+)
    QString vacuumSql = QString("VACUUM INTO '%1'").arg(backupPath);
    if (query.exec(vacuumSql)) {
        qInfo() << "Database backed up to:" << backupPath;
        return true;
    } else {
        qWarning() << "Backup failed:" << query.lastError();
        return false;
    }
}
----

**Backup Strategy:**
* Create backup before schema migrations
* Create backup before major operations
* Store backups in backup directory
* Retain backups for 7 days
* Automatic cleanup of old backups

== Testing Specification

=== Functional Testing

==== SQLite Configuration Tests

[cols="1, 2, 4, 3", options="headers"]
|===
^.^| Test Case ID ^.^| Requirement Covered ^.^| Test Steps ^.^| Expected Result (Acceptance Criteria)

| **T-SQL-01** | FR-SQL-6.1 (Minimum Version) | a|
. Launch Reader application.
. Check SQLite version in logs or About dialog.
. Verify version is 3.51 or higher.
| **AC:** SQLite version is detected and logged. Version is 3.51 or higher. Error is displayed if version is insufficient.

| **T-SQL-02** | FR-SQL-6.2 (Version Detection) | a|
. Launch Reader application.
. Check application logs for SQLite version information.
| **AC:** SQLite version is logged at application startup. Version information is available in logs. Version format is correct (e.g., "3.51.0").

| **T-SQL-03** | FR-SQL-6.3 (WAL Mode - Local Database) | a|
. Launch Reader application (first run, creates new database).
. Check journal mode of local database.
. Verify WAL mode is enabled.
| **AC:** Local database is created with WAL mode enabled. Journal mode is "wal". WAL file is created.

| **T-SQL-04** | FR-SQL-6.3 (WAL Mode - Existing Database) | a|
. Launch Reader application with existing local database (not in WAL mode).
. Verify database is converted to WAL mode.
| **AC:** Existing database is automatically converted to WAL mode. Conversion is logged. Database functions correctly after conversion.

| **T-SQL-05** | FR-SQL-6.4 (WAL Mode - Cartridge Files) | a|
. Create new cartridge in Creator Tool.
. Check journal mode of cartridge file.
. Verify WAL mode is enabled.
| **AC:** Cartridge file is created with WAL mode enabled. Journal mode is "wal". WAL file is created alongside cartridge.

| **T-SQL-06** | FR-SQL-6.5 (WAL Checkpoint Configuration) | a|
. Perform multiple write operations on local database.
. Monitor WAL file size.
. Verify checkpoint occurs when threshold is reached.
| **AC:** WAL checkpoint occurs when WAL file exceeds 10MB or 1000 pages written. Checkpoint truncates WAL file. Checkpoint is logged.

| **T-SQL-07** | FR-SQL-6.6 (WAL Mode Detection) | a|
. Create database file not in WAL mode.
. Open database in Reader (read-only).
. Verify detection and logging.
| **AC:** WAL mode is detected. Warning is logged if database is not in WAL mode. Database can still be read (if read-only).

| **T-SQL-08** | FR-SQL-6.7 (Page Size Configuration) | a|
. Create new local database.
. Check page size of database.
. Verify page size is 4096 bytes.
| **AC:** Database is created with page size 4096 bytes. Page size is correctly set. Page size matches specification.

| **T-SQL-09** | FR-SQL-6.8 (Cache Size Configuration) | a|
. Open local database.
. Check cache size setting.
. Open cartridge file.
. Check cache size setting.
| **AC:** Local database cache size is 2000 pages (8MB). Cartridge cache size is 1000 pages (4MB). Cache sizes are correctly configured.

| **T-SQL-10** | FR-SQL-6.9 (Synchronous Configuration) | a|
. Open database in Reader.
. Check synchronous mode setting.
. Verify synchronous mode is NORMAL.
| **AC:** Synchronous mode is set to NORMAL. Setting is correctly configured. Mode is appropriate for WAL mode.

| **T-SQL-11** | FR-SQL-6.10 (Journal Mode Configuration) | a|
. Create new database.
. Check journal mode.
. Verify journal mode is WAL.
| **AC:** Journal mode is set to WAL. Mode is correctly configured. WAL mode is enabled.

| **T-SQL-12** | FR-SQL-6.11 (Foreign Key Constraints) | a|
. Open database.
. Enable foreign key constraints.
. Attempt to insert record violating foreign key constraint.
. Verify constraint is enforced.
| **AC:** Foreign key constraints are enabled. Constraint violations are rejected. Error is returned. Data integrity is maintained.

| **T-SQL-13** | FR-SQL-6.12 (Query Optimizer) | a|
. Perform bulk import operation.
. Run ANALYZE command.
. Execute query that benefits from statistics.
. Measure query performance.
| **AC:** ANALYZE updates query optimizer statistics. Query performance is improved after ANALYZE. Statistics are used by optimizer.

| **T-SQL-14** | FR-SQL-6.13 (Index Optimization) | a|
. Verify indexes exist on frequently queried columns.
. Execute queries using indexed columns.
. Measure query performance.
| **AC:** All required indexes exist. Queries use indexes (verify with EXPLAIN QUERY PLAN). Query performance is optimal.

| **T-SQL-15** | FR-SQL-6.14 (Vacuum and Optimization) | a|
. Perform operations that fragment database (inserts, deletes).
. Run VACUUM operation.
. Check database file size before and after.
| **AC:** VACUUM operation completes successfully. Database file size is reduced. Database integrity is maintained. ANALYZE is run after VACUUM.

|===

=== Connection and Transaction Testing

[cols="1, 2, 4, 3", options="headers"]
|===
^.^| Test Case ID ^.^| Requirement Covered ^.^| Test Steps ^.^| Expected Result (Acceptance Criteria)

| **T-SQL-16** | FR-SQL-6.15 (Connection Pooling) | a|
. Launch Reader application.
. Open multiple cartridges simultaneously.
. Verify connection management.
| **AC:** Local database uses single connection (Singleton). Each cartridge has separate connection (Per-Instance). Connections are managed correctly.

| **T-SQL-17** | FR-SQL-6.16 (Connection Timeout) | a|
. Lock database file externally (simulate locked database).
. Attempt to open database in Reader.
. Monitor timeout behavior.
| **AC:** Connection timeout occurs after 30 seconds. Retry logic with exponential backoff is used. Maximum 3 retry attempts. Error is displayed after timeout.

| **T-SQL-18** | FR-SQL-6.17 (Busy Handler) | a|
. Open database in one Reader instance.
. Attempt to write to same database from another instance.
. Verify busy handler behavior.
| **AC:** Busy handler waits up to 5 seconds. Exponential backoff is used. SQLITE_BUSY error is returned if lock persists. Error is handled gracefully.

| **T-SQL-19** | FR-SQL-6.18 (Transaction Usage) | a|
. Perform form data save operation.
. Verify transaction is used.
. Simulate error during save.
. Verify rollback occurs.
| **AC:** Transaction is used for form data save. All operations are atomic. Rollback occurs on error. Data integrity is maintained.

| **T-SQL-20** | FR-SQL-6.19 (Transaction Isolation) | a|
. Open same cartridge in two Reader instances.
. Perform writes from both instances.
. Verify isolation behavior.
| **AC:** Transactions are properly isolated. WAL mode allows concurrent reads. Writes are serialized correctly. No data corruption occurs.

| **T-SQL-21** | FR-SQL-6.20 (Savepoint Support) | a|
. Perform complex operation using savepoints.
. Simulate error at intermediate step.
. Verify rollback to savepoint.
| **AC:** Savepoints are created correctly. Rollback to savepoint works. Partial operations can be rolled back. Transaction integrity is maintained.

|===

=== Error Handling and Recovery Testing

[cols="1, 2, 4, 3", options="headers"]
|===
^.^| Test Case ID ^.^| Requirement Covered ^.^| Test Steps ^.^| Expected Result (Acceptance Criteria)

| **T-SQL-22** | FR-SQL-6.21 (Integrity Checks - Quick) | a|
. Open cartridge in Reader.
. Perform quick integrity check.
. Verify check completes.
| **AC:** Quick integrity check is performed on cartridge open. Check completes quickly (< 1 second for typical cartridge). Results are logged. "ok" result indicates integrity.

| **T-SQL-23** | FR-SQL-6.21 (Integrity Checks - Full) | a|
. Suspect database corruption.
. Perform full integrity check.
. Verify check completes.
| **AC:** Full integrity check is performed. Check is comprehensive. Results are logged. Errors are reported if corruption detected.

| **T-SQL-24** | FR-SQL-6.22 (Corruption Recovery) | a|
. Corrupt database file (manually alter bytes).
. Attempt to open in Reader.
. Verify recovery attempt.
| **AC:** Corruption is detected. Recovery is attempted using .dump/.read. Recovered data is logged. User is notified of recovery status. Maximum data is recovered.

| **T-SQL-25** | FR-SQL-6.23 (Backup and Restore) | a|
. Perform schema migration operation.
. Verify backup is created before migration.
. Simulate migration failure.
. Restore from backup.
| **AC:** Backup is created before major operations. Backup file is stored in backup directory. Backup can be restored. Database is restored to pre-operation state.

|===

=== Performance Testing

[cols="1, 2, 4, 3", options="headers"]
|===
^.^| Test Case ID ^.^| Requirement Covered ^.^| Test Steps ^.^| Expected Result (Acceptance Criteria)

| **T-SQL-26** | WAL Mode Performance | a|
. Create database with WAL mode disabled.
. Perform mixed read/write operations.
. Enable WAL mode.
. Perform same operations.
. Compare performance.
| **AC:** WAL mode provides better performance for mixed workloads. Concurrent reads don't block writes. Performance improvement is measurable.

| **T-SQL-27** | Cache Size Performance | a|
. Configure different cache sizes.
. Execute same queries.
. Measure query performance.
| **AC:** Larger cache sizes improve query performance. Optimal cache size is identified. Performance improvement is measurable.

| **T-SQL-28** | Index Performance | a|
. Execute queries on indexed columns.
. Execute queries on non-indexed columns.
. Compare performance.
| **AC:** Indexed queries are significantly faster. Index usage is verified with EXPLAIN QUERY PLAN. Performance difference is measurable.

| **T-SQL-29** | Transaction Performance | a|
. Perform operations with transactions.
. Perform same operations without transactions.
. Compare performance and data integrity.
| **AC:** Transactions maintain data integrity. Performance impact is minimal. Atomicity is guaranteed.

| **T-SQL-30** | Large Database Performance | a|
. Create database with 1000+ cartridges in manifest.
. Perform queries on large dataset.
. Measure query performance.
| **AC:** Queries complete within reasonable time (< 500ms for manifest queries). Indexes are used effectively. Performance is acceptable.

|===

=== Stress Testing

[cols="1, 2, 4, 3", options="headers"]
|===
^.^| Test Case ID ^.^| Requirement Covered ^.^| Test Steps ^.^| Expected Result (Acceptance Criteria)

| **T-SQL-31** | Concurrent Access | a|
. Open same cartridge in multiple Reader instances.
. Perform simultaneous reads and writes.
. Verify data integrity.
| **AC:** Concurrent access works correctly with WAL mode. Reads don't block each other. Writes are serialized. No data corruption occurs.

| **T-SQL-32** | High Write Load | a|
. Perform rapid write operations (100+ writes per second).
. Monitor WAL file growth.
. Verify checkpoint behavior.
| **AC:** WAL file grows during high write load. Checkpoint occurs when threshold reached. WAL file size is managed. Performance remains acceptable.

| **T-SQL-33** | Large Transaction | a|
. Perform transaction with 1000+ operations.
. Verify transaction completes.
. Verify atomicity.
| **AC:** Large transaction completes successfully. All operations are atomic. Rollback works if transaction fails. Performance is acceptable.

| **T-SQL-34** | Database Size Limits | a|
. Create database approaching SQLite size limits (140TB theoretical).
. Perform operations on large database.
. Verify performance.
| **AC:** Database handles large sizes correctly. Performance degrades gracefully. Operations complete successfully. No errors occur.

|===

== Implementation Checklist

=== Reader Application

- [ ] Detect SQLite version at startup
- [ ] Verify minimum version (3.51)
- [ ] Enable WAL mode for local database
- [ ] Configure WAL checkpoint (10MB or 1000 pages)
- [ ] Set page size to 4096 bytes (for new databases)
- [ ] Configure cache size (2000 pages for local, 1000 for cartridges)
- [ ] Set synchronous mode to NORMAL
- [ ] Enable foreign key constraints per connection
- [ ] Run ANALYZE after bulk operations
- [ ] Implement integrity checks (quick and full)
- [ ] Implement backup before migrations
- [ ] Configure connection timeouts and busy handler
- [ ] Use transactions for all multi-step operations
- [ ] Implement VACUUM operation

=== Creator Tool

- [ ] Detect SQLite version at startup
- [ ] Enable WAL mode for cartridge files
- [ ] Configure cache size for cartridges
- [ ] Set page size to 4096 bytes (for new cartridges)
- [ ] Enable foreign key constraints
- [ ] Use transactions for all operations
- [ ] Use savepoints for complex operations
- [ ] Implement integrity checks
- [ ] Run ANALYZE after significant changes

== Best Practices Summary

=== Configuration Best Practices

. **WAL Mode:** Always use WAL mode for better concurrency and performance
. **Page Size:** Use 4096 bytes (4KB) for optimal performance
. **Cache Size:** Configure appropriate cache size based on database usage
. **Synchronous:** Use NORMAL mode with WAL (safe and performant)
. **Foreign Keys:** Always enable foreign key constraints
. **Transactions:** Use transactions for all multi-step operations
. **Indexes:** Ensure all frequently queried columns are indexed
. **ANALYZE:** Run ANALYZE after significant data changes
. **Integrity Checks:** Perform periodic integrity checks
. **Backups:** Create backups before major operations

=== Performance Best Practices

. **Connection Management:** Open connections on-demand, close when done
. **Transaction Scope:** Keep transactions as short as possible
. **Batch Operations:** Use batch inserts/updates for bulk operations
. **Index Usage:** Verify indexes are used with EXPLAIN QUERY PLAN
. **Query Optimization:** Use prepared statements for repeated queries
. **WAL Checkpointing:** Monitor WAL file size and checkpoint appropriately
. **Vacuum:** Run VACUUM periodically to reduce fragmentation

=== Security Best Practices

. **Input Validation:** Always validate and sanitize user input
. **Prepared Statements:** Use prepared statements to prevent SQL injection
. **Transaction Rollback:** Always rollback transactions on error
. **Integrity Checks:** Verify database integrity regularly
. **Backup Strategy:** Maintain backups for recovery

== Summary

This specification provides comprehensive SQLite configuration requirements, design, and testing:

* **Requirements:** 23 functional requirements (FR-SQL-6.1 through FR-SQL-6.23) covering version, WAL mode, optimization, connection management, transactions, and error handling
* **Design:** Complete implementation specifications with code examples for all configuration settings
* **Testing:** 34 test cases covering functional, connection, transaction, error handling, performance, and stress testing
* **Best Practices:** Summary of configuration, performance, and security best practices

The specification ensures SQLite is properly configured for performance, reliability, and data integrity in both Reader and Creator Tool applications.
